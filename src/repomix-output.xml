This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-15T12:50:24.472Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
client/java/ninja/trek/pocketportals/mixin/client/ClientWorldMixin.java
client/java/ninja/trek/pocketportals/mixin/client/ExampleClientMixin.java
client/java/ninja/trek/pocketportals/PocketPortalsClient.java
client/java/ninja/trek/pocketportals/PocketPortalsDataGenerator.java
client/resources/pocket-portals.client.mixins.json
main/java/ninja/trek/pocketportals/block/ModBlocks.java
main/java/ninja/trek/pocketportals/block/PocketPortalBlock.java
main/java/ninja/trek/pocketportals/block/PocketPortalBlockEntity.java
main/java/ninja/trek/pocketportals/block/PocketPortalFrame.java
main/java/ninja/trek/pocketportals/block/ReturnPocketPortalBlock.java
main/java/ninja/trek/pocketportals/block/ReturnPocketPortalBlockEntity.java
main/java/ninja/trek/pocketportals/data/DataLoader.java
main/java/ninja/trek/pocketportals/data/PocketPortalDataTypes.java
main/java/ninja/trek/pocketportals/dimension/GridBiomeSource.java
main/java/ninja/trek/pocketportals/dimension/GridSpawnRules.java
main/java/ninja/trek/pocketportals/dimension/ModDimensions.java
main/java/ninja/trek/pocketportals/dimension/PocketDimensionJsonProvider.java
main/java/ninja/trek/pocketportals/dimension/PocketDimensionsRegistry.java
main/java/ninja/trek/pocketportals/dimension/SkyIslandChunkGenerator.java
main/java/ninja/trek/pocketportals/item/ModItems.java
main/java/ninja/trek/pocketportals/item/PocketPortalItem.java
main/java/ninja/trek/pocketportals/mixin/ExampleMixin.java
main/java/ninja/trek/pocketportals/mixin/SpawnHelperMixin.java
main/java/ninja/trek/pocketportals/network/SpawnRulesPacket.java
main/java/ninja/trek/pocketportals/PocketPortals.java
main/java/ninja/trek/pocketportals/PocketPortalsDataGenerator.java
main/java/ninja/trek/pocketportals/SpawnRulesData.java
main/resources/assets/pocket-portals/models/block/pocket_portal_frame.json
main/resources/fabric.mod.json
main/resources/pocket-portals.mixins.json
repomixx.bat
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="client/java/ninja/trek/pocketportals/mixin/client/ClientWorldMixin.java">
package ninja.trek.pocketportals.mixin.client;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.world.ClientWorld;
import net.minecraft.entity.EntityType;
import net.minecraft.text.Text;
import net.minecraft.util.hit.BlockHitResult;
import net.minecraft.util.hit.HitResult;
import ninja.trek.pocketportals.SpawnRulesData;
import ninja.trek.pocketportals.block.ModBlocks;
import ninja.trek.pocketportals.block.PocketPortalBlockEntity;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
import java.util.Map;
import java.util.stream.Collectors;
@Mixin(ClientWorld.class)
public class ClientWorldMixin {
    @Inject(method = "tick", at = @At("HEAD"))
    private void onTick(CallbackInfo ci) {
        MinecraftClient client = MinecraftClient.getInstance();
        if (client.player == null) return;
        HitResult hit = client.crosshairTarget;
        if (hit == null || hit.getType() != HitResult.Type.BLOCK) return;
        BlockHitResult blockHit = (BlockHitResult) hit;
        ClientWorld world = (ClientWorld) (Object) this;
        if (world.getBlockState(blockHit.getBlockPos()).isOf(ModBlocks.POCKET_PORTAL_FRAME)) {
            // Look for portal base block
            for (int y = 0; y > -3; y--) {
                var basePos = blockHit.getBlockPos().add(0, y, 0);
                if (world.getBlockState(basePos).isOf(ModBlocks.POCKET_PORTAL)) {
                    var blockEntity = world.getBlockEntity(basePos);
                    if (blockEntity instanceof PocketPortalBlockEntity portalBE) {
                        Integer dimensionIndex = portalBE.getDimensionIndex();
                        if (dimensionIndex != null) {
                            Map<EntityType<?>, Boolean> rules = SpawnRulesData.getSpawnRules(dimensionIndex);
                            if (!rules.isEmpty()) {
                                // Count disabled spawns
                                long disabledCount = rules.values().stream().filter(allowed -> !allowed).count();
                                String overlay;
                                if (disabledCount == rules.size()) {
                                    overlay = "ยง7All mob spawns disabled";
                                } else if (disabledCount > 0) {
                                    overlay = "ยง7Disabled spawns: " +
                                            rules.entrySet().stream()
                                                    .filter(e -> !e.getValue())
                                                    .map(e -> e.getKey().getName().getString())
                                                    .collect(Collectors.joining(", "));
                                } else {
                                    overlay = "ยง7All mob spawns enabled";
                                }
                                client.player.sendMessage(Text.literal(overlay), true);
                            }
                        }
                        break;
                    }
                }
            }
        }
    }
}
</file>

<file path="client/java/ninja/trek/pocketportals/mixin/client/ExampleClientMixin.java">
package ninja.trek.pocketportals.mixin.client;
import net.minecraft.client.MinecraftClient;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(MinecraftClient.class)
public class ExampleClientMixin {
	@Inject(at = @At("HEAD"), method = "run")
	private void init(CallbackInfo info) {
		// This code is injected into the start of MinecraftClient.run()V
	}
}
</file>

<file path="client/java/ninja/trek/pocketportals/PocketPortalsClient.java">
package ninja.trek.pocketportals;
import net.fabricmc.api.ClientModInitializer;
import net.fabricmc.fabric.api.client.networking.v1.ClientPlayNetworking;
import net.fabricmc.fabric.api.networking.v1.PacketSender;
import net.minecraft.client.MinecraftClient;
import ninja.trek.pocketportals.network.SpawnRulesPacket;
public class PocketPortalsClient implements ClientModInitializer {
	@Override
	public void onInitializeClient() {
		// Register the receiver for SpawnRulesPacket.
		ClientPlayNetworking.<SpawnRulesPacket>registerGlobalReceiver(
				SpawnRulesPacket.ID,
				(SpawnRulesPacket packet, PacketSender sender) -> {
					MinecraftClient.getInstance().execute(() -> {
						SpawnRulesData.setSpawnRules(packet.dimensionIndex(), packet.rules());
					});
				}
		);
	}
}
</file>

<file path="client/java/ninja/trek/pocketportals/PocketPortalsDataGenerator.java">
package ninja.trek.pocketportals;
import net.fabricmc.fabric.api.datagen.v1.DataGeneratorEntrypoint;
import net.fabricmc.fabric.api.datagen.v1.FabricDataGenerator;
public class PocketPortalsDataGenerator implements DataGeneratorEntrypoint {
	@Override
	public void onInitializeDataGenerator(FabricDataGenerator fabricDataGenerator) {
	}
}
</file>

<file path="client/resources/pocket-portals.client.mixins.json">
{
	"required": true,
	"package": "ninja.trek.pocketportals.mixin.client",
	"compatibilityLevel": "JAVA_21",
	"client": [
		"ExampleClientMixin"
	],
	"injectors": {
		"defaultRequire": 1
	}
}
</file>

<file path="main/java/ninja/trek/pocketportals/block/ModBlocks.java">
package ninja.trek.pocketportals.block;
import com.mojang.serialization.MapCodec;
import net.fabricmc.fabric.api.object.builder.v1.block.FabricBlockSettings;
import net.fabricmc.fabric.api.object.builder.v1.block.entity.FabricBlockEntityTypeBuilder;
import net.minecraft.block.BlockRenderType;
import net.minecraft.block.BlockState;
import net.minecraft.block.BlockWithEntity;
import net.minecraft.block.Blocks;
import net.minecraft.block.entity.BlockEntity;
import net.minecraft.block.entity.BlockEntityType;
import net.minecraft.entity.Entity;
import net.minecraft.entity.LivingEntity;
import net.minecraft.item.ItemStack;
import net.minecraft.registry.Registries;
import net.minecraft.registry.Registry;
import net.minecraft.util.Identifier;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.World;
import ninja.trek.pocketportals.PocketPortals;
import ninja.trek.pocketportals.block.*;
public class ModBlocks {
    public static final PocketPortalBlock POCKET_PORTAL = new PocketPortalBlock(
            FabricBlockSettings.create()
                    .strength(3.0f)
                    .requiresTool()
                    .nonOpaque()
    );
    public static final ReturnPocketPortalBlock RETURN_POCKET_PORTAL = new ReturnPocketPortalBlock(
            FabricBlockSettings.create()
                    .strength(3.0f)
                    .requiresTool()
                    .nonOpaque()
    );
    public static final PocketPortalFrame POCKET_PORTAL_FRAME = new PocketPortalFrame(
            FabricBlockSettings.create()
                    .luminance(state -> 11)
                    .noCollision()
                    .strength(-1.0F)
    );
    public static final BlockEntityType<PocketPortalBlockEntity> POCKET_PORTAL_BLOCK_ENTITY =
            FabricBlockEntityTypeBuilder.create(
                    PocketPortalBlockEntity::new,
                    POCKET_PORTAL
            ).build();
    public static final BlockEntityType<ReturnPocketPortalBlockEntity> RETURN_PORTAL_BLOCK_ENTITY =
            FabricBlockEntityTypeBuilder.create(
                    ReturnPocketPortalBlockEntity::new,
                    RETURN_POCKET_PORTAL
            ).build();
    public static void registerBlocks() {
        Registry.register(
                Registries.BLOCK,
                Identifier.of(PocketPortals.MOD_ID, "pocket_portal"),
                POCKET_PORTAL
        );
        Registry.register(
                Registries.BLOCK,
                Identifier.of(PocketPortals.MOD_ID, "return_pocket_portal"),
                RETURN_POCKET_PORTAL
        );
        Registry.register(
                Registries.BLOCK,
                Identifier.of(PocketPortals.MOD_ID, "pocket_portal_frame"),
                POCKET_PORTAL_FRAME
        );
        Registry.register(
                Registries.BLOCK_ENTITY_TYPE,
                Identifier.of(PocketPortals.MOD_ID, "pocket_portal_entity"),
                POCKET_PORTAL_BLOCK_ENTITY
        );
        Registry.register(
                Registries.BLOCK_ENTITY_TYPE,
                Identifier.of(PocketPortals.MOD_ID, "return_portal_entity"),
                RETURN_PORTAL_BLOCK_ENTITY
        );
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/block/PocketPortalBlock.java">
package ninja.trek.pocketportals.block;
import com.mojang.serialization.MapCodec;
import net.minecraft.block.Block;
import net.minecraft.block.BlockRenderType;
import net.minecraft.block.BlockState;
import net.minecraft.block.BlockWithEntity;
import net.minecraft.block.Blocks;
import net.minecraft.block.HorizontalFacingBlock;
import net.minecraft.block.entity.BlockEntity;
import net.minecraft.entity.Entity;
import net.minecraft.entity.LivingEntity;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.item.ItemStack;
import net.minecraft.server.world.ServerWorld;
import net.minecraft.state.StateManager;
import net.minecraft.state.property.DirectionProperty;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.World;
import ninja.trek.pocketportals.dimension.PocketDimensionsRegistry;
import static ninja.trek.pocketportals.data.PocketPortalDataTypes.DIMENSION_INDEX;
public class PocketPortalBlock extends BlockWithEntity {
    public static final DirectionProperty FACING = HorizontalFacingBlock.FACING;
    public static final MapCodec<PocketPortalBlock> CODEC = createCodec(PocketPortalBlock::new);
    public PocketPortalBlock(Settings settings) {
        super(Settings.copy(Blocks.STONE)
                .strength(3.0f)
                .requiresTool()
                .nonOpaque());
        setDefaultState(getStateManager().getDefaultState());
    }
    @Override
    protected MapCodec<? extends BlockWithEntity> getCodec() {
        return CODEC;
    }
    @Override
    public BlockRenderType getRenderType(BlockState state) {
        return BlockRenderType.MODEL;
    }
    @Override
    protected void appendProperties(StateManager.Builder<Block, BlockState> builder) {
        builder.add(FACING);
    }
    @Override
    public BlockEntity createBlockEntity(BlockPos pos, BlockState state) {
        return new PocketPortalBlockEntity(pos, state);
    }
    // In PocketPortalBlock.java, modify the onPlaced method:
    @Override
    public void onPlaced(World world, BlockPos pos, BlockState state, LivingEntity placer, ItemStack stack) {
        super.onPlaced(world, pos, state, placer, stack);
        if (!world.isClient) {
            BlockEntity blockEntity = world.getBlockEntity(pos);
            if (blockEntity instanceof PocketPortalBlockEntity portalBE) {
                // Read dimension index from the item's components
                Integer storedIndex = stack.get(DIMENSION_INDEX);
                // If none present, get a new unused one
                if (storedIndex == null) {
                    storedIndex = PocketDimensionsRegistry.findUnusedSlot(((ServerWorld)world).getServer());
                }
                // Set it in the block entity
                portalBE.setDimensionIndex(storedIndex);
                portalBE.markDirty();
                // Create frame blocks above
                BlockPos portalPos1 = pos.up();
                BlockPos portalPos2 = portalPos1.up();
                world.setBlockState(portalPos1, ModBlocks.POCKET_PORTAL_FRAME.getDefaultState());
                world.setBlockState(portalPos2, ModBlocks.POCKET_PORTAL_FRAME.getDefaultState());
            }
        }
    }
    @Override
    public void onEntityCollision(BlockState state, World world, BlockPos pos, Entity entity) {
        if (!world.isClient) {
            // Only allow teleportation from overworld
            if (!world.getRegistryKey().equals(World.OVERWORLD)) {
                return;
            }
            BlockEntity be = world.getBlockEntity(pos);
            if (be instanceof PocketPortalBlockEntity portalBE) {
                portalBE.handleEntityCollision(entity);
            }
        }
    }
    @Override
    public BlockState onBreak(World world, BlockPos pos, BlockState state, PlayerEntity player) {
        if (!world.isClient) {
            BlockEntity be = world.getBlockEntity(pos);
            if (be instanceof PocketPortalBlockEntity portalBE) {
                Integer dimIndex = portalBE.getDimensionIndex();
                // Create a new item with the dimension index
                ItemStack newStack = new ItemStack(ModBlocks.POCKET_PORTAL);
                if (dimIndex != null) {
                    // Store using item components
                    newStack.set(DIMENSION_INDEX, dimIndex);
                }
                // Drop the item
                Block.dropStack(world, pos, newStack);
            }
        }
        // Remove frames above
        world.setBlockState(pos.up(), Blocks.AIR.getDefaultState());
        world.setBlockState(pos.up(2), Blocks.AIR.getDefaultState());
        return super.onBreak(world, pos, state, player);
    }
    @Override
    public void onStateReplaced(BlockState state, World world, BlockPos pos,
                                BlockState newState, boolean moved) {
        if (!state.isOf(newState.getBlock())) {
            // Remove frame blocks
            world.setBlockState(pos.up(), Blocks.AIR.getDefaultState());
            world.setBlockState(pos.up(2), Blocks.AIR.getDefaultState());
        }
        super.onStateReplaced(state, world, pos, newState, moved);
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/block/PocketPortalBlockEntity.java">
package ninja.trek.pocketportals.block;
import net.fabricmc.fabric.api.networking.v1.PacketByteBufs;
import net.fabricmc.fabric.api.networking.v1.ServerPlayNetworking;
import net.minecraft.block.BlockState;
import net.minecraft.block.entity.BlockEntity;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityType;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.nbt.NbtCompound;
import net.minecraft.network.PacketByteBuf;
import net.minecraft.network.packet.s2c.play.PositionFlag;
import net.minecraft.registry.RegistryWrapper;
import net.minecraft.server.network.ServerPlayerEntity;
import net.minecraft.server.world.ServerWorld;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.Heightmap;
import ninja.trek.pocketportals.PocketPortals;
import ninja.trek.pocketportals.SpawnRulesData;
import ninja.trek.pocketportals.dimension.GridSpawnRules;
import ninja.trek.pocketportals.dimension.ModDimensions;
import ninja.trek.pocketportals.dimension.PocketDimensionsRegistry;
import ninja.trek.pocketportals.network.SpawnRulesPacket;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.Map;
public class PocketPortalBlockEntity extends BlockEntity {
    private static final String DIMENSION_INDEX_KEY = "PocketDimensionIndex";
    private Integer dimensionIndex = null; // store an index from 0..255
    public PocketPortalBlockEntity(BlockPos pos, BlockState state) {
        super(ModBlocks.POCKET_PORTAL_BLOCK_ENTITY, pos, state);
    }
    public Integer getDimensionIndex() {
        return dimensionIndex;
    }
    public void setDimensionIndex(Integer dimensionIndex) {
        this.dimensionIndex = dimensionIndex;
    }
    @Override
    public void readNbt(NbtCompound nbt, RegistryWrapper.WrapperLookup lookup) {
        super.readNbt(nbt, lookup);
        if (nbt.contains(DIMENSION_INDEX_KEY)) {
            dimensionIndex = nbt.getInt(DIMENSION_INDEX_KEY);
        }
    }
    @Override
    public void writeNbt(NbtCompound nbt, RegistryWrapper.WrapperLookup lookup) {
        super.writeNbt(nbt, lookup);
        if (dimensionIndex != null) {
            nbt.putInt(DIMENSION_INDEX_KEY, dimensionIndex);
        }
    }
    // In PocketPortalBlockEntity.java, modify handleEntityCollision:
    public void handleEntityCollision(Entity entity) {
        if (!(world instanceof ServerWorld serverWorld)) return;
        if (!entity.canUsePortals(false)) return;
        if (dimensionIndex == null) {
            PocketPortals.LOGGER.warn("Portal block has no dimension index assigned!");
            return;
        }
        if (entity.hasPortalCooldown()) {
            return;
        }
        // Set portal cooldown (20 ticks = 1 second)
        entity.setPortalCooldown(20);
        // Get the target dimension
        ServerWorld targetWorld = serverWorld.getServer().getWorld(PocketDimensionsRegistry.getDimensionKey());
        if (targetWorld == null) {
            PocketPortals.LOGGER.error("Pocket dimension is not loaded!");
            return;
        }
        // Are we already in the pocket dimension?
        if (serverWorld.getRegistryKey().equals(PocketDimensionsRegistry.getDimensionKey())) {
            // Then go back to Overworld
            ServerWorld overworld = serverWorld.getServer().getOverworld();
            teleportEntity(entity, overworld, pos.getX() + 0.5, pos.getY() + 1, pos.getZ() + 0.5);
        } else {
            // Calculate grid position from index
            ModDimensions.GridPosition gridPos = ModDimensions.indexToGridPosition(dimensionIndex);
            ModDimensions.WorldPosition worldPos = ModDimensions.gridToWorldPosition(gridPos);
            // Teleport to the specific grid location in the pocket dimension
            teleportEntity(entity, targetWorld,
                    worldPos.x() + 0.5, worldPos.y() + 1, worldPos.z() + 0.5);
            // Build return portal at the destination
            BlockPos base = new BlockPos(worldPos.x() + 2, worldPos.y(), worldPos.z());
            // Create RETURN portal block
            targetWorld.setBlockState(base, ModBlocks.RETURN_POCKET_PORTAL.getDefaultState());
            targetWorld.setBlockState(base.up(), ModBlocks.POCKET_PORTAL_FRAME.getDefaultState());
            targetWorld.setBlockState(base.up(2), ModBlocks.POCKET_PORTAL_FRAME.getDefaultState());
            // Set up the return portal block entity
            BlockEntity be = targetWorld.getBlockEntity(base);
            if (be instanceof ReturnPocketPortalBlockEntity returnPortalBE) {
                // Store the entry Y position instead of the block's Y position
                BlockPos returnPos = new BlockPos(pos.getX(), entity.getBlockY(), pos.getZ());
                returnPortalBE.setReturnPosition(returnPos, world.getRegistryKey());
                returnPortalBE.markDirty();
            }
        }
    }
    private void teleportEntity(Entity entity, ServerWorld targetWorld, double x, double y, double z) {
        BlockPos.Mutable checkPos = new BlockPos.Mutable((int)x, (int)y, (int)z);
        // Get the actual height from the chunk generator
        int surfaceHeight = targetWorld.getChunkManager()
                .getChunkGenerator()
                .getHeight((int)x, (int)z,
                        Heightmap.Type.MOTION_BLOCKING,
                        targetWorld,
                        targetWorld.getChunkManager().getNoiseConfig());
        // Set our check position to the surface height
        checkPos.set((int)x, surfaceHeight, (int)z);
        // Move up until we have 2 blocks of air clearance
        while (checkPos.getY() < targetWorld.getTopY() &&
                (!targetWorld.getBlockState(checkPos).isAir() ||
                        !targetWorld.getBlockState(checkPos.up()).isAir())) {
            checkPos.move(0, 1, 0);
        }
        // Teleport to the safe position we found
        entity.teleport(
                targetWorld,
                x, checkPos.getY(), z,
                EnumSet.noneOf(PositionFlag.class),
                entity.getYaw(),
                entity.getPitch()
        );
    }
    public void syncSpawnRules(PlayerEntity player) {
        if (dimensionIndex == null || !(player instanceof ServerPlayerEntity serverPlayer)) return;
        // Get spawn rules for this dimension index
        GridSpawnRules rules = PocketDimensionsRegistry.getSpawnRules(world.getServer(), dimensionIndex);
        if (rules == null) return;
        // Create map of spawn rules
        Map<EntityType<?>, Boolean> spawnRules = new HashMap<>();
        // Add all managed mobs to the map
        for (EntityType<?> entityType : PocketDimensionsRegistry.MANAGED_MOBS) {
            spawnRules.put(entityType, rules.canSpawn(entityType));
        }
        // Create and send packet
        SpawnRulesPacket packet = new SpawnRulesPacket(dimensionIndex, spawnRules);
        ServerPlayNetworking.send(serverPlayer, packet);
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/block/PocketPortalFrame.java">
package ninja.trek.pocketportals.block;
import com.mojang.serialization.MapCodec;
import net.minecraft.block.Block;
import net.minecraft.block.BlockRenderType;
import net.minecraft.block.BlockState;
import net.minecraft.block.Blocks;
import net.minecraft.block.entity.BlockEntity;
import net.minecraft.entity.Entity;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.particle.ParticleTypes;
import net.minecraft.sound.SoundCategory;
import net.minecraft.sound.SoundEvents;
import net.minecraft.util.ActionResult;
import net.minecraft.util.Hand;
import net.minecraft.util.hit.BlockHitResult;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.random.Random;
import net.minecraft.text.Text;
import net.minecraft.world.World;
public class PocketPortalFrame extends Block {
    public static final MapCodec<PocketPortalFrame> CODEC = createCodec(PocketPortalFrame::new);
    public PocketPortalFrame(Settings settings) {
        super(Settings.copy(Blocks.NETHER_PORTAL)
                .luminance(state -> 11)
                .noCollision()
                .strength(-1.0F)
        );
    }
    @Override
    public void onEntityCollision(BlockState state, World world, BlockPos pos, Entity entity) {
        if (!world.isClient && entity.canUsePortals(false)) {
            // Find the portal base block by searching downward
            BlockPos basePos = findPortalBase(world, pos);
            if (basePos != null) {
                BlockEntity blockEntity = world.getBlockEntity(basePos);
                // Handle both types of portal bases
                if (blockEntity instanceof PocketPortalBlockEntity portalBlockEntity) {
                    portalBlockEntity.handleEntityCollision(entity);
                } else if (blockEntity instanceof ReturnPocketPortalBlockEntity returnPortalBlockEntity) {
                    returnPortalBlockEntity.handleEntityCollision(entity);
                }
            }
        }
    }
    /**
     * Allow sneak-right-click to show dimension info in chat.
     */
    @Override
    public ActionResult onUse(BlockState state, World world, BlockPos pos,
                              PlayerEntity player, BlockHitResult hit) {
        if (!world.isClient) {
            BlockPos basePos = findPortalBase(world, pos);
            if (basePos != null) {
                BlockEntity be = world.getBlockEntity(basePos);
                if (be instanceof PocketPortalBlockEntity portalBE) {
                    portalBE.syncSpawnRules(player);
                }
            }
        }
        return ActionResult.SUCCESS;
    }
    private BlockPos findPortalBase(World world, BlockPos startPos) {
        // Search downward for either type of portal base block
        BlockPos.Mutable currentPos = startPos.mutableCopy();
        for (int y = 0; y > -3; y--) {
            currentPos.move(0, y, 0);
            if (world.getBlockState(currentPos).getBlock() instanceof PocketPortalBlock ||
                    world.getBlockState(currentPos).getBlock() instanceof ReturnPocketPortalBlock) {
                return currentPos.toImmutable();
            }
        }
        return null;
    }
    @Override
    public void randomDisplayTick(BlockState state, World world, BlockPos pos, Random random) {
        if (random.nextInt(100) == 0) {
            world.playSound(
                    pos.getX() + 0.5D,
                    pos.getY() + 0.5D,
                    pos.getZ() + 0.5D,
                    SoundEvents.BLOCK_PORTAL_AMBIENT,
                    SoundCategory.BLOCKS,
                    0.5F,
                    random.nextFloat() * 0.4F + 0.8F,
                    false
            );
        }
        for(int i = 0; i < 4; ++i) {
            double x = pos.getX() + random.nextDouble();
            double y = pos.getY() + random.nextDouble();
            double z = pos.getZ() + random.nextDouble();
            double dx = (random.nextDouble() - 0.5D) * 0.5D;
            double dy = (random.nextDouble() - 0.5D) * 0.5D;
            double dz = (random.nextDouble() - 0.5D) * 0.5D;
            world.addParticle(ParticleTypes.PORTAL, x, y, z, dx, dy, dz);
        }
    }
    @Override
    public BlockRenderType getRenderType(BlockState state) {
        return BlockRenderType.MODEL;
    }
    @Override
    protected MapCodec<? extends Block> getCodec() {
        return CODEC;
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/block/ReturnPocketPortalBlock.java">
package ninja.trek.pocketportals.block;
import com.mojang.serialization.MapCodec;
import net.minecraft.block.BlockRenderType;
import net.minecraft.block.BlockState;
import net.minecraft.block.BlockWithEntity;
import net.minecraft.block.Blocks;
import net.minecraft.block.entity.BlockEntity;
import net.minecraft.entity.Entity;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.World;
import ninja.trek.pocketportals.PocketPortals;
import ninja.trek.pocketportals.block.ReturnPocketPortalBlockEntity;
import ninja.trek.pocketportals.dimension.PocketDimensionsRegistry;
public class ReturnPocketPortalBlock extends BlockWithEntity {
    public static final MapCodec<ReturnPocketPortalBlock> CODEC = createCodec(ReturnPocketPortalBlock::new);
    public ReturnPocketPortalBlock(Settings settings) {
        super(Settings.copy(Blocks.STONE)
                .strength(3.0f)
                .requiresTool()
                .nonOpaque());
    }
    @Override
    protected MapCodec<? extends BlockWithEntity> getCodec() {
        return CODEC;
    }
    @Override
    public BlockRenderType getRenderType(BlockState state) {
        return BlockRenderType.MODEL;
    }
    @Override
    public BlockEntity createBlockEntity(BlockPos pos, BlockState state) {
        return new ReturnPocketPortalBlockEntity(pos, state);
    }
    @Override
    public void onEntityCollision(BlockState state, World world, BlockPos pos, Entity entity) {
        if (!world.isClient) {
            // Only handle collision if we're in the pocket dimension
            if (!world.getRegistryKey().equals(PocketDimensionsRegistry.getDimensionKey())) {
                return;
            }
            BlockEntity be = world.getBlockEntity(pos);
            if (be instanceof ReturnPocketPortalBlockEntity returnPortalBE) {
                // Add debug logging
                PocketPortals.LOGGER.info("Entity {} collided with return portal at {}",
                        entity.getUuidAsString(), pos);
                returnPortalBE.handleEntityCollision(entity);
            }
        }
    }
    @Override
    public void onStateReplaced(BlockState state, World world, BlockPos pos,
                                BlockState newState, boolean moved) {
        if (!state.isOf(newState.getBlock())) {
            // Remove frame blocks
            world.setBlockState(pos.up(), Blocks.AIR.getDefaultState());
            world.setBlockState(pos.up(2), Blocks.AIR.getDefaultState());
        }
        super.onStateReplaced(state, world, pos, newState, moved);
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/block/ReturnPocketPortalBlockEntity.java">
package ninja.trek.pocketportals.block;
import net.minecraft.block.BlockState;
import net.minecraft.block.entity.BlockEntity;
import net.minecraft.entity.Entity;
import net.minecraft.nbt.NbtCompound;
import net.minecraft.network.packet.s2c.play.PositionFlag;
import net.minecraft.registry.RegistryKey;
import net.minecraft.registry.RegistryKeys;
import net.minecraft.registry.RegistryWrapper;
import net.minecraft.server.world.ServerWorld;
import net.minecraft.sound.SoundCategory;
import net.minecraft.sound.SoundEvents;
import net.minecraft.util.Identifier;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.World;
import ninja.trek.pocketportals.PocketPortals;
import java.util.EnumSet;
public class ReturnPocketPortalBlockEntity extends BlockEntity {
    private static final String RETURN_POS_X = "ReturnPosX";
    private static final String RETURN_POS_Y = "ReturnPosY";
    private static final String RETURN_POS_Z = "ReturnPosZ";
    private static final String RETURN_DIMENSION = "ReturnDimension";
    private BlockPos returnPosition;
    private RegistryKey<World> returnDimension;
    public ReturnPocketPortalBlockEntity(BlockPos pos, BlockState state) {
        super(ModBlocks.RETURN_PORTAL_BLOCK_ENTITY, pos, state);
    }
    public void setReturnPosition(BlockPos pos, RegistryKey<World> dimension) {
        this.returnPosition = pos;
        this.returnDimension = dimension;
        markDirty();
        PocketPortals.LOGGER.info("Set return portal destination: pos={}, dim={}",
                pos, dimension.getValue());
    }
    @Override
    public void readNbt(NbtCompound nbt, RegistryWrapper.WrapperLookup lookup) {
        super.readNbt(nbt, lookup);
        if (nbt.contains(RETURN_POS_X)) {
            int x = nbt.getInt(RETURN_POS_X);
            int y = nbt.getInt(RETURN_POS_Y);
            int z = nbt.getInt(RETURN_POS_Z);
            returnPosition = new BlockPos(x, y, z);
            String dimId = nbt.getString(RETURN_DIMENSION);
            returnDimension = RegistryKey.of(RegistryKeys.WORLD, Identifier.of(dimId));
            PocketPortals.LOGGER.info("Loaded return portal data: pos={}, dim={}",
                    returnPosition, returnDimension.getValue());
        }
    }
    @Override
    public void writeNbt(NbtCompound nbt, RegistryWrapper.WrapperLookup lookup) {
        super.writeNbt(nbt, lookup);
        if (returnPosition != null && returnDimension != null) {
            nbt.putInt(RETURN_POS_X, returnPosition.getX());
            nbt.putInt(RETURN_POS_Y, returnPosition.getY());
            nbt.putInt(RETURN_POS_Z, returnPosition.getZ());
            nbt.putString(RETURN_DIMENSION, returnDimension.getValue().toString());
            PocketPortals.LOGGER.info("Saved return portal data: pos={}, dim={}",
                    returnPosition, returnDimension.getValue());
        }
    }
    private BlockPos findSafeReturnLocation(ServerWorld targetWorld, BlockPos originalPos) {
        // First check if the portal and frames are still there
        if (targetWorld.getBlockState(originalPos).getBlock() instanceof PocketPortalBlock) {
            // Portal block exists, use original position
            return originalPos;
        }
        // Portal is gone, need to find safe spot
        BlockPos.Mutable checkPos = new BlockPos.Mutable(
                originalPos.getX(),
                originalPos.getY(),
                originalPos.getZ()
        );
        // First try to find ground below
        for (int y = originalPos.getY(); y >= targetWorld.getBottomY(); y--) {
            checkPos.setY(y);
            if (targetWorld.getBlockState(checkPos).isSolid()) {
                // Found solid ground, return position above it
                return checkPos.up().toImmutable();
            }
        }
        // Search up and down from original Y
        int originalY = originalPos.getY();
        int searchRadius = 10;
        // Search downward first (preferred)
        for (int y = originalY - 1; y >= Math.max(targetWorld.getBottomY(), originalY - searchRadius); y--) {
            checkPos.setY(y);
            if (isSafeSpot(targetWorld, checkPos)) {
                return checkPos.toImmutable();
            }
        }
        // Then search upward
        for (int y = originalY + 1; y <= Math.min(targetWorld.getTopY() - 2, originalY + searchRadius); y++) {
            checkPos.setY(y);
            if (isSafeSpot(targetWorld, checkPos)) {
                return checkPos.toImmutable();
            }
        }
        // If still no safe spot, find highest solid block
        for (int y = Math.min(originalY + 5, targetWorld.getTopY()); y >= targetWorld.getBottomY(); y--) {
            checkPos.setY(y);
            if (targetWorld.getBlockState(checkPos).isSolid()) {
                return checkPos.up().toImmutable();
            }
        }
        // Last resort - return to y=64
        return new BlockPos(originalPos.getX(), 64, originalPos.getZ());
    }
    private boolean isSafeSpot(ServerWorld world, BlockPos pos) {
        // Check if we have solid ground below
        if (!world.getBlockState(pos.down()).isSolid()) {
            return false;
        }
        // Check if we have 2 air blocks for the player
        if (!world.getBlockState(pos).isAir() ||
                !world.getBlockState(pos.up()).isAir()) {
            return false;
        }
        return true;
    }
    public void handleEntityCollision(Entity entity) {
        if (!(world instanceof ServerWorld serverWorld)) {
            PocketPortals.LOGGER.error("Return portal not in server world!");
            return;
        }
        if (!entity.canUsePortals(false)) {
            PocketPortals.LOGGER.debug("Entity cannot use portals: {}", entity);
            return;
        }
        if (returnPosition == null || returnDimension == null) {
            PocketPortals.LOGGER.error("Return portal missing destination data: pos={}, dim={}",
                    returnPosition, returnDimension);
            return;
        }
        // Get the target world
        ServerWorld targetWorld = serverWorld.getServer().getWorld(returnDimension);
        if (targetWorld == null) {
            PocketPortals.LOGGER.error("Target world not found: {}", returnDimension.getValue());
            return;
        }
        // Find a safe return location
        BlockPos safePos = findSafeReturnLocation(targetWorld, returnPosition);
        PocketPortals.LOGGER.info("Found safe return location: {} (original was {})",
                safePos, returnPosition);
        // Only apply cooldown if teleport is successful
        if (entity.hasPortalCooldown()) {
            PocketPortals.LOGGER.debug("Entity {} has portal cooldown", entity.getUuidAsString());
            return;
        }
        // Reduced cooldown from 1000 to 100 ticks (5 seconds)
        entity.setPortalCooldown(100);
        // Perform the teleport
        boolean success = entity.teleport(
                targetWorld,
                safePos.getX() + 0.5,
                safePos.getY(),
                safePos.getZ() + 0.5,
                EnumSet.noneOf(PositionFlag.class),
                entity.getYaw(),
                entity.getPitch()
        );
        if (success) {
            // Play portal sound
            world.playSound(null, pos,
                    SoundEvents.BLOCK_PORTAL_TRAVEL,
                    SoundCategory.BLOCKS,
                    0.25f,
                    1.0f);
            PocketPortals.LOGGER.info("Successfully teleported entity {} to {}",
                    entity.getUuidAsString(), safePos);
        } else {
            PocketPortals.LOGGER.error("Failed to teleport entity {} to {}",
                    entity.getUuidAsString(), safePos);
        }
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/data/DataLoader.java">
package ninja.trek.pocketportals.data;
import net.fabricmc.fabric.api.resource.ResourceManagerHelper;
import net.fabricmc.fabric.api.resource.SimpleSynchronousResourceReloadListener;
import net.minecraft.resource.ResourceManager;
import net.minecraft.resource.ResourceType;
import net.minecraft.util.Identifier;
import ninja.trek.pocketportals.PocketPortals;
public class DataLoader {
    public static void register() {
        ResourceManagerHelper.get(ResourceType.SERVER_DATA).registerReloadListener(
                new SimpleSynchronousResourceReloadListener() {
                    @Override
                    public Identifier getFabricId() {
                        return Identifier.of(PocketPortals.MOD_ID, "dimension_loader");
                    }
                    @Override
                    public void reload(ResourceManager manager) {
                        // Check for dimension type file
                        Identifier dimTypeId = Identifier.of(PocketPortals.MOD_ID, "dimension_type/pocket_dimension_type.json");
                        if (manager.getResource(dimTypeId).isPresent()) {
                            PocketPortals.LOGGER.info("Found pocket dimension type configuration");
                        } else {
                            PocketPortals.LOGGER.error("Missing pocket dimension type configuration at {}", dimTypeId);
                        }
                        // Check for dimension file
                        Identifier dimId = Identifier.of(PocketPortals.MOD_ID, "dimension/pocket_dimension.json");
                        if (manager.getResource(dimId).isPresent()) {
                            PocketPortals.LOGGER.info("Found pocket dimension configuration");
                        } else {
                            PocketPortals.LOGGER.error("Missing pocket dimension configuration at {}", dimId);
                        }
                    }
                }
        );
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/data/PocketPortalDataTypes.java">
package ninja.trek.pocketportals.data;
import com.mojang.serialization.Codec;
import net.minecraft.component.ComponentType;
import net.minecraft.network.RegistryByteBuf;
import net.minecraft.network.codec.PacketCodec;
import net.minecraft.util.Identifier;
/**
 * Defines a custom ComponentType<Integer> for storing a dimension index
 * in an item or block entity, using Minecraft 1.21's new item component system.
 */
public final class PocketPortalDataTypes {
    /**
     * Our custom component type that stores an Integer (dimension index).
     *
     * - Codec: Handles saving/loading from NBT and JSON.
     * - PacketCodec: Handles network sync and serialization.
     */
    public static final ComponentType<Integer> DIMENSION_INDEX = new ComponentType.Builder<Integer>()
            .codec(Codec.INT) // Set up codec for serialization
            .packetCodec(new PacketCodec<RegistryByteBuf, Integer>() {
                @Override
                public Integer decode(RegistryByteBuf buf) {
                    return buf.readVarInt(); // Read the dimension index from the network buffer
                }
                @Override
                public void encode(RegistryByteBuf buf, Integer value) {
                    buf.writeVarInt(value); // Write the dimension index to the network buffer
                }
            })
            .build(); // Build the ComponentType
    // Prevent instantiation
    private PocketPortalDataTypes() {}
}
</file>

<file path="main/java/ninja/trek/pocketportals/dimension/GridBiomeSource.java">
package ninja.trek.pocketportals.dimension;
import com.mojang.serialization.Codec;
import com.mojang.serialization.MapCodec;
import com.mojang.serialization.codecs.RecordCodecBuilder;
import net.fabricmc.fabric.api.event.lifecycle.v1.ServerLifecycleEvents;
import net.minecraft.registry.Registry;
import net.minecraft.registry.RegistryKey;
import net.minecraft.registry.RegistryKeys;
import net.minecraft.registry.entry.RegistryEntry;
import net.minecraft.util.Identifier;
import net.minecraft.world.biome.Biome;
import net.minecraft.world.biome.source.BiomeSource;
import net.minecraft.world.biome.source.util.MultiNoiseUtil;
import ninja.trek.pocketportals.PocketPortals;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.stream.Stream;
public class GridBiomeSource extends BiomeSource {
    private record Parameters(long seed) {}
    private final Parameters parameters;
    public static final MapCodec<GridBiomeSource> CODEC = RecordCodecBuilder.mapCodec(instance ->
            instance.group(
                    Codec.LONG.fieldOf("seed").stable().forGetter(source -> source.parameters.seed())
            ).apply(instance, seed -> new GridBiomeSource(new Parameters(seed))));
    private List<RegistryKey<Biome>> biomeKeys;
    private Registry<Biome> biomeRegistry;
    public GridBiomeSource(Parameters parameters) {
        this.parameters = parameters;
        this.biomeKeys = new ArrayList<>();
        // Initialize the biome registry from the dynamic registry
        ServerLifecycleEvents.SERVER_STARTING.register(server -> {
            setBiomeRegistry(server.getRegistryManager().get(RegistryKeys.BIOME));
        });
    }
    public void setBiomeRegistry(Registry<Biome> registry) {
        this.biomeRegistry = registry;
        populateBiomeList();
    }
    private void populateBiomeList() {
        biomeKeys.clear();
        // Add all biomes from the registry that are valid overworld biomes
        biomeRegistry.getKeys().forEach(key -> {
            if (isValidOverworldBiome(key)) {
                biomeKeys.add(key);
            }
        });
        if (biomeKeys.isEmpty()) {
            PocketPortals.LOGGER.warn("No valid overworld biomes found, falling back to plains");
            biomeKeys.add(RegistryKey.of(RegistryKeys.BIOME, Identifier.of("minecraft", "plains")));
        } else {
            PocketPortals.LOGGER.info("Loaded {} overworld biomes for pocket dimensions", biomeKeys.size());
        }
    }
    private boolean isValidOverworldBiome(RegistryKey<Biome> key) {
        String path = key.getValue().getPath();
        return !path.contains("end") &&
                !path.contains("nether") &&
                !path.contains("basalt") &&
                !path.contains("void") &&
                !path.contains("small") &&
                !path.startsWith("debug_") &&
                !path.equals("custom");
    }
    @Override
    public MapCodec<? extends BiomeSource> getCodec() {
        return CODEC;
    }
    @Override
    public Stream<RegistryEntry<Biome>> biomeStream() {
        if (biomeRegistry == null) {
            return Stream.empty();
        }
        return biomeKeys.stream()
                .map(key -> biomeRegistry.getEntry(key))
                .filter(Optional::isPresent)
                .map(Optional::get);
    }
    @Override
    public RegistryEntry<Biome> getBiome(int x, int y, int z, MultiNoiseUtil.MultiNoiseSampler noise) {
        if (biomeRegistry == null || biomeKeys.isEmpty()) {
            return biomeRegistry.getEntry(RegistryKey.of(RegistryKeys.BIOME,
                    Identifier.of("minecraft", "plains"))).orElseThrow();
        }
        int gridX = Math.floorDiv(x, ModDimensions.GRID_SPACING);
        int gridZ = Math.floorDiv(z, ModDimensions.GRID_SPACING);
        // Use seed from parameters
        var random = new java.util.Random(parameters.seed() ^ ((long)gridX << 32 | (long)gridZ));
        RegistryKey<Biome> biomeKey = biomeKeys.get(random.nextInt(biomeKeys.size()));
        return biomeRegistry.getEntry(biomeKey).orElseThrow(() ->
                new RuntimeException("Could not find biome for key: " + biomeKey.getValue()));
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/dimension/GridSpawnRules.java">
package ninja.trek.pocketportals.dimension;
import net.minecraft.entity.EntityType;
import net.minecraft.nbt.NbtCompound;
import net.minecraft.nbt.NbtList;
import net.minecraft.registry.Registries;
import net.minecraft.util.Identifier;
import java.util.HashMap;
import java.util.Map;
public class GridSpawnRules {
    private final int gridIndex;
    private final Map<EntityType<?>, Boolean> spawnRules;
    public GridSpawnRules(int gridIndex) {
        this.gridIndex = gridIndex;
        this.spawnRules = new HashMap<>();
        // Default to allowing all standard hostile mobs
        setDefaultRules();
    }
    private void setDefaultRules() {
        // Allow common hostile mobs by default
        spawnRules.put(EntityType.ZOMBIE, true);
        spawnRules.put(EntityType.SKELETON, true);
        spawnRules.put(EntityType.SPIDER, true);
        spawnRules.put(EntityType.CREEPER, true);
        spawnRules.put(EntityType.ENDERMAN, true);
        spawnRules.put(EntityType.WITCH, true);
        spawnRules.put(EntityType.PHANTOM, true);
        spawnRules.put(EntityType.SLIME, true);
    }
    public boolean canSpawn(EntityType<?> entityType) {
        return spawnRules.getOrDefault(entityType, true);
    }
    public void setSpawnRule(EntityType<?> entityType, boolean allowed) {
        spawnRules.put(entityType, allowed);
    }
    public NbtCompound writeNbt() {
        NbtCompound nbt = new NbtCompound();
        nbt.putInt("GridIndex", gridIndex);
        NbtList rulesList = new NbtList();
        spawnRules.forEach((entityType, allowed) -> {
            NbtCompound ruleNbt = new NbtCompound();
            ruleNbt.putString("EntityType", Registries.ENTITY_TYPE.getId(entityType).toString());
            ruleNbt.putBoolean("Allowed", allowed);
            rulesList.add(ruleNbt);
        });
        nbt.put("SpawnRules", rulesList);
        return nbt;
    }
    public static GridSpawnRules fromNbt(NbtCompound nbt) {
        int gridIndex = nbt.getInt("GridIndex");
        GridSpawnRules rules = new GridSpawnRules(gridIndex);
        NbtList rulesList = nbt.getList("SpawnRules", 10); // 10 is the NBT type for compound tags
        rulesList.forEach(element -> {
            NbtCompound ruleNbt = (NbtCompound) element;
            EntityType<?> entityType = Registries.ENTITY_TYPE.get(
                    Identifier.tryParse(ruleNbt.getString("EntityType")));
            boolean allowed = ruleNbt.getBoolean("Allowed");
            rules.setSpawnRule(entityType, allowed);
        });
        return rules;
    }
    public int getGridIndex() {
        return gridIndex;
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/dimension/ModDimensions.java">
package ninja.trek.pocketportals.dimension;
import net.minecraft.registry.Registry;
import net.minecraft.registry.Registries;
import net.minecraft.util.Identifier;
import net.minecraft.world.biome.source.BiomeSource;
import ninja.trek.pocketportals.PocketPortals;
public class ModDimensions {
    public static final int GRID_SPACING = 100_000; // Blocks between each portal location
    public static final int GRID_SIZE = 600; // 600x600 grid
    public static void register() {
        // Register chunk generator
        Registry.register(
                Registries.CHUNK_GENERATOR,
                Identifier.of(PocketPortals.MOD_ID, "sky_island"),
                SkyIslandChunkGenerator.CODEC
        );
        // Register biome source
        Registry.register(
                Registries.BIOME_SOURCE,
                Identifier.of(PocketPortals.MOD_ID, "grid_biome_source"),
                GridBiomeSource.CODEC
        );
    }
    /**
     * Convert a dimension index (0-359999) to grid coordinates
     */
    public static GridPosition indexToGridPosition(int index) {
        if (index < 0 || index >= GRID_SIZE * GRID_SIZE) {
            throw new IllegalArgumentException("Index out of bounds: " + index);
        }
        int x = index % GRID_SIZE;
        int z = index / GRID_SIZE;
        return new GridPosition(x, z);
    }
    /**
     * Convert grid coordinates to world coordinates
     */
    public static WorldPosition gridToWorldPosition(GridPosition grid) {
        // Convert grid coordinates to world coordinates, centered in each cell
        // Add 50,000 block offset to keep away from world border
        int worldX = (grid.x() - (GRID_SIZE / 2)) * GRID_SPACING + 50_000;
        int worldZ = (grid.z() - (GRID_SIZE / 2)) * GRID_SPACING + 50_000;
        return new WorldPosition(worldX, 64, worldZ); // Y=64 is base height
    }
    public record GridPosition(int x, int z) {}
    public record WorldPosition(int x, int y, int z) {}
}
</file>

<file path="main/java/ninja/trek/pocketportals/dimension/PocketDimensionJsonProvider.java">
package ninja.trek.pocketportals.dimension;
import com.google.gson.JsonObject;
import net.fabricmc.fabric.api.datagen.v1.FabricDataOutput;
import net.minecraft.data.DataProvider;
import net.minecraft.data.DataWriter;
import net.minecraft.util.Identifier;
import ninja.trek.pocketportals.PocketPortals;
import java.util.concurrent.CompletableFuture;
public class PocketDimensionJsonProvider implements DataProvider {
    private final FabricDataOutput output;
    private static final long DIMENSION_SEED = 12345678L;
    public PocketDimensionJsonProvider(FabricDataOutput output) {
        this.output = output;
    }
    @Override
    public CompletableFuture<?> run(DataWriter writer) {
        return CompletableFuture.allOf(
                generateDimensionType(writer),
                generateDimension(writer)
        );
    }
    private CompletableFuture<?> generateDimensionType(DataWriter writer) {
        JsonObject typeJson = new JsonObject();
        typeJson.addProperty("ultrawarm", false);
        typeJson.addProperty("natural", true);
        typeJson.addProperty("coordinate_scale", 1.0);
        typeJson.addProperty("has_skylight", true);
        typeJson.addProperty("has_ceiling", false);
        typeJson.addProperty("ambient_light", 0.0);
        typeJson.addProperty("fixed_time", 6000L);
        typeJson.addProperty("piglin_safe", false);
        typeJson.addProperty("bed_works", true);
        typeJson.addProperty("respawn_anchor_works", false);
        typeJson.addProperty("has_raids", false);
        typeJson.addProperty("logical_height", 384);
        typeJson.addProperty("min_y", -64);
        typeJson.addProperty("height", 384);
        typeJson.addProperty("infiniburn", "#minecraft:infiniburn_overworld");
        typeJson.addProperty("effects", "minecraft:overworld");
        typeJson.addProperty("monster_spawn_light_level", 0);
        typeJson.addProperty("monster_spawn_block_light_limit", 0);
        return DataProvider.writeToPath(
                writer,
                typeJson,
                output.getPath()
                        .resolve("data")
                        .resolve(PocketPortals.MOD_ID)
                        .resolve("dimension_type")
                        .resolve("pocket_dimension_type.json")
        );
    }
    private CompletableFuture<?> generateDimension(DataWriter writer) {
        JsonObject dimensionJson = new JsonObject();
        dimensionJson.addProperty("type", PocketPortals.MOD_ID + ":pocket_dimension_type");
        JsonObject generator = new JsonObject();
        generator.addProperty("type", PocketPortals.MOD_ID + ":sky_island");
        generator.addProperty("seed", DIMENSION_SEED);
        // Add generator settings reference
        generator.addProperty("settings", "minecraft:overworld");
        JsonObject biomeSource = new JsonObject();
        biomeSource.addProperty("type", PocketPortals.MOD_ID + ":grid_biome_source");
        biomeSource.addProperty("seed", DIMENSION_SEED);
        generator.add("biome_source", biomeSource);
        dimensionJson.add("generator", generator);
        return DataProvider.writeToPath(
                writer,
                dimensionJson,
                output.getPath()
                        .resolve("data")
                        .resolve(PocketPortals.MOD_ID)
                        .resolve("dimension")
                        .resolve("pocket_dimension.json")
        );
    }
    @Override
    public String getName() {
        return "Pocket Dimension Configurations";
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/dimension/PocketDimensionsRegistry.java">
package ninja.trek.pocketportals.dimension;
import net.fabricmc.fabric.api.event.lifecycle.v1.ServerLifecycleEvents;
import net.minecraft.entity.EntityType;
import net.minecraft.nbt.NbtCompound;
import net.minecraft.nbt.NbtList;
import net.minecraft.registry.RegistryKey;
import net.minecraft.registry.RegistryKeys;
import net.minecraft.registry.RegistryWrapper;
import net.minecraft.server.MinecraftServer;
import net.minecraft.util.Identifier;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.PersistentState;
import net.minecraft.world.World;
import ninja.trek.pocketportals.PocketPortals;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;
import java.util.List;
import java.util.Arrays;
public class PocketDimensionsRegistry extends PersistentState {
    private static final String NEXT_INDEX_KEY = "NextPortalIndex";
    private static final String SPAWN_RULES_KEY = "SpawnRules";
    private static int nextAvailableIndex = 0;
    private final Map<Integer, GridSpawnRules> spawnRules = new HashMap<>();
    // List of common hostile mobs that we'll manage spawn rules for
    public static final List<EntityType<?>> MANAGED_MOBS = Arrays.asList(
            EntityType.ZOMBIE,
            EntityType.SKELETON,
            EntityType.SPIDER,
            EntityType.CREEPER,
            EntityType.ENDERMAN,
            EntityType.WITCH,
            EntityType.PHANTOM,
            EntityType.SLIME
    );
    public static GridSpawnRules getSpawnRules(MinecraftServer server, int index) {
        PocketDimensionsRegistry state = getState(server);
        if (state == null) return null;
        // Get or create rules for this index
        GridSpawnRules rules = state.spawnRules.get(index);
        if (rules == null) {
            rules = new GridSpawnRules(index);
            setRandomSpawnRules(rules);
            state.spawnRules.put(index, rules);
            state.markDirty();
        }
        return rules;
    }
    private static final Type<PocketDimensionsRegistry> TYPE = new Type<>(
            PocketDimensionsRegistry::new,
            (nbt, lookup) -> createFromNbt(nbt, lookup),
            null
    );
    private static final RegistryKey<World> DIMENSION_KEY = RegistryKey.of(
            RegistryKeys.WORLD,
            Identifier.of(PocketPortals.MOD_ID, "pocket_dimension")
    );
    public PocketDimensionsRegistry() {
        super();
    }
    @Override
    public NbtCompound writeNbt(NbtCompound nbt, RegistryWrapper.WrapperLookup registryLookup) {
        nbt.putInt(NEXT_INDEX_KEY, nextAvailableIndex);
        NbtList rulesNbt = new NbtList();
        spawnRules.values().forEach(rules -> {
            rulesNbt.add(rules.writeNbt());
        });
        nbt.put(SPAWN_RULES_KEY, rulesNbt);
        return nbt;
    }
    public static PocketDimensionsRegistry createFromNbt(NbtCompound nbt, RegistryWrapper.WrapperLookup lookup) {
        PocketDimensionsRegistry state = new PocketDimensionsRegistry();
        nextAvailableIndex = nbt.getInt(NEXT_INDEX_KEY);
        if (nbt.contains(SPAWN_RULES_KEY)) {
            NbtList rulesNbt = nbt.getList(SPAWN_RULES_KEY, 10);
            rulesNbt.forEach(element -> {
                GridSpawnRules rules = GridSpawnRules.fromNbt((NbtCompound) element);
                state.spawnRules.put(rules.getGridIndex(), rules);
            });
        }
        return state;
    }
    private static PocketDimensionsRegistry getState(MinecraftServer server) {
        if (server.getOverworld() == null) {
            PocketPortals.LOGGER.warn("Tried to access persistent state before overworld was loaded!");
            return null;
        }
        return server.getOverworld().getPersistentStateManager()
                .getOrCreate(TYPE, PocketPortals.MOD_ID + "_registry");
    }
    private static void setRandomSpawnRules(GridSpawnRules rules) {
        Random random = new Random();
        int randomType = random.nextInt(4); // 0-3
        if (randomType == 0) {
            // 25% chance: Fully peaceful
            PocketPortals.LOGGER.info("Creating peaceful dimension space");
            MANAGED_MOBS.forEach(mob -> rules.setSpawnRule(mob, false));
        }
        else if (randomType == 1) {
            // 25% chance: Fully hostile
            PocketPortals.LOGGER.info("Creating hostile dimension space");
            MANAGED_MOBS.forEach(mob -> rules.setSpawnRule(mob, true));
        }
        else {
            // 50% chance: Random for each mob
            PocketPortals.LOGGER.info("Creating mixed dimension space");
            MANAGED_MOBS.forEach(mob -> {
                boolean allowed = random.nextBoolean();
                rules.setSpawnRule(mob, allowed);
                PocketPortals.LOGGER.debug("Set spawn rule for {}: {}", mob, allowed);
            });
        }
    }
    public static synchronized int findUnusedSlot(MinecraftServer server) {
        PocketDimensionsRegistry state = getState(server);
        if (state == null) {
            int index = nextAvailableIndex;
            nextAvailableIndex = (nextAvailableIndex + 1) % (ModDimensions.GRID_SIZE * ModDimensions.GRID_SIZE);
            return index;
        }
        int nextIndex = nextAvailableIndex;
        nextAvailableIndex = (nextAvailableIndex + 1) % (ModDimensions.GRID_SIZE * ModDimensions.GRID_SIZE);
        // Create new GridSpawnRules with random configuration
        GridSpawnRules rules = new GridSpawnRules(nextIndex);
        setRandomSpawnRules(rules);
        state.spawnRules.put(nextIndex, rules);
        state.markDirty();
        return nextIndex;
    }
    public static void init() {
        ServerLifecycleEvents.SERVER_STARTED.register(server -> {
            getState(server);
        });
    }
    public static RegistryKey<World> getDimensionKey() {
        return DIMENSION_KEY;
    }
    public static boolean canMobSpawn(MinecraftServer server, BlockPos pos, EntityType<?> entityType) {
        PocketDimensionsRegistry state = getState(server);
        if (state == null) return true;
        int gridX = Math.floorDiv(pos.getX(), ModDimensions.GRID_SPACING);
        int gridZ = Math.floorDiv(pos.getZ(), ModDimensions.GRID_SPACING);
        int index = gridX + (gridZ * ModDimensions.GRID_SIZE);
        GridSpawnRules rules = state.spawnRules.get(index);
        if (rules == null) {
            rules = new GridSpawnRules(index);
            setRandomSpawnRules(rules);
            state.spawnRules.put(index, rules);
            state.markDirty();
        }
        return rules.canSpawn(entityType);
    }
    public static void setMobSpawnRule(MinecraftServer server, int gridIndex,
                                       EntityType<?> entityType, boolean allowed) {
        PocketDimensionsRegistry state = getState(server);
        if (state == null) return;
        GridSpawnRules rules = state.spawnRules.computeIfAbsent(gridIndex,
                GridSpawnRules::new);
        rules.setSpawnRule(entityType, allowed);
        state.markDirty();
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/dimension/SkyIslandChunkGenerator.java">
package ninja.trek.pocketportals.dimension;
import com.mojang.serialization.Codec;
import com.mojang.serialization.MapCodec;
import com.mojang.serialization.codecs.RecordCodecBuilder;
import net.minecraft.block.BlockState;
import net.minecraft.block.Blocks;
import net.minecraft.registry.entry.RegistryEntry;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.ChunkRegion;
import net.minecraft.world.HeightLimitView;
import net.minecraft.world.Heightmap;
import net.minecraft.world.biome.Biome;
import net.minecraft.world.biome.source.BiomeAccess;
import net.minecraft.world.biome.source.BiomeSource;
import net.minecraft.world.chunk.Chunk;
import net.minecraft.world.gen.GenerationStep;
import net.minecraft.world.gen.StructureAccessor;
import net.minecraft.world.gen.chunk.Blender;
import net.minecraft.world.gen.chunk.ChunkGenerator;
import net.minecraft.world.gen.chunk.ChunkGeneratorSettings;
import net.minecraft.world.gen.chunk.NoiseChunkGenerator;
import net.minecraft.world.gen.chunk.VerticalBlockSample;
import net.minecraft.world.gen.noise.NoiseConfig;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executor;
public class SkyIslandChunkGenerator extends ChunkGenerator {
    public static final MapCodec<SkyIslandChunkGenerator> CODEC = RecordCodecBuilder.mapCodec(instance ->
            instance.group(
                    BiomeSource.CODEC.fieldOf("biome_source").forGetter(ChunkGenerator::getBiomeSource),
                    ChunkGeneratorSettings.REGISTRY_CODEC.fieldOf("settings").forGetter(generator -> generator.settings)
            ).apply(instance, SkyIslandChunkGenerator::new));
    private static final int BASE_HEIGHT = 64;
    private static final int ISLAND_RADIUS = 50;
    private static final double NOISE_SCALE = 0.05;
    private final RegistryEntry<ChunkGeneratorSettings> settings;
    private final NoiseChunkGenerator vanillaGenerator;
    public SkyIslandChunkGenerator(BiomeSource biomeSource, RegistryEntry<ChunkGeneratorSettings> settings) {
        super(biomeSource);
        this.settings = settings;
        this.vanillaGenerator = new NoiseChunkGenerator(biomeSource, settings);
    }
    @Override
    protected MapCodec<? extends ChunkGenerator> getCodec() {
        return CODEC;
    }
    private boolean isInIslandRange(int worldX, int worldZ) {
        // Convert to grid coordinates
        int gridX = Math.floorDiv(worldX, ModDimensions.GRID_SPACING);
        int gridZ = Math.floorDiv(worldZ, ModDimensions.GRID_SPACING);
        // Get center of current grid cell
        int centerX = (gridX * ModDimensions.GRID_SPACING) + (ModDimensions.GRID_SPACING / 2);
        int centerZ = (gridZ * ModDimensions.GRID_SPACING) + (ModDimensions.GRID_SPACING / 2);
        // Calculate distance from center
        double dx = worldX - centerX;
        double dz = worldZ - centerZ;
        double distanceSquared = dx * dx + dz * dz;
        return distanceSquared <= ISLAND_RADIUS * ISLAND_RADIUS;
    }
    private double getIslandNoise(int x, int z) {
        // Convert to grid coordinates
        int gridX = Math.floorDiv(x, ModDimensions.GRID_SPACING);
        int gridZ = Math.floorDiv(z, ModDimensions.GRID_SPACING);
        // Get center of current grid cell
        int centerX = (gridX * ModDimensions.GRID_SPACING) + (ModDimensions.GRID_SPACING / 2);
        int centerZ = (gridZ * ModDimensions.GRID_SPACING) + (ModDimensions.GRID_SPACING / 2);
        // Calculate normalized distance from center (0.0 to 1.0)
        double dx = x - centerX;
        double dz = z - centerZ;
        double distance = Math.sqrt(dx * dx + dz * dz);
        double normalizedDist = Math.min(1.0, distance / ISLAND_RADIUS);
        // Create smooth falloff from center
        double falloff = 1.0 - (normalizedDist * normalizedDist); // Quadratic falloff
        // Add some variation using sine waves
        double variation = Math.sin(x * NOISE_SCALE) * Math.cos(z * NOISE_SCALE) * 0.2;
        return Math.max(0.0, falloff + variation);
    }
    @Override
    public CompletableFuture<Chunk> populateNoise(Blender blender, NoiseConfig noiseConfig, StructureAccessor structureAccessor, Chunk chunk) {
        // First, let vanilla handle base generation
        return vanillaGenerator.populateNoise(blender, noiseConfig, structureAccessor, chunk).thenApply(populatedChunk -> {
            // Then modify it to create our island shape
            int chunkX = chunk.getPos().x * 16;
            int chunkZ = chunk.getPos().z * 16;
            BlockPos.Mutable mutable = new BlockPos.Mutable();
            for (int x = 0; x < 16; x++) {
                for (int z = 0; z < 16; z++) {
                    int worldX = chunkX + x;
                    int worldZ = chunkZ + z;
                    if (!isInIslandRange(worldX, worldZ)) {
                        // Outside island range - clear all blocks
                        for (int y = chunk.getBottomY(); y < chunk.getTopY(); y++) {
                            mutable.set(x, y, z);
                            chunk.setBlockState(mutable, Blocks.AIR.getDefaultState(), false);
                        }
                    } else {
                        // Inside island range - apply noise modification
                        double islandFactor = getIslandNoise(worldX, worldZ);
                        int currentHeight = chunk.getHeightmap(Heightmap.Type.WORLD_SURFACE).get(x, z);
                        int targetHeight = (int)(BASE_HEIGHT + (islandFactor * 30)); // 30 blocks of max variation
                        // Adjust terrain height
                        if (currentHeight > targetHeight) {
                            // Remove blocks above target height
                            for (int y = targetHeight + 1; y <= currentHeight; y++) {
                                mutable.set(x, y, z);
                                chunk.setBlockState(mutable, Blocks.AIR.getDefaultState(), false);
                            }
                        }
                    }
                }
            }
            return populatedChunk;
        });
    }
    @Override
    public void carve(ChunkRegion chunkRegion, long seed, NoiseConfig noiseConfig, BiomeAccess biomeAccess,
                      StructureAccessor structureAccessor, Chunk chunk, GenerationStep.Carver generationStep) {
        // Delegate to vanilla for carving
        vanillaGenerator.carve(chunkRegion, seed, noiseConfig, biomeAccess, structureAccessor, chunk, generationStep);
    }
    @Override
    public void buildSurface(ChunkRegion region, StructureAccessor structures, NoiseConfig noiseConfig, Chunk chunk) {
        // Delegate to vanilla for surface building
        vanillaGenerator.buildSurface(region, structures, noiseConfig, chunk);
    }
    @Override
    public void populateEntities(ChunkRegion region) {
    }
    @Override
    public int getHeight(int x, int z, Heightmap.Type heightmap, HeightLimitView world, NoiseConfig noiseConfig) {
        if (!isInIslandRange(x, z)) {
            return world.getBottomY();
        }
        return vanillaGenerator.getHeight(x, z, heightmap, world, noiseConfig);
    }
    @Override
    public VerticalBlockSample getColumnSample(int x, int z, HeightLimitView world, NoiseConfig noiseConfig) {
        return vanillaGenerator.getColumnSample(x, z, world, noiseConfig);
    }
    @Override
    public void getDebugHudText(List<String> text, NoiseConfig noiseConfig, BlockPos pos) {
        text.add("Sky Island Generator - Grid Position: " +
                Math.floorDiv(pos.getX(), ModDimensions.GRID_SPACING) + ", " +
                Math.floorDiv(pos.getZ(), ModDimensions.GRID_SPACING));
        vanillaGenerator.getDebugHudText(text, noiseConfig, pos);
    }
    @Override
    public int getWorldHeight() {
        return vanillaGenerator.getWorldHeight();
    }
    @Override
    public int getSeaLevel() {
        return -64; // No sea in sky islands
    }
    @Override
    public int getMinimumY() {
        return vanillaGenerator.getMinimumY();
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/item/ModItems.java">
package ninja.trek.pocketportals.item;
import net.minecraft.item.Item;
import net.minecraft.registry.Registries;
import net.minecraft.registry.Registry;
import net.minecraft.util.Identifier;
import ninja.trek.pocketportals.PocketPortals;
public class ModItems {
    // Register a custom PocketPortalItem so we can store dimension index in its NBT
    public static final PocketPortalItem POCKET_PORTAL = new PocketPortalItem(
            new Item.Settings().maxCount(1) // non-stackable
    );
    public static void registerItems() {
        Registry.register(
                Registries.ITEM,
                Identifier.of(PocketPortals.MOD_ID, "pocket_portal"),
                POCKET_PORTAL
        );
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/item/PocketPortalItem.java">
package ninja.trek.pocketportals.item;
import net.minecraft.item.BlockItem;
import net.minecraft.item.ItemStack;
import net.minecraft.item.tooltip.TooltipType;
import net.minecraft.text.Text;
import net.minecraft.util.Formatting;
import net.minecraft.world.World;
import ninja.trek.pocketportals.block.ModBlocks;
import org.jetbrains.annotations.Nullable;
import java.util.List;
import static ninja.trek.pocketportals.data.PocketPortalDataTypes.DIMENSION_INDEX;
/**
 * Custom PocketPortalItem that reads the dimension index from
 * Fabric Data Components for its tooltip (instead of raw NBT).
 */
public class PocketPortalItem extends BlockItem {
    public PocketPortalItem(Settings settings) {
        super(ModBlocks.POCKET_PORTAL, settings);
    }
    @Override
    public void appendTooltip(
            ItemStack stack,
            TooltipContext context,
            List<Text> tooltip,
            TooltipType type
    ) {
        // 1) Let the parent BlockItem do any default work
        super.appendTooltip(stack, context, tooltip, type);
        // 2) Fetch our dimension index from Fabric Data Components
        Integer index = stack.get(DIMENSION_INDEX); // If none set, returns null
        // 3) Show a line of text based on that index
        if (index != null) {
            tooltip.add(Text.literal("Bound to dimension index: " + index)
                    .formatted(Formatting.GRAY));
        } else {
            tooltip.add(Text.literal("Unlinked").formatted(Formatting.DARK_GRAY));
        }
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/mixin/ExampleMixin.java">
package ninja.trek.pocketportals.mixin;
import net.minecraft.server.MinecraftServer;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(MinecraftServer.class)
public class ExampleMixin {
	@Inject(at = @At("HEAD"), method = "loadWorld")
	private void init(CallbackInfo info) {
		// This code is injected into the start of MinecraftServer.loadWorld()V
	}
}
</file>

<file path="main/java/ninja/trek/pocketportals/mixin/SpawnHelperMixin.java">
package ninja.trek.pocketportals.mixin;
import net.minecraft.entity.EntityType;
import net.minecraft.entity.SpawnGroup;
import net.minecraft.server.world.ServerWorld;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.SpawnHelper;
import net.minecraft.world.biome.SpawnSettings;
import net.minecraft.world.gen.StructureAccessor;
import net.minecraft.world.gen.chunk.ChunkGenerator;
import ninja.trek.pocketportals.dimension.PocketDimensionsRegistry;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;
@Mixin(SpawnHelper.class)
public class SpawnHelperMixin {
    @Inject(
            method = "canSpawn(Lnet/minecraft/server/world/ServerWorld;Lnet/minecraft/entity/SpawnGroup;Lnet/minecraft/world/gen/StructureAccessor;Lnet/minecraft/world/gen/chunk/ChunkGenerator;Lnet/minecraft/world/biome/SpawnSettings$SpawnEntry;Lnet/minecraft/util/math/BlockPos$Mutable;D)Z",
            at = @At("RETURN"),
            cancellable = true
    )
    private static void onCanSpawn(
            ServerWorld world,
            SpawnGroup group,
            StructureAccessor structureAccessor,
            ChunkGenerator chunkGenerator,
            SpawnSettings.SpawnEntry spawnEntry,
            BlockPos.Mutable pos,
            double squaredDistance,
            CallbackInfoReturnable<Boolean> cir
    ) {
        // Only proceed if vanilla spawn checks passed
        if (!cir.getReturnValue()) {
            return;
        }
        // Only apply our rules in the pocket dimension
        if (!world.getRegistryKey().equals(PocketDimensionsRegistry.getDimensionKey())) {
            return;
        }
        // Get the entity type from the spawn entry
        EntityType<?> entityType = spawnEntry.type;
        // Check if spawning is allowed in this grid space
        if (!PocketDimensionsRegistry.canMobSpawn(world.getServer(), pos, entityType)) {
            cir.setReturnValue(false);
        }
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/network/SpawnRulesPacket.java">
package ninja.trek.pocketportals.network;
import net.minecraft.entity.EntityType;
import net.minecraft.network.PacketByteBuf;
import net.minecraft.network.packet.CustomPayload;
import net.minecraft.registry.Registries;
import net.minecraft.util.Identifier;
import ninja.trek.pocketportals.PocketPortals;
import java.util.HashMap;
import java.util.Map;
public record SpawnRulesPacket(int dimensionIndex, Map<EntityType<?>, Boolean> rules)
        implements CustomPayload {
    // Define the packet's unique ID using our custom type.
    public static final CustomPayload.Id<SpawnRulesPacket> ID =
            new CustomPayload.Id<>(Identifier.of(PocketPortals.MOD_ID, "spawn_rules_sync"));
    /**
     * Constructor that decodes a SpawnRulesPacket from a PacketByteBuf.
     * Fabric will use this constructor to create an instance from raw data.
     */
    public SpawnRulesPacket(PacketByteBuf buf) {
        this(buf.readVarInt(), readRules(buf));
    }
    /**
     * Helper method to read the rules map from the buffer.
     */
    private static Map<EntityType<?>, Boolean> readRules(PacketByteBuf buf) {
        int size = buf.readVarInt();
        Map<EntityType<?>, Boolean> rules = new HashMap<>();
        for (int i = 0; i < size; i++) {
            EntityType<?> type = Registries.ENTITY_TYPE.get(buf.readIdentifier());
            boolean allowed = buf.readBoolean();
            if (type != null) {
                rules.put(type, allowed);
            }
        }
        return rules;
    }
    /**
     * Write the packet data to the buffer.
     */
    public void write(PacketByteBuf buf) {
        buf.writeVarInt(dimensionIndex);
        buf.writeVarInt(rules.size());
        rules.forEach((type, allowed) -> {
            buf.writeIdentifier(Registries.ENTITY_TYPE.getId(type));
            buf.writeBoolean(allowed);
        });
    }
    @Override
    public Id<? extends CustomPayload> getId() {
        return ID;
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/PocketPortals.java">
package ninja.trek.pocketportals;
import net.fabricmc.api.ModInitializer;
import net.fabricmc.fabric.api.event.lifecycle.v1.ServerLifecycleEvents;
import ninja.trek.pocketportals.block.ModBlocks;
import ninja.trek.pocketportals.data.DataLoader;
import ninja.trek.pocketportals.dimension.ModDimensions;
import ninja.trek.pocketportals.dimension.PocketDimensionsRegistry;
import ninja.trek.pocketportals.item.ModItems;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class PocketPortals implements ModInitializer {
	public static final String MOD_ID = "pocket-portals";
	public static final Logger LOGGER = LoggerFactory.getLogger(MOD_ID);
	@Override
	public void onInitialize() {
		// Register data loader first
		DataLoader.register();
		// Register dimension system first
		ModDimensions.register();
		PocketDimensionsRegistry.init();
		// Then register blocks and items that might depend on dimensions
		ModBlocks.registerBlocks();
		ModItems.registerItems();
		LOGGER.info("EndNew mod initialized!");
	}
}
</file>

<file path="main/java/ninja/trek/pocketportals/PocketPortalsDataGenerator.java">
package ninja.trek.pocketportals;
import net.fabricmc.fabric.api.datagen.v1.DataGeneratorEntrypoint;
import net.fabricmc.fabric.api.datagen.v1.FabricDataGenerator;
import net.fabricmc.fabric.api.datagen.v1.provider.*;
import net.minecraft.data.client.*;
import net.minecraft.data.server.recipe.RecipeExporter;
import net.minecraft.registry.RegistryWrapper;
import net.minecraft.util.Identifier;
import ninja.trek.pocketportals.block.ModBlocks;
import ninja.trek.pocketportals.dimension.PocketDimensionJsonProvider;
import ninja.trek.pocketportals.item.ModItems;
import net.minecraft.item.Items;
import net.minecraft.recipe.book.RecipeCategory;
import net.minecraft.data.server.recipe.ShapedRecipeJsonBuilder;
public class PocketPortalsDataGenerator implements DataGeneratorEntrypoint {
    @Override
    public void onInitializeDataGenerator(FabricDataGenerator fabricDataGenerator) {
        FabricDataGenerator.Pack pack = fabricDataGenerator.createPack();
        // Models and Blockstates
        pack.addProvider((output, registriesLookup) -> new FabricModelProvider(output) {
            @Override
            public void generateBlockStateModels(BlockStateModelGenerator blockStateModelGenerator) {
                // Create unique textures for each portal type
                Identifier portalTexture = Identifier.of(PocketPortals.MOD_ID, "block/pocket_portal");
                Identifier returnPortalTexture = Identifier.of(PocketPortals.MOD_ID, "block/return_portal");
                Identifier frameTexture = Identifier.of(PocketPortals.MOD_ID, "block/portal_frame");
                // Register block models using correct methods for 1.21
                blockStateModelGenerator.registerSimpleCubeAll(ModBlocks.POCKET_PORTAL);
                blockStateModelGenerator.registerSimpleCubeAll(ModBlocks.RETURN_POCKET_PORTAL);
                blockStateModelGenerator.registerSimpleState(ModBlocks.POCKET_PORTAL_FRAME);
            }
            @Override
            public void generateItemModels(ItemModelGenerator itemModelGenerator) {
                // Generate item model for the portal item
                itemModelGenerator.register(ModItems.POCKET_PORTAL, Models.GENERATED);
            }
        });
        // Recipes
        pack.addProvider((output, registriesLookup) -> new FabricRecipeProvider(output, registriesLookup) {
            @Override
            public void generate(RecipeExporter exporter) {
                ShapedRecipeJsonBuilder.create(RecipeCategory.MISC, ModItems.POCKET_PORTAL)
                        .pattern("OEO")
                        .pattern("EDE")
                        .pattern("OEO")
                        .input('O', Items.OBSIDIAN)
                        .input('E', Items.ENDER_PEARL)
                        .input('D', Items.DIAMOND)
                        .criterion(FabricRecipeProvider.hasItem(Items.ENDER_PEARL),
                                FabricRecipeProvider.conditionsFromItem(Items.ENDER_PEARL))
                        .offerTo(exporter, Identifier.of(PocketPortals.MOD_ID, "pocket_portal"));
            }
        });
        // Loot Tables
        pack.addProvider((output, registriesLookup) -> new FabricBlockLootTableProvider(output, registriesLookup) {
            @Override
            public void generate() {
                // Use proper loot table generation methods for blocks
                this.addDrop(ModBlocks.POCKET_PORTAL, this.drops(ModBlocks.POCKET_PORTAL));
                this.addDrop(ModBlocks.RETURN_POCKET_PORTAL, this.drops(ModBlocks.RETURN_POCKET_PORTAL));
                this.addDrop(ModBlocks.POCKET_PORTAL_FRAME, this.drops(ModBlocks.POCKET_PORTAL_FRAME));
            }
        });
        // Language Provider
        pack.addProvider((output, registriesLookup) -> new FabricLanguageProvider(output, registriesLookup) {
            @Override
            public void generateTranslations(RegistryWrapper.WrapperLookup registryLookup, TranslationBuilder translationBuilder) {
                // Register translations using proper method
                translationBuilder.add(ModBlocks.POCKET_PORTAL, "Pocket Portal");
                translationBuilder.add(ModBlocks.RETURN_POCKET_PORTAL, "Return Portal");
                translationBuilder.add(ModBlocks.POCKET_PORTAL_FRAME, "Portal Frame");
                translationBuilder.add("itemGroup." + PocketPortals.MOD_ID + ".main", "Pocket Portals");
            }
        });
        // Dimension configurations
        pack.addProvider(PocketDimensionJsonProvider::new);
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/SpawnRulesData.java">
package ninja.trek.pocketportals;
import net.minecraft.entity.EntityType;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
public class SpawnRulesData {
    // Use ConcurrentHashMap for thread safety when accessing from different threads
    private static final Map<Integer, Map<EntityType<?>, Boolean>> dimensionSpawnRules =
            new ConcurrentHashMap<>();
    public static void setSpawnRules(int dimensionIndex, Map<EntityType<?>, Boolean> rules) {
        dimensionSpawnRules.put(dimensionIndex, new HashMap<>(rules));
    }
    public static Map<EntityType<?>, Boolean> getSpawnRules(int dimensionIndex) {
        return dimensionSpawnRules.getOrDefault(dimensionIndex, new HashMap<>());
    }
    public static void clearAllRules() {
        dimensionSpawnRules.clear();
    }
    // Private constructor to prevent instantiation
    private SpawnRulesData() {}
}
</file>

<file path="main/resources/assets/pocket-portals/models/block/pocket_portal_frame.json">
{
  "parent": "block/cube",
  "textures": {
    "particle": "block/nether_portal",
    "portal": "block/nether_portal"
  },
  "elements": [
    {
      "from": [0, 0, 0],
      "to": [16, 16, 16],
      "faces": {
        "north": {"uv": [0, 0, 16, 16], "texture": "portal"},
        "east": {"uv": [0, 0, 16, 16], "texture": "portal"},
        "south": {"uv": [0, 0, 16, 16], "texture": "portal"},
        "west": {"uv": [0, 0, 16, 16], "texture": "portal"},
        "up": {"uv": [0, 0, 16, 16], "texture": "portal"},
        "down": {"uv": [0, 0, 16, 16], "texture": "portal"}
      }
    }
  ]
}
</file>

<file path="main/resources/fabric.mod.json">
{
	"schemaVersion": 1,
	"id": "pocket-portals",
	"version": "${version}",
	"name": "Pocket Portals",
	"description": "This is an example description! Tell everyone what your mod is about!",
	"authors": [
		"Me!"
	],
	"contact": {
		"homepage": "https://fabricmc.net/",
		"sources": "https://github.com/FabricMC/fabric-example-mod"
	},
	"license": "CC0-1.0",
	"icon": "assets/pocket-portals/icon.png",
	"environment": "*",
	"entrypoints": {
		"main": [
			"ninja.trek.pocketportals.PocketPortals"
		],
		"client": [
			"ninja.trek.pocketportals.PocketPortalsClient"
		],
		"fabric-datagen": [
			"ninja.trek.pocketportals.PocketPortalsDataGenerator"
		]
	},
	"mixins": [
		"pocket-portals.mixins.json",
		{
			"config": "pocket-portals.client.mixins.json",
			"environment": "client"
		}
	],
	"depends": {
		"fabricloader": ">=0.16.10",
		"minecraft": "~1.21",
		"java": ">=21",
		"fabric-api": "*"
	},
	"suggests": {
		"another-mod": "*"
	}
}
</file>

<file path="main/resources/pocket-portals.mixins.json">
{
	"required": true,
	"package": "ninja.trek.pocketportals.mixin",
	"compatibilityLevel": "JAVA_21",
	"mixins": [
		"ExampleMixin",
		"SpawnHelperMixin"
	],
	"injectors": {
		"defaultRequire": 1
	}
}
</file>

<file path="repomixx.bat">
repomix --style xml --remove-empty-lines --copy --ignore "**/generated/**"
</file>

</files>
