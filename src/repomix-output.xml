This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-16T11:48:16.793Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
client/java/ninja/trek/pocketportals/mixin/client/ClientWorldMixin.java
client/java/ninja/trek/pocketportals/mixin/client/ExampleClientMixin.java
client/java/ninja/trek/pocketportals/PocketPortalsClient.java
client/java/ninja/trek/pocketportals/PocketPortalsDataGenerator.java
client/resources/pocket-portals.client.mixins.json
client/resources/pocketportals.client.mixins.json
main/java/ninja/trek/pocketportals/block/ModBlocks.java
main/java/ninja/trek/pocketportals/block/PocketPortalBlock.java
main/java/ninja/trek/pocketportals/block/PocketPortalBlockEntity.java
main/java/ninja/trek/pocketportals/block/PocketPortalFrame.java
main/java/ninja/trek/pocketportals/block/ReturnPocketPortalBlock.java
main/java/ninja/trek/pocketportals/block/ReturnPocketPortalBlockEntity.java
main/java/ninja/trek/pocketportals/data/DataLoader.java
main/java/ninja/trek/pocketportals/data/PocketPortalDataTypes.java
main/java/ninja/trek/pocketportals/dimension/GridBiomeSource.java
main/java/ninja/trek/pocketportals/dimension/GridSpawnRules.java
main/java/ninja/trek/pocketportals/dimension/ModDimensions.java
main/java/ninja/trek/pocketportals/dimension/PocketDimensionJsonProvider.java
main/java/ninja/trek/pocketportals/dimension/PocketDimensionsRegistry.java
main/java/ninja/trek/pocketportals/dimension/SkyIslandChunkGenerator.java
main/java/ninja/trek/pocketportals/item/ModItems.java
main/java/ninja/trek/pocketportals/item/PocketPortalItem.java
main/java/ninja/trek/pocketportals/mixin/ExampleMixin.java
main/java/ninja/trek/pocketportals/mixin/SpawnHelperMixin.java
main/java/ninja/trek/pocketportals/network/SpawnRulesPacket.java
main/java/ninja/trek/pocketportals/PocketPortals.java
main/java/ninja/trek/pocketportals/SpawnRulesData.java
main/resources/fabric.mod.json
main/resources/pocket-portals.mixins.json
main/resources/pocketportals.mixins.json
repomixx.bat
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="client/java/ninja/trek/pocketportals/mixin/client/ClientWorldMixin.java">
package ninja.trek.pocketportals.mixin.client;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.world.ClientWorld;
import net.minecraft.entity.EntityType;
import net.minecraft.text.Text;
import net.minecraft.util.hit.BlockHitResult;
import net.minecraft.util.hit.HitResult;
import ninja.trek.pocketportals.SpawnRulesData;
import ninja.trek.pocketportals.block.ModBlocks;
import ninja.trek.pocketportals.block.PocketPortalBlockEntity;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
import java.util.Map;
import java.util.stream.Collectors;
@Mixin(ClientWorld.class)
public class ClientWorldMixin {
    @Inject(method = "tick", at = @At("HEAD"))
    private void onTick(CallbackInfo ci) {
        MinecraftClient client = MinecraftClient.getInstance();
        if (client.player == null) return;
        HitResult hit = client.crosshairTarget;
        if (hit == null || hit.getType() != HitResult.Type.BLOCK) return;
        BlockHitResult blockHit = (BlockHitResult) hit;
        ClientWorld world = (ClientWorld) (Object) this;
        if (world.getBlockState(blockHit.getBlockPos()).isOf(ModBlocks.POCKET_PORTAL_FRAME)) {
            // Look for portal base block
            for (int y = 0; y > -3; y--) {
                var basePos = blockHit.getBlockPos().add(0, y, 0);
                if (world.getBlockState(basePos).isOf(ModBlocks.POCKET_PORTAL)) {
                    var blockEntity = world.getBlockEntity(basePos);
                    if (blockEntity instanceof PocketPortalBlockEntity portalBE) {
                        Integer dimensionIndex = portalBE.getDimensionIndex();
                        if (dimensionIndex != null) {
                            Map<EntityType<?>, Boolean> rules = SpawnRulesData.getSpawnRules(dimensionIndex);
                            if (!rules.isEmpty()) {
                                // Count disabled spawns
                                long disabledCount = rules.values().stream().filter(allowed -> !allowed).count();
                                String overlay;
                                if (disabledCount == rules.size()) {
                                    overlay = "ยง7All mob spawns disabled";
                                } else if (disabledCount > 0) {
                                    overlay = "ยง7Disabled spawns: " +
                                            rules.entrySet().stream()
                                                    .filter(e -> !e.getValue())
                                                    .map(e -> e.getKey().getName().getString())
                                                    .collect(Collectors.joining(", "));
                                } else {
                                    overlay = "ยง7All mob spawns enabled";
                                }
                                client.player.sendMessage(Text.literal(overlay), true);
                            }
                        }
                        break;
                    }
                }
            }
        }
    }
}
</file>

<file path="client/java/ninja/trek/pocketportals/mixin/client/ExampleClientMixin.java">
package ninja.trek.pocketportals.mixin.client;
import net.minecraft.client.MinecraftClient;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(MinecraftClient.class)
public class ExampleClientMixin {
	@Inject(at = @At("HEAD"), method = "run")
	private void init(CallbackInfo info) {
		// This code is injected into the start of MinecraftClient.run()V
	}
}
</file>

<file path="client/java/ninja/trek/pocketportals/PocketPortalsClient.java">
package ninja.trek.pocketportals;
import net.fabricmc.api.ClientModInitializer;
import net.fabricmc.fabric.api.client.networking.v1.ClientPlayNetworking;
import net.fabricmc.fabric.api.networking.v1.PayloadTypeRegistry;
import net.minecraft.client.MinecraftClient;
import net.minecraft.network.RegistryByteBuf;
import ninja.trek.pocketportals.network.SpawnRulesPacket;
public class PocketPortalsClient implements ClientModInitializer {
	@Override
	public void onInitializeClient() {
		PayloadTypeRegistry<RegistryByteBuf> playS2CRegistry = PayloadTypeRegistry.playS2C();
		playS2CRegistry.register(SpawnRulesPacket.ID, SpawnRulesPacket.CODEC);
		// Register client-side receiver
		ClientPlayNetworking.registerGlobalReceiver(SpawnRulesPacket.ID, (packet, context) -> {
			// Schedule handling on the main client thread
			context.client().execute(() -> {
				SpawnRulesData.setSpawnRules(packet.dimensionIndex(), packet.rules());
			});
		});
	}
}
</file>

<file path="client/java/ninja/trek/pocketportals/PocketPortalsDataGenerator.java">
package ninja.trek.pocketportals;
import net.fabricmc.fabric.api.client.datagen.v1.provider.FabricModelProvider;
import net.fabricmc.fabric.api.datagen.v1.DataGeneratorEntrypoint;
import net.fabricmc.fabric.api.datagen.v1.FabricDataGenerator;
import net.fabricmc.fabric.api.datagen.v1.FabricDataOutput;
import net.minecraft.client.data.*;
import net.minecraft.state.property.Properties;
import net.minecraft.util.Identifier;
import ninja.trek.pocketportals.block.ModBlocks;
import ninja.trek.pocketportals.dimension.PocketDimensionJsonProvider;
import ninja.trek.pocketportals.item.ModItems;
import java.util.concurrent.CompletableFuture;
import net.minecraft.registry.RegistryWrapper;
public class PocketPortalsDataGenerator implements DataGeneratorEntrypoint {
    @Override
    public void onInitializeDataGenerator(FabricDataGenerator fabricDataGenerator) {
        FabricDataGenerator.Pack pack = fabricDataGenerator.createPack();
        // Add Dimension Data Provider
        pack.addProvider((FabricDataOutput output, CompletableFuture<RegistryWrapper.WrapperLookup> registriesFuture) ->
                new PocketDimensionJsonProvider(output));
        // Add Model Provider
        pack.addProvider((FabricDataOutput output, CompletableFuture<RegistryWrapper.WrapperLookup> registriesFuture) ->
                new FabricModelProvider(output) {
                    @Override
                    public void generateBlockStateModels(BlockStateModelGenerator blockStateModelGenerator) {
                        // Create texture identifiers
                        Identifier portalTexture = Identifier.of(PocketPortals.MOD_ID, "block/pocket_portal");
                        Identifier returnPortalTexture = Identifier.of(PocketPortals.MOD_ID, "block/return_pocket_portal");
                        Identifier frameTexture = Identifier.of(PocketPortals.MOD_ID, "block/pocket_portal_frame");
                        // Create texture mappings
                        TextureMap portalTextures = new TextureMap()
                                .put(TextureKey.ALL, portalTexture);
                        TextureMap returnPortalTextures = new TextureMap()
                                .put(TextureKey.ALL, returnPortalTexture);
                        TextureMap frameTextures = new TextureMap()
                                .put(TextureKey.ALL, frameTexture);
                        // Generate base models
                        Identifier portalModel = Models.CUBE_ALL.upload(
                                ModBlocks.POCKET_PORTAL,
                                portalTextures,
                                blockStateModelGenerator.modelCollector
                        );
                        Identifier returnPortalModel = Models.CUBE_ALL.upload(
                                ModBlocks.RETURN_POCKET_PORTAL,
                                returnPortalTextures,
                                blockStateModelGenerator.modelCollector
                        );
                        Identifier frameModel = Models.CUBE_ALL.upload(
                                ModBlocks.POCKET_PORTAL_FRAME,
                                frameTextures,
                                blockStateModelGenerator.modelCollector
                        );
                        // Generate blockstates with variants
                        // Pocket Portal (with facing variants)
                        blockStateModelGenerator.blockStateCollector.accept(
                                VariantsBlockStateSupplier.create(ModBlocks.POCKET_PORTAL)
                                        .coordinate(BlockStateVariantMap.create(Properties.HORIZONTAL_FACING)
                                                .register(net.minecraft.util.math.Direction.NORTH, BlockStateVariant.create().put(VariantSettings.MODEL, portalModel))
                                                .register(net.minecraft.util.math.Direction.SOUTH, BlockStateVariant.create().put(VariantSettings.MODEL, portalModel).put(VariantSettings.Y, VariantSettings.Rotation.R180))
                                                .register(net.minecraft.util.math.Direction.WEST, BlockStateVariant.create().put(VariantSettings.MODEL, portalModel).put(VariantSettings.Y, VariantSettings.Rotation.R270))
                                                .register(net.minecraft.util.math.Direction.EAST, BlockStateVariant.create().put(VariantSettings.MODEL, portalModel).put(VariantSettings.Y, VariantSettings.Rotation.R90)))
                        );
                        // Return Portal (simple block)
                        blockStateModelGenerator.blockStateCollector.accept(
                                BlockStateModelGenerator.createSingletonBlockState(
                                        ModBlocks.RETURN_POCKET_PORTAL,
                                        returnPortalModel
                                )
                        );
                        // Portal Frame (simple block)
                        blockStateModelGenerator.blockStateCollector.accept(
                                BlockStateModelGenerator.createSingletonBlockState(
                                        ModBlocks.POCKET_PORTAL_FRAME,
                                        frameModel
                                )
                        );
                    }
                    @Override
                    public void generateItemModels(ItemModelGenerator itemModelGenerator) {
                        // Generate item models that reference block models
                        itemModelGenerator.register(ModItems.POCKET_PORTAL_ITEM, Models.GENERATED);
                    }
                });
    }
}
</file>

<file path="client/resources/pocket-portals.client.mixins.json">
{
	"required": true,
	"package": "ninja.trek.pocketportals.mixin.client",
	"compatibilityLevel": "JAVA_21",
	"client": [
		"ExampleClientMixin"
	],
	"injectors": {
		"defaultRequire": 1
	}
}
</file>

<file path="client/resources/pocketportals.client.mixins.json">
{
	"required": true,
	"package": "ninja.trek.pocketportals.mixin.client",
	"compatibilityLevel": "JAVA_21",
	"client": [
		"ExampleClientMixin"
	],
	"injectors": {
		"defaultRequire": 1
	}
}
</file>

<file path="main/java/ninja/trek/pocketportals/block/ModBlocks.java">
package ninja.trek.pocketportals.block;
import net.minecraft.block.AbstractBlock;
import net.minecraft.block.Block;
import net.minecraft.registry.Registry;
import net.minecraft.registry.RegistryKey;
import net.minecraft.registry.RegistryKeys;
import net.minecraft.registry.Registries;
import net.minecraft.util.Identifier;
import ninja.trek.pocketportals.PocketPortals;
import net.fabricmc.fabric.api.object.builder.v1.block.entity.FabricBlockEntityTypeBuilder;
public class ModBlocks {
    // --- Blocks ---
    public static Block POCKET_PORTAL;
    public static Block RETURN_POCKET_PORTAL;
    public static Block POCKET_PORTAL_FRAME;
    // --- Block Entities ---
    public static net.minecraft.block.entity.BlockEntityType<PocketPortalBlockEntity> POCKET_PORTAL_BLOCK_ENTITY;
    public static net.minecraft.block.entity.BlockEntityType<ReturnPocketPortalBlockEntity> RETURN_PORTAL_BLOCK_ENTITY;
    public static void registerBlocks() {
        POCKET_PORTAL = registerBlock("pocket_portal",
                AbstractBlock.Settings.create()
                        .strength(3.0f)
                        .requiresTool()
                        .nonOpaque());
        RETURN_POCKET_PORTAL = registerBlock("return_pocket_portal",
                AbstractBlock.Settings.create()
                        .strength(3.0f)
                        .requiresTool()
                        .nonOpaque());
        POCKET_PORTAL_FRAME = registerBlock("pocket_portal_frame",
                AbstractBlock.Settings.create()
                        .luminance(state -> 11)
                        .noCollision()
                        .strength(-1.0F));
        // Register block entities
        POCKET_PORTAL_BLOCK_ENTITY = Registry.register(
                Registries.BLOCK_ENTITY_TYPE,
                Identifier.of(PocketPortals.MOD_ID, "pocket_portal_entity"),
                FabricBlockEntityTypeBuilder.create(PocketPortalBlockEntity::new, POCKET_PORTAL).build()
        );
        RETURN_PORTAL_BLOCK_ENTITY = Registry.register(
                Registries.BLOCK_ENTITY_TYPE,
                Identifier.of(PocketPortals.MOD_ID, "return_portal_entity"),
                FabricBlockEntityTypeBuilder.create(ReturnPocketPortalBlockEntity::new, RETURN_POCKET_PORTAL).build()
        );
    }
    private static Block registerBlock(String name, AbstractBlock.Settings settings) {
        Identifier id = Identifier.of(PocketPortals.MOD_ID, name);
        RegistryKey<Block> key = RegistryKey.of(RegistryKeys.BLOCK, id);
        // Always attach the registry key to the settings!
        PocketPortals.LOGGER.info("Registering block {} with registry key {}", name, key);
        AbstractBlock.Settings settingsWithKey = settings.registryKey(key);
        Block block = createBlock(name, settingsWithKey);
        return Registry.register(Registries.BLOCK, key, block);
    }
    private static Block createBlock(String name, AbstractBlock.Settings settings) {
        return switch (name) {
            case "pocket_portal" -> new PocketPortalBlock(settings);
            case "return_pocket_portal" -> new ReturnPocketPortalBlock(settings);
            case "pocket_portal_frame" -> new PocketPortalFrame(settings);
            default -> throw new IllegalArgumentException("Unknown block: " + name);
        };
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/block/PocketPortalBlock.java">
package ninja.trek.pocketportals.block;
import com.mojang.serialization.MapCodec;
import net.minecraft.block.*;
import net.minecraft.block.entity.BlockEntity;
import net.minecraft.entity.Entity;
import net.minecraft.entity.LivingEntity;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.item.ItemStack;
import net.minecraft.server.world.ServerWorld;
import net.minecraft.state.StateManager;
import net.minecraft.state.property.Property;
import net.minecraft.util.Identifier;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Direction;
import net.minecraft.world.World;
import ninja.trek.pocketportals.dimension.PocketDimensionsRegistry;
import static ninja.trek.pocketportals.data.PocketPortalDataTypes.DIMENSION_INDEX;
public class PocketPortalBlock extends BlockWithEntity {
    public static final Property<Direction> FACING = HorizontalFacingBlock.FACING;
    public static final MapCodec<PocketPortalBlock> CODEC = createCodec(PocketPortalBlock::new);
    public PocketPortalBlock(Settings settings) {
        super(validateSettings(settings));
        setDefaultState(getStateManager().getDefaultState().with(FACING, Direction.NORTH));
    }
    private static Settings validateSettings(Settings settings) {
        if (settings == null) {
            throw new IllegalArgumentException("Settings cannot be null");
        }
        return settings;
    }
    @Override
    protected MapCodec<? extends BlockWithEntity> getCodec() {
        return CODEC;
    }
    @Override
    public BlockRenderType getRenderType(BlockState state) {
        return BlockRenderType.MODEL;
    }
    @Override
    protected void appendProperties(StateManager.Builder<Block, BlockState> builder) {
        builder.add(FACING);
    }
    @Override
    public BlockEntity createBlockEntity(BlockPos pos, BlockState state) {
        return new PocketPortalBlockEntity(pos, state);
    }
    // In PocketPortalBlock.java, modify the onPlaced method:
    @Override
    public void onPlaced(World world, BlockPos pos, BlockState state, LivingEntity placer, ItemStack stack) {
        super.onPlaced(world, pos, state, placer, stack);
        if (!world.isClient) {
            BlockEntity blockEntity = world.getBlockEntity(pos);
            if (blockEntity instanceof PocketPortalBlockEntity portalBE) {
                // Read dimension index from the item's components
                Integer storedIndex = stack.get(DIMENSION_INDEX);
                // If none present, get a new unused one
                if (storedIndex == null) {
                    storedIndex = PocketDimensionsRegistry.findUnusedSlot(((ServerWorld)world).getServer());
                }
                // Set it in the block entity
                portalBE.setDimensionIndex(storedIndex);
                portalBE.markDirty();
                // Create frame blocks above
                BlockPos portalPos1 = pos.up();
                BlockPos portalPos2 = portalPos1.up();
                world.setBlockState(portalPos1, ModBlocks.POCKET_PORTAL_FRAME.getDefaultState());
                world.setBlockState(portalPos2, ModBlocks.POCKET_PORTAL_FRAME.getDefaultState());
            }
        }
    }
    @Override
    public void onEntityCollision(BlockState state, World world, BlockPos pos, Entity entity) {
        if (!world.isClient) {
            // Only allow teleportation from overworld
            if (!world.getRegistryKey().equals(World.OVERWORLD)) {
                return;
            }
            BlockEntity be = world.getBlockEntity(pos);
            if (be instanceof PocketPortalBlockEntity portalBE) {
                portalBE.handleEntityCollision(entity);
            }
        }
    }
    @Override
    public BlockState onBreak(World world, BlockPos pos, BlockState state, PlayerEntity player) {
        if (!world.isClient) {
            BlockEntity be = world.getBlockEntity(pos);
            if (be instanceof PocketPortalBlockEntity portalBE) {
                Integer dimIndex = portalBE.getDimensionIndex();
                // Create a new item with the dimension index
                ItemStack newStack = new ItemStack(ModBlocks.POCKET_PORTAL);
                if (dimIndex != null) {
                    // Store using item components
                    newStack.set(DIMENSION_INDEX, dimIndex);
                }
                // Drop the item
                Block.dropStack(world, pos, newStack);
            }
        }
        // Remove frames above
        world.setBlockState(pos.up(), Blocks.AIR.getDefaultState());
        world.setBlockState(pos.up(2), Blocks.AIR.getDefaultState());
        return super.onBreak(world, pos, state, player);
    }
    @Override
    public void onStateReplaced(BlockState state, World world, BlockPos pos,
                                BlockState newState, boolean moved) {
        if (!state.isOf(newState.getBlock())) {
            // Remove frame blocks
            world.setBlockState(pos.up(), Blocks.AIR.getDefaultState());
            world.setBlockState(pos.up(2), Blocks.AIR.getDefaultState());
        }
        super.onStateReplaced(state, world, pos, newState, moved);
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/block/PocketPortalBlockEntity.java">
package ninja.trek.pocketportals.block;
import net.fabricmc.fabric.api.networking.v1.PacketByteBufs;
import net.fabricmc.fabric.api.networking.v1.ServerPlayNetworking;
import net.minecraft.block.BlockState;
import net.minecraft.block.entity.BlockEntity;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityType;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.nbt.NbtCompound;
import net.minecraft.network.PacketByteBuf;
import net.minecraft.network.packet.s2c.play.PositionFlag;
import net.minecraft.registry.RegistryWrapper;
import net.minecraft.server.network.ServerPlayerEntity;
import net.minecraft.server.world.ServerWorld;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.Heightmap;
import ninja.trek.pocketportals.PocketPortals;
import ninja.trek.pocketportals.SpawnRulesData;
import ninja.trek.pocketportals.dimension.GridSpawnRules;
import ninja.trek.pocketportals.dimension.ModDimensions;
import ninja.trek.pocketportals.dimension.PocketDimensionsRegistry;
import ninja.trek.pocketportals.network.SpawnRulesPacket;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.Map;
public class PocketPortalBlockEntity extends BlockEntity {
    private static final String DIMENSION_INDEX_KEY = "PocketDimensionIndex";
    private Integer dimensionIndex = null; // store an index from 0..255
    public PocketPortalBlockEntity(BlockPos pos, BlockState state) {
        super(ModBlocks.POCKET_PORTAL_BLOCK_ENTITY, pos, state);
    }
    public Integer getDimensionIndex() {
        return dimensionIndex;
    }
    public void setDimensionIndex(Integer dimensionIndex) {
        this.dimensionIndex = dimensionIndex;
    }
    @Override
    public void readNbt(NbtCompound nbt, RegistryWrapper.WrapperLookup lookup) {
        super.readNbt(nbt, lookup);
        if (nbt.contains(DIMENSION_INDEX_KEY)) {
            dimensionIndex = nbt.getInt(DIMENSION_INDEX_KEY);
        }
    }
    @Override
    public void writeNbt(NbtCompound nbt, RegistryWrapper.WrapperLookup lookup) {
        super.writeNbt(nbt, lookup);
        if (dimensionIndex != null) {
            nbt.putInt(DIMENSION_INDEX_KEY, dimensionIndex);
        }
    }
    // In PocketPortalBlockEntity.java, modify handleEntityCollision:
    public void handleEntityCollision(Entity entity) {
        if (!(world instanceof ServerWorld serverWorld)) return;
        if (!entity.canUsePortals(false)) return;
        if (dimensionIndex == null) {
            PocketPortals.LOGGER.warn("Portal block has no dimension index assigned!");
            return;
        }
        if (entity.hasPortalCooldown()) {
            return;
        }
        // Set portal cooldown (20 ticks = 1 second)
        entity.setPortalCooldown(20);
        // Get the target dimension
        ServerWorld targetWorld = serverWorld.getServer().getWorld(PocketDimensionsRegistry.getDimensionKey());
        if (targetWorld == null) {
            PocketPortals.LOGGER.error("Pocket dimension is not loaded!");
            return;
        }
        // Are we already in the pocket dimension?
        if (serverWorld.getRegistryKey().equals(PocketDimensionsRegistry.getDimensionKey())) {
            // Then go back to Overworld
            ServerWorld overworld = serverWorld.getServer().getOverworld();
            teleportEntity(entity, overworld, pos.getX() + 0.5, pos.getY() + 1, pos.getZ() + 0.5);
        } else {
            // Calculate grid position from index
            ModDimensions.GridPosition gridPos = ModDimensions.indexToGridPosition(dimensionIndex);
            ModDimensions.WorldPosition worldPos = ModDimensions.gridToWorldPosition(gridPos);
            // Teleport to the specific grid location in the pocket dimension
            teleportEntity(entity, targetWorld,
                    worldPos.x() + 0.5, worldPos.y() + 1, worldPos.z() + 0.5);
            // Build return portal at the destination
            BlockPos base = new BlockPos(worldPos.x() + 2, worldPos.y(), worldPos.z());
            // Create RETURN portal block
            targetWorld.setBlockState(base, ModBlocks.RETURN_POCKET_PORTAL.getDefaultState());
            targetWorld.setBlockState(base.up(), ModBlocks.POCKET_PORTAL_FRAME.getDefaultState());
            targetWorld.setBlockState(base.up(2), ModBlocks.POCKET_PORTAL_FRAME.getDefaultState());
            // Set up the return portal block entity
            BlockEntity be = targetWorld.getBlockEntity(base);
            if (be instanceof ReturnPocketPortalBlockEntity returnPortalBE) {
                // Store the entry Y position instead of the block's Y position
                BlockPos returnPos = new BlockPos(pos.getX(), entity.getBlockY(), pos.getZ());
                returnPortalBE.setReturnPosition(returnPos, world.getRegistryKey());
                returnPortalBE.markDirty();
            }
        }
    }
    private void teleportEntity(Entity entity, ServerWorld targetWorld, double x, double y, double z) {
        BlockPos.Mutable checkPos = new BlockPos.Mutable((int)x, (int)y, (int)z);
        // Get the actual height from the chunk generator
        int surfaceHeight = targetWorld.getChunkManager()
                .getChunkGenerator()
                .getHeight((int)x, (int)z,
                        Heightmap.Type.MOTION_BLOCKING,
                        targetWorld,
                        targetWorld.getChunkManager().getNoiseConfig());
        // Set our check position to the surface height
        checkPos.set((int)x, surfaceHeight, (int)z);
        // Move up until we have 2 blocks of air clearance
        while (checkPos.getY() < targetWorld.getTopYInclusive() &&
                (!targetWorld.getBlockState(checkPos).isAir() ||
                        !targetWorld.getBlockState(checkPos.up()).isAir())) {
            checkPos.move(0, 1, 0);
        }
        // Teleport to the safe position we found
        entity.teleport(
                targetWorld,
                x, checkPos.getY(), z,
                EnumSet.noneOf(PositionFlag.class),
                entity.getYaw(),
                entity.getPitch(),
                true
        );
    }
    public void syncSpawnRules(PlayerEntity player) {
        if (dimensionIndex == null || !(player instanceof ServerPlayerEntity serverPlayer)) return;
        // Get spawn rules for this dimension index
        GridSpawnRules rules = PocketDimensionsRegistry.getSpawnRules(world.getServer(), dimensionIndex);
        if (rules == null) return;
        // Create map of spawn rules
        Map<EntityType<?>, Boolean> spawnRules = new HashMap<>();
        // Add all managed mobs to the map
        for (EntityType<?> entityType : PocketDimensionsRegistry.MANAGED_MOBS) {
            spawnRules.put(entityType, rules.canSpawn(entityType));
        }
        // Create and send packet
        SpawnRulesPacket packet = new SpawnRulesPacket(dimensionIndex, spawnRules);
        ServerPlayNetworking.send(serverPlayer, packet);
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/block/PocketPortalFrame.java">
package ninja.trek.pocketportals.block;
import com.mojang.serialization.MapCodec;
import net.minecraft.block.Block;
import net.minecraft.block.BlockRenderType;
import net.minecraft.block.BlockState;
import net.minecraft.block.Blocks;
import net.minecraft.block.entity.BlockEntity;
import net.minecraft.entity.Entity;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.particle.ParticleTypes;
import net.minecraft.sound.SoundCategory;
import net.minecraft.sound.SoundEvents;
import net.minecraft.util.ActionResult;
import net.minecraft.util.Hand;
import net.minecraft.util.hit.BlockHitResult;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.random.Random;
import net.minecraft.text.Text;
import net.minecraft.world.World;
public class PocketPortalFrame extends Block {
    public static final MapCodec<PocketPortalFrame> CODEC = createCodec(PocketPortalFrame::new);
    public PocketPortalFrame(Settings settings) {
        super(validateSettings(settings));
    }
    private static Settings validateSettings(Settings settings) {
        if (settings == null) {
            throw new IllegalArgumentException("Settings cannot be null");
        }
        return settings;
    }
    @Override
    public void onEntityCollision(BlockState state, World world, BlockPos pos, Entity entity) {
        if (!world.isClient && entity.canUsePortals(false)) {
            // Find the portal base block by searching downward
            BlockPos basePos = findPortalBase(world, pos);
            if (basePos != null) {
                BlockEntity blockEntity = world.getBlockEntity(basePos);
                // Handle both types of portal bases
                if (blockEntity instanceof PocketPortalBlockEntity portalBlockEntity) {
                    portalBlockEntity.handleEntityCollision(entity);
                } else if (blockEntity instanceof ReturnPocketPortalBlockEntity returnPortalBlockEntity) {
                    returnPortalBlockEntity.handleEntityCollision(entity);
                }
            }
        }
    }
    /**
     * Allow sneak-right-click to show dimension info in chat.
     */
    @Override
    public ActionResult onUse(BlockState state, World world, BlockPos pos,
                              PlayerEntity player, BlockHitResult hit) {
        if (!world.isClient) {
            BlockPos basePos = findPortalBase(world, pos);
            if (basePos != null) {
                BlockEntity be = world.getBlockEntity(basePos);
                if (be instanceof PocketPortalBlockEntity portalBE) {
                    portalBE.syncSpawnRules(player);
                }
            }
        }
        return ActionResult.SUCCESS;
    }
    private BlockPos findPortalBase(World world, BlockPos startPos) {
        // Search downward for either type of portal base block
        BlockPos.Mutable currentPos = startPos.mutableCopy();
        for (int y = 0; y > -3; y--) {
            currentPos.move(0, y, 0);
            if (world.getBlockState(currentPos).getBlock() instanceof PocketPortalBlock ||
                    world.getBlockState(currentPos).getBlock() instanceof ReturnPocketPortalBlock) {
                return currentPos.toImmutable();
            }
        }
        return null;
    }
    @Override
    public void randomDisplayTick(BlockState state, World world, BlockPos pos, Random random) {
        if (random.nextInt(100) == 0) {
            world.playSound(
                    pos.getX() + 0.5D,
                    pos.getY() + 0.5D,
                    pos.getZ() + 0.5D,
                    SoundEvents.BLOCK_PORTAL_AMBIENT,
                    SoundCategory.BLOCKS,
                    0.5F,
                    random.nextFloat() * 0.4F + 0.8F,
                    false
            );
        }
        for(int i = 0; i < 4; ++i) {
            double x = pos.getX() + random.nextDouble();
            double y = pos.getY() + random.nextDouble();
            double z = pos.getZ() + random.nextDouble();
            double dx = (random.nextDouble() - 0.5D) * 0.5D;
            double dy = (random.nextDouble() - 0.5D) * 0.5D;
            double dz = (random.nextDouble() - 0.5D) * 0.5D;
            world.addParticle(ParticleTypes.PORTAL, x, y, z, dx, dy, dz);
        }
    }
    @Override
    public BlockRenderType getRenderType(BlockState state) {
        return BlockRenderType.MODEL;
    }
    @Override
    protected MapCodec<? extends Block> getCodec() {
        return CODEC;
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/block/ReturnPocketPortalBlock.java">
package ninja.trek.pocketportals.block;
import com.mojang.serialization.MapCodec;
import net.minecraft.block.BlockRenderType;
import net.minecraft.block.BlockState;
import net.minecraft.block.BlockWithEntity;
import net.minecraft.block.Blocks;
import net.minecraft.block.entity.BlockEntity;
import net.minecraft.entity.Entity;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.World;
import ninja.trek.pocketportals.PocketPortals;
import ninja.trek.pocketportals.block.ReturnPocketPortalBlockEntity;
import ninja.trek.pocketportals.dimension.PocketDimensionsRegistry;
public class ReturnPocketPortalBlock extends BlockWithEntity {
    public static final MapCodec<ReturnPocketPortalBlock> CODEC = createCodec(ReturnPocketPortalBlock::new);
    public ReturnPocketPortalBlock(Settings settings) {
        super(validateSettings(settings));
    }
    private static Settings validateSettings(Settings settings) {
        if (settings == null) {
            throw new IllegalArgumentException("Settings cannot be null");
        }
        return settings;
    }
    @Override
    protected MapCodec<? extends BlockWithEntity> getCodec() {
        return CODEC;
    }
    @Override
    public BlockRenderType getRenderType(BlockState state) {
        return BlockRenderType.MODEL;
    }
    @Override
    public BlockEntity createBlockEntity(BlockPos pos, BlockState state) {
        return new ReturnPocketPortalBlockEntity(pos, state);
    }
    @Override
    public void onEntityCollision(BlockState state, World world, BlockPos pos, Entity entity) {
        if (!world.isClient) {
            // Only handle collision if we're in the pocket dimension
            if (!world.getRegistryKey().equals(PocketDimensionsRegistry.getDimensionKey())) {
                return;
            }
            BlockEntity be = world.getBlockEntity(pos);
            if (be instanceof ReturnPocketPortalBlockEntity returnPortalBE) {
                // Add debug logging
                PocketPortals.LOGGER.info("Entity {} collided with return portal at {}",
                        entity.getUuidAsString(), pos);
                returnPortalBE.handleEntityCollision(entity);
            }
        }
    }
    @Override
    public void onStateReplaced(BlockState state, World world, BlockPos pos,
                                BlockState newState, boolean moved) {
        if (!state.isOf(newState.getBlock())) {
            // Remove frame blocks
            world.setBlockState(pos.up(), Blocks.AIR.getDefaultState());
            world.setBlockState(pos.up(2), Blocks.AIR.getDefaultState());
        }
        super.onStateReplaced(state, world, pos, newState, moved);
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/block/ReturnPocketPortalBlockEntity.java">
package ninja.trek.pocketportals.block;
import net.minecraft.block.BlockState;
import net.minecraft.block.entity.BlockEntity;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityType;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.nbt.NbtCompound;
import net.minecraft.network.packet.s2c.play.PositionFlag;
import net.minecraft.registry.RegistryKey;
import net.minecraft.registry.RegistryKeys;
import net.minecraft.registry.RegistryWrapper;
import net.minecraft.server.network.ServerPlayerEntity;
import net.minecraft.server.world.ServerWorld;
import net.minecraft.sound.SoundCategory;
import net.minecraft.sound.SoundEvents;
import net.minecraft.util.Identifier;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.World;
import ninja.trek.pocketportals.PocketPortals;
import ninja.trek.pocketportals.dimension.GridSpawnRules;
import ninja.trek.pocketportals.dimension.PocketDimensionsRegistry;
import ninja.trek.pocketportals.network.SpawnRulesPacket;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.Map;
public class ReturnPocketPortalBlockEntity extends BlockEntity {
    private static final String RETURN_POS_X = "ReturnPosX";
    private static final String RETURN_POS_Y = "ReturnPosY";
    private static final String RETURN_POS_Z = "ReturnPosZ";
    private static final String RETURN_DIMENSION = "ReturnDimension";
    private BlockPos returnPosition;
    private RegistryKey<World> returnDimension;
    public ReturnPocketPortalBlockEntity(BlockPos pos, BlockState state) {
        super(ModBlocks.RETURN_PORTAL_BLOCK_ENTITY, pos, state);
    }
    public void setReturnPosition(BlockPos pos, RegistryKey<World> dimension) {
        this.returnPosition = pos;
        this.returnDimension = dimension;
        markDirty();
        PocketPortals.LOGGER.info("Set return portal destination: pos={}, dim={}",
                pos, dimension.getValue());
    }
    @Override
    public void readNbt(NbtCompound nbt, RegistryWrapper.WrapperLookup lookup) {
        super.readNbt(nbt, lookup);
        if (nbt.contains(RETURN_POS_X)) {
            int x = nbt.getInt(RETURN_POS_X);
            int y = nbt.getInt(RETURN_POS_Y);
            int z = nbt.getInt(RETURN_POS_Z);
            returnPosition = new BlockPos(x, y, z);
            String dimId = nbt.getString(RETURN_DIMENSION);
            returnDimension = RegistryKey.of(RegistryKeys.WORLD, Identifier.of(dimId));
            PocketPortals.LOGGER.info("Loaded return portal data: pos={}, dim={}",
                    returnPosition, returnDimension.getValue());
        }
    }
    @Override
    public void writeNbt(NbtCompound nbt, RegistryWrapper.WrapperLookup lookup) {
        super.writeNbt(nbt, lookup);
        if (returnPosition != null && returnDimension != null) {
            nbt.putInt(RETURN_POS_X, returnPosition.getX());
            nbt.putInt(RETURN_POS_Y, returnPosition.getY());
            nbt.putInt(RETURN_POS_Z, returnPosition.getZ());
            nbt.putString(RETURN_DIMENSION, returnDimension.getValue().toString());
            PocketPortals.LOGGER.info("Saved return portal data: pos={}, dim={}",
                    returnPosition, returnDimension.getValue());
        }
    }
    private BlockPos findSafeReturnLocation(ServerWorld targetWorld, BlockPos originalPos) {
        // First check if the original position still has a portal
        if (targetWorld.getBlockState(originalPos).isOf(ModBlocks.POCKET_PORTAL)) {
            // Portal is still there, use it!
            PocketPortals.LOGGER.info("Original portal found at {}, using it", originalPos);
            return originalPos;
        }
        // If portal is gone, start looking for safe spots
        if (isSafeSpot(targetWorld, originalPos)) {
            PocketPortals.LOGGER.info("Original position {} is safe, using it", originalPos);
            return originalPos;
        }
        BlockPos.Mutable checkPos = originalPos.mutableCopy();
        // First search near the original Y level (within ยฑ2 blocks)
        for (int y = -2; y <= 2; y++) {
            checkPos.setY(originalPos.getY() + y);
            if (isSafeSpot(targetWorld, checkPos)) {
                PocketPortals.LOGGER.info("Found safe spot near original Y: {}", checkPos);
                return checkPos.toImmutable();
            }
        }
        // If that fails, search more extensively around the original Y
        int searchRadius = 10;
        // Search downward from original Y
        for (int y = originalPos.getY() - 3; y >= Math.max(targetWorld.getBottomY(), originalPos.getY() - searchRadius); y--) {
            checkPos.setY(y);
            if (isSafeSpot(targetWorld, checkPos)) {
                PocketPortals.LOGGER.info("Found safe spot below: {}", checkPos);
                return checkPos.toImmutable();
            }
        }
        // Then search upward from original Y
        for (int y = originalPos.getY() + 3; y <= Math.min(targetWorld.getTopYInclusive() - 2, originalPos.getY() + searchRadius); y++) {
            checkPos.setY(y);
            if (isSafeSpot(targetWorld, checkPos)) {
                PocketPortals.LOGGER.info("Found safe spot above: {}", checkPos);
                return checkPos.toImmutable();
            }
        }
        // If still no safe spot, find highest solid block below original position
        checkPos = originalPos.mutableCopy();
        for (int y = originalPos.getY(); y >= targetWorld.getBottomY(); y--) {
            checkPos.setY(y);
            if (targetWorld.getBlockState(checkPos).isSolid()) {
                BlockPos safePos = checkPos.up().toImmutable();
                PocketPortals.LOGGER.info("Using highest solid block method, found: {}", safePos);
                return safePos;
            }
        }
        // Absolute last resort - go to original Y but ensure there's air
        BlockPos lastResort = new BlockPos(originalPos.getX(), originalPos.getY(), originalPos.getZ());
        targetWorld.setBlockState(lastResort, net.minecraft.block.Blocks.AIR.getDefaultState());
        targetWorld.setBlockState(lastResort.up(), net.minecraft.block.Blocks.AIR.getDefaultState());
        PocketPortals.LOGGER.warn("Using last resort position: {}", lastResort);
        return lastResort;
    }
    private boolean isSafeSpot(ServerWorld world, BlockPos pos) {
        // Check for portal blocks and frames - we don't want to spawn inside these
        // unless it's our original portal (which is checked separately)
        if (world.getBlockState(pos).isOf(ModBlocks.POCKET_PORTAL_FRAME) ||
                world.getBlockState(pos.up()).isOf(ModBlocks.POCKET_PORTAL_FRAME) ||
                world.getBlockState(pos).isOf(ModBlocks.POCKET_PORTAL) ||
                world.getBlockState(pos.up()).isOf(ModBlocks.POCKET_PORTAL)) {
            return false;
        }
        // Must have two air blocks for player height
        if (!world.getBlockState(pos).isAir() || !world.getBlockState(pos.up()).isAir()) {
            return false;
        }
        // Must have solid ground below
        BlockPos groundPos = pos.down();
        return world.getBlockState(groundPos).isSolid() ||
                world.getBlockState(groundPos).blocksMovement();
    }
    public void handleEntityCollision(Entity entity) {
        if (!(world instanceof ServerWorld serverWorld)) {
            PocketPortals.LOGGER.error("Return portal not in server world!");
            return;
        }
        if (!entity.canUsePortals(false)) {
            PocketPortals.LOGGER.debug("Entity cannot use portals: {}", entity);
            return;
        }
        if (returnPosition == null || returnDimension == null) {
            PocketPortals.LOGGER.error("Return portal missing destination data: pos={}, dim={}",
                    returnPosition, returnDimension);
            return;
        }
        // Get the target world
        ServerWorld targetWorld = serverWorld.getServer().getWorld(returnDimension);
        if (targetWorld == null) {
            PocketPortals.LOGGER.error("Target world not found: {}", returnDimension.getValue());
            return;
        }
        // Find a safe return location (prioritizing original portal)
        BlockPos safePos = findSafeReturnLocation(targetWorld, returnPosition);
        PocketPortals.LOGGER.info("Found safe return location: {} (original was {})",
                safePos, returnPosition);
        // Only apply cooldown if teleport is successful
        if (entity.hasPortalCooldown()) {
            PocketPortals.LOGGER.debug("Entity {} has portal cooldown", entity.getUuidAsString());
            return;
        }
        // Calculate target position
        double targetX = safePos.getX() + 0.5;
        double targetY = safePos.getY();
        double targetZ = safePos.getZ() + 0.5;
        // If returning to original portal, adjust Y position to be inside the portal
        if (targetWorld.getBlockState(safePos).isOf(ModBlocks.POCKET_PORTAL)) {
            targetY += 0.5; // Position entity in middle of portal block
        }
        // Reduced cooldown from 1000 to 100 ticks (5 seconds)
        entity.setPortalCooldown(100);
        // Perform the teleport
        boolean success = entity.teleport(
                targetWorld,
                targetX,
                targetY,
                targetZ,
                EnumSet.noneOf(PositionFlag.class),
                entity.getYaw(),
                entity.getPitch(),
                true
        );
        if (success) {
            // Play portal sound
            world.playSound(null, pos,
                    SoundEvents.BLOCK_PORTAL_TRAVEL,
                    SoundCategory.BLOCKS,
                    0.25f,
                    1.0f);
            PocketPortals.LOGGER.info("Successfully teleported entity {} to {}",
                    entity.getUuidAsString(), safePos);
        } else {
            PocketPortals.LOGGER.error("Failed to teleport entity {} to {}",
                    entity.getUuidAsString(), safePos);
        }
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/data/DataLoader.java">
package ninja.trek.pocketportals.data;
import net.fabricmc.fabric.api.resource.ResourceManagerHelper;
import net.fabricmc.fabric.api.resource.SimpleSynchronousResourceReloadListener;
import net.minecraft.resource.ResourceManager;
import net.minecraft.resource.ResourceType;
import net.minecraft.util.Identifier;
import ninja.trek.pocketportals.PocketPortals;
public class DataLoader {
    public static void register() {
        ResourceManagerHelper.get(ResourceType.SERVER_DATA).registerReloadListener(
                new SimpleSynchronousResourceReloadListener() {
                    @Override
                    public Identifier getFabricId() {
                        return Identifier.of(PocketPortals.MOD_ID, "dimension_loader");
                    }
                    @Override
                    public void reload(ResourceManager manager) {
                        // Check for dimension type file
                        Identifier dimTypeId = Identifier.of(PocketPortals.MOD_ID, "dimension_type/pocket_dimension_type.json");
                        if (manager.getResource(dimTypeId).isPresent()) {
                            PocketPortals.LOGGER.info("Found pocket dimension type configuration");
                        } else {
                            PocketPortals.LOGGER.error("Missing pocket dimension type configuration at {}", dimTypeId);
                        }
                        // Check for dimension file
                        Identifier dimId = Identifier.of(PocketPortals.MOD_ID, "dimension/pocket_dimension.json");
                        if (manager.getResource(dimId).isPresent()) {
                            PocketPortals.LOGGER.info("Found pocket dimension configuration");
                        } else {
                            PocketPortals.LOGGER.error("Missing pocket dimension configuration at {}", dimId);
                        }
                    }
                }
        );
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/data/PocketPortalDataTypes.java">
package ninja.trek.pocketportals.data;
import com.mojang.serialization.Codec;
import net.minecraft.component.ComponentType;
import net.minecraft.network.RegistryByteBuf;
import net.minecraft.network.codec.PacketCodec;
import net.minecraft.util.Identifier;
/**
 * Defines a custom ComponentType<Integer> for storing a dimension index
 * in an item or block entity, using Minecraft 1.21's new item component system.
 */
public final class PocketPortalDataTypes {
    /**
     * Our custom component type that stores an Integer (dimension index).
     *
     * - Codec: Handles saving/loading from NBT and JSON.
     * - PacketCodec: Handles network sync and serialization.
     */
    public static final ComponentType<Integer> DIMENSION_INDEX = new ComponentType.Builder<Integer>()
            .codec(Codec.INT) // Set up codec for serialization
            .packetCodec(new PacketCodec<RegistryByteBuf, Integer>() {
                @Override
                public Integer decode(RegistryByteBuf buf) {
                    return buf.readVarInt(); // Read the dimension index from the network buffer
                }
                @Override
                public void encode(RegistryByteBuf buf, Integer value) {
                    buf.writeVarInt(value); // Write the dimension index to the network buffer
                }
            })
            .build(); // Build the ComponentType
    // Prevent instantiation
    private PocketPortalDataTypes() {}
}
</file>

<file path="main/java/ninja/trek/pocketportals/dimension/GridBiomeSource.java">
package ninja.trek.pocketportals.dimension;
import com.mojang.serialization.Codec;
import com.mojang.serialization.MapCodec;
import com.mojang.serialization.codecs.RecordCodecBuilder;
import net.minecraft.registry.Registry;
import net.minecraft.registry.RegistryKeys;
import net.minecraft.registry.entry.RegistryEntry;
import net.minecraft.util.Identifier;
import net.minecraft.world.biome.Biome;
import net.minecraft.world.biome.BiomeKeys;
import net.minecraft.world.biome.source.BiomeSource;
import net.minecraft.world.biome.source.util.MultiNoiseUtil;
import ninja.trek.pocketportals.PocketPortals;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Stream;
public class GridBiomeSource extends BiomeSource {
    private final long seed;
    private Registry<Biome> biomeRegistry;
    private final List<RegistryEntry<Biome>> biomes;
    private RegistryEntry<Biome> fallbackBiome;
    public static final MapCodec<GridBiomeSource> CODEC = RecordCodecBuilder.mapCodec(instance ->
            instance.group(
                    Codec.LONG.fieldOf("seed").stable().forGetter(source -> source.seed)
            ).apply(instance, GridBiomeSource::new));
    public GridBiomeSource(long seed) {
        this.seed = seed;
        this.biomes = new ArrayList<>();
    }
    @Override
    protected MapCodec<? extends BiomeSource> getCodec() {
        return CODEC;
    }
    @Override
    public RegistryEntry<Biome> getBiome(int x, int y, int z, MultiNoiseUtil.MultiNoiseSampler noise) {
        initializeBiomesIfNeeded();
        if (biomes.isEmpty()) {
            return getFallbackBiome();
        }
        int gridX = Math.floorDiv(x, ModDimensions.GRID_SPACING);
        int gridZ = Math.floorDiv(z, ModDimensions.GRID_SPACING);
        // Create deterministic random using grid coordinates and seed
        var random = new java.util.Random(seed ^ ((long)gridX << 32 | (long)gridZ));
        // Select a random biome from our valid biomes list
        return biomes.get(random.nextInt(biomes.size()));
    }
    private RegistryEntry<Biome> getFallbackBiome() {
        if (fallbackBiome == null && biomeRegistry != null) {
            // Try to get plains biome
            var plainsId = BiomeKeys.PLAINS.getValue();
            if (biomeRegistry.containsId(plainsId)) {
                var plainsBiome = biomeRegistry.get(plainsId);
                if (plainsBiome != null) {
                    fallbackBiome = biomeRegistry.getEntry(plainsBiome);
                }
            }
            // If plains isn't available, use the first biome in the registry
            if (fallbackBiome == null) {
                var firstEntry = biomeRegistry.getEntrySet().stream().findFirst();
                if (firstEntry.isPresent()) {
                    fallbackBiome = biomeRegistry.getEntry(firstEntry.get().getValue());
                } else {
                    throw new IllegalStateException("No biomes available in registry");
                }
            }
        }
        if (fallbackBiome == null) {
            throw new IllegalStateException("Could not initialize fallback biome");
        }
        return fallbackBiome;
    }
    @Override
    public Stream<RegistryEntry<Biome>> biomeStream() {
        initializeBiomesIfNeeded();
        return biomes.stream();
    }
    private void initializeBiomesIfNeeded() {
        if (biomeRegistry == null || biomes.isEmpty()) {
            // Get server safely
            var server = PocketPortals.getServer();
            if (server == null) {
                PocketPortals.LOGGER.warn("Server not yet available for biome initialization");
                return;
            }
            var overworld = server.getOverworld();
            if (overworld == null) {
                PocketPortals.LOGGER.warn("Overworld not yet available for biome initialization");
                return;
            }
            biomeRegistry = overworld.getRegistryManager().getOrThrow(RegistryKeys.BIOME);
            if (biomeRegistry != null) {
                populateBiomes();
            }
        }
    }
    private void populateBiomes() {
        if (biomeRegistry == null) return;
        biomes.clear();
        // Add all valid overworld biomes
        biomeRegistry.getEntrySet().forEach(entry -> {
            if (isValidOverworldBiome(entry.getKey().getValue())) {
                var biome = entry.getValue();
                this.biomes.add(biomeRegistry.getEntry(biome));
            }
        });
        if (biomes.isEmpty()) {
            PocketPortals.LOGGER.warn("No valid overworld biomes found, adding plains as fallback");
            var plainsId = BiomeKeys.PLAINS.getValue();
            if (biomeRegistry.containsId(plainsId)) {
                var plainsBiome = biomeRegistry.get(plainsId);
                if (plainsBiome != null) {
                    biomes.add(biomeRegistry.getEntry(plainsBiome));
                }
            }
        }
        PocketPortals.LOGGER.info("Initialized GridBiomeSource with {} biomes", biomes.size());
    }
    private boolean isValidOverworldBiome(Identifier id) {
        String path = id.getPath();
        return !path.contains("end") &&
                !path.contains("nether") &&
                !path.contains("basalt") &&
                !path.contains("void") &&
                !path.contains("small") &&
                !path.startsWith("debug_") &&
                !path.equals("custom");
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/dimension/GridSpawnRules.java">
package ninja.trek.pocketportals.dimension;
import net.minecraft.entity.EntityType;
import net.minecraft.nbt.NbtCompound;
import net.minecraft.nbt.NbtList;
import net.minecraft.registry.Registries;
import net.minecraft.util.Identifier;
import java.util.HashMap;
import java.util.Map;
public class GridSpawnRules {
    private final int gridIndex;
    private final Map<EntityType<?>, Boolean> spawnRules;
    public GridSpawnRules(int gridIndex) {
        this.gridIndex = gridIndex;
        this.spawnRules = new HashMap<>();
        // Default to allowing all standard hostile mobs
        setDefaultRules();
    }
    private void setDefaultRules() {
        // Allow common hostile mobs by default
        spawnRules.put(EntityType.ZOMBIE, true);
        spawnRules.put(EntityType.SKELETON, true);
        spawnRules.put(EntityType.SPIDER, true);
        spawnRules.put(EntityType.CREEPER, true);
        spawnRules.put(EntityType.ENDERMAN, true);
        spawnRules.put(EntityType.WITCH, true);
        spawnRules.put(EntityType.PHANTOM, true);
        spawnRules.put(EntityType.SLIME, true);
    }
    public boolean canSpawn(EntityType<?> entityType) {
        return spawnRules.getOrDefault(entityType, true);
    }
    public void setSpawnRule(EntityType<?> entityType, boolean allowed) {
        spawnRules.put(entityType, allowed);
    }
    public NbtCompound writeNbt() {
        NbtCompound nbt = new NbtCompound();
        nbt.putInt("GridIndex", gridIndex);
        NbtList rulesList = new NbtList();
        spawnRules.forEach((entityType, allowed) -> {
            NbtCompound ruleNbt = new NbtCompound();
            ruleNbt.putString("EntityType", Registries.ENTITY_TYPE.getId(entityType).toString());
            ruleNbt.putBoolean("Allowed", allowed);
            rulesList.add(ruleNbt);
        });
        nbt.put("SpawnRules", rulesList);
        return nbt;
    }
    public static GridSpawnRules fromNbt(NbtCompound nbt) {
        int gridIndex = nbt.getInt("GridIndex");
        GridSpawnRules rules = new GridSpawnRules(gridIndex);
        NbtList rulesList = nbt.getList("SpawnRules", 10); // 10 is the NBT type for compound tags
        rulesList.forEach(element -> {
            NbtCompound ruleNbt = (NbtCompound) element;
            EntityType<?> entityType = Registries.ENTITY_TYPE.get(
                    Identifier.tryParse(ruleNbt.getString("EntityType")));
            boolean allowed = ruleNbt.getBoolean("Allowed");
            rules.setSpawnRule(entityType, allowed);
        });
        return rules;
    }
    public int getGridIndex() {
        return gridIndex;
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/dimension/ModDimensions.java">
package ninja.trek.pocketportals.dimension;
import com.mojang.serialization.Codec;
import com.mojang.serialization.MapCodec;
import net.minecraft.registry.Registry;
import net.minecraft.registry.Registries;
import net.minecraft.registry.RegistryKey;
import net.minecraft.util.Identifier;
import net.minecraft.world.biome.source.BiomeSource;
import net.minecraft.world.gen.chunk.ChunkGenerator;
import ninja.trek.pocketportals.PocketPortals;
public class ModDimensions {
    public static final int GRID_SPACING = 100_000; // Blocks between each portal location
    public static final int GRID_SIZE = 600; // 600x600 grid
    public static void register() {
        // Register chunk generator - this works fine
        Registry.register(
                Registries.CHUNK_GENERATOR,
                Identifier.of(PocketPortals.MOD_ID, "sky_island"),
                SkyIslandChunkGenerator.CODEC
        );
        // Get the proper registry type for biome source
        Registry<MapCodec<? extends BiomeSource>> biomeSourceRegistry =
                (Registry<MapCodec<? extends BiomeSource>>)(Registry<?>) Registries.BIOME_SOURCE;
        // Convert GridBiomeSource.CODEC to MapCodec
        MapCodec<GridBiomeSource> biomeSourceMapCodec = GridBiomeSource.CODEC;
        Registry.register(
                biomeSourceRegistry,
                Identifier.of(PocketPortals.MOD_ID, "grid_biome_source"),
                biomeSourceMapCodec
        );
    }
    /**
     * Convert a dimension index (0-359999) to grid coordinates
     */
    public static GridPosition indexToGridPosition(int index) {
        if (index < 0 || index >= GRID_SIZE * GRID_SIZE) {
            throw new IllegalArgumentException("Index out of bounds: " + index);
        }
        int x = index % GRID_SIZE;
        int z = index / GRID_SIZE;
        return new GridPosition(x, z);
    }
    /**
     * Convert grid coordinates to world coordinates
     */
    public static WorldPosition gridToWorldPosition(GridPosition grid) {
        // Convert grid coordinates to world coordinates, centered in each cell
        // Add 50,000 block offset to keep away from world border
        int worldX = (grid.x() - (GRID_SIZE / 2)) * GRID_SPACING + 50_000;
        int worldZ = (grid.z() - (GRID_SIZE / 2)) * GRID_SPACING + 50_000;
        return new WorldPosition(worldX, 64, worldZ); // Y=64 is base height
    }
    public record GridPosition(int x, int z) {}
    public record WorldPosition(int x, int y, int z) {}
}
</file>

<file path="main/java/ninja/trek/pocketportals/dimension/PocketDimensionJsonProvider.java">
package ninja.trek.pocketportals.dimension;
import com.google.gson.JsonObject;
import net.fabricmc.fabric.api.datagen.v1.FabricDataOutput;
import net.minecraft.data.DataProvider;
import net.minecraft.data.DataWriter;
import net.minecraft.util.Identifier;
import ninja.trek.pocketportals.PocketPortals;
import java.util.concurrent.CompletableFuture;
public class PocketDimensionJsonProvider implements DataProvider {
    private final FabricDataOutput output;
    private static final long DIMENSION_SEED = 12345678L;
    public PocketDimensionJsonProvider(FabricDataOutput output) {
        this.output = output;
    }
    @Override
    public CompletableFuture<?> run(DataWriter writer) {
        // Generate both files concurrently
        return CompletableFuture.allOf(
                generateDimensionType(writer),
                generateDimension(writer)
        );
    }
    private CompletableFuture<?> generateDimensionType(DataWriter writer) {
        JsonObject typeJson = new JsonObject();
        // Configure dimension type properties
        typeJson.addProperty("ultrawarm", false);
        typeJson.addProperty("natural", true);
        typeJson.addProperty("coordinate_scale", 1.0);
        typeJson.addProperty("has_skylight", true);
        typeJson.addProperty("has_ceiling", false);
        typeJson.addProperty("ambient_light", 0.0);
        typeJson.addProperty("fixed_time", 6000L);
        typeJson.addProperty("piglin_safe", false);
        typeJson.addProperty("bed_works", true);
        typeJson.addProperty("respawn_anchor_works", false);
        typeJson.addProperty("has_raids", false);
        typeJson.addProperty("logical_height", 384);
        typeJson.addProperty("min_y", -64);
        typeJson.addProperty("height", 384);
        typeJson.addProperty("infiniburn", "#minecraft:infiniburn_overworld");
        typeJson.addProperty("effects", "minecraft:overworld");
        typeJson.addProperty("monster_spawn_light_level", 0);
        typeJson.addProperty("monster_spawn_block_light_limit", 0);
        return DataProvider.writeToPath(
                writer,
                typeJson,
                output.getPath()
                        .resolve("data")
                        .resolve(PocketPortals.MOD_ID)
                        .resolve("dimension_type")
                        .resolve("pocket_dimension_type.json")
        );
    }
    private CompletableFuture<?> generateDimension(DataWriter writer) {
        JsonObject dimensionJson = new JsonObject();
        // Set dimension type reference
        dimensionJson.addProperty("type", PocketPortals.MOD_ID + ":pocket_dimension_type");
        // Configure generator
        JsonObject generator = new JsonObject();
        generator.addProperty("type", PocketPortals.MOD_ID + ":sky_island");
        generator.addProperty("seed", DIMENSION_SEED);
        generator.addProperty("settings", "minecraft:overworld");
        // Configure biome source
        JsonObject biomeSource = new JsonObject();
        biomeSource.addProperty("type", PocketPortals.MOD_ID + ":grid_biome_source");
        biomeSource.addProperty("seed", DIMENSION_SEED);
        // Add biome source to generator
        generator.add("biome_source", biomeSource);
        // Add generator to dimension
        dimensionJson.add("generator", generator);
        return DataProvider.writeToPath(
                writer,
                dimensionJson,
                output.getPath()
                        .resolve("data")
                        .resolve(PocketPortals.MOD_ID)
                        .resolve("dimension")
                        .resolve("pocket_dimension.json")
        );
    }
    @Override
    public String getName() {
        return "Pocket Dimension Configurations";
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/dimension/PocketDimensionsRegistry.java">
package ninja.trek.pocketportals.dimension;
import net.fabricmc.fabric.api.event.lifecycle.v1.ServerLifecycleEvents;
import net.minecraft.entity.EntityType;
import net.minecraft.nbt.NbtCompound;
import net.minecraft.nbt.NbtList;
import net.minecraft.registry.RegistryKey;
import net.minecraft.registry.RegistryKeys;
import net.minecraft.registry.RegistryWrapper;
import net.minecraft.server.MinecraftServer;
import net.minecraft.util.Identifier;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.PersistentState;
import net.minecraft.world.World;
import ninja.trek.pocketportals.PocketPortals;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;
import java.util.List;
import java.util.Arrays;
public class PocketDimensionsRegistry extends PersistentState {
    private static final String NEXT_INDEX_KEY = "NextPortalIndex";
    private static final String SPAWN_RULES_KEY = "SpawnRules";
    private static int nextAvailableIndex = 0;
    private final Map<Integer, GridSpawnRules> spawnRules = new HashMap<>();
    // List of common hostile mobs that we'll manage spawn rules for
    public static final List<EntityType<?>> MANAGED_MOBS = Arrays.asList(
            EntityType.ZOMBIE,
            EntityType.SKELETON,
            EntityType.SPIDER,
            EntityType.CREEPER,
            EntityType.ENDERMAN,
            EntityType.WITCH,
            EntityType.PHANTOM,
            EntityType.SLIME
    );
    public static GridSpawnRules getSpawnRules(MinecraftServer server, int index) {
        PocketDimensionsRegistry state = getState(server);
        if (state == null) return null;
        // Get or create rules for this index
        GridSpawnRules rules = state.spawnRules.get(index);
        if (rules == null) {
            rules = new GridSpawnRules(index);
            setRandomSpawnRules(rules);
            state.spawnRules.put(index, rules);
            state.markDirty();
        }
        return rules;
    }
    private static final Type<PocketDimensionsRegistry> TYPE = new Type<>(
            PocketDimensionsRegistry::new,
            (nbt, lookup) -> createFromNbt(nbt, lookup),
            null
    );
    private static final RegistryKey<World> DIMENSION_KEY = RegistryKey.of(
            RegistryKeys.WORLD,
            Identifier.of(PocketPortals.MOD_ID, "pocket_dimension")
    );
    public PocketDimensionsRegistry() {
        super();
    }
    @Override
    public NbtCompound writeNbt(NbtCompound nbt, RegistryWrapper.WrapperLookup registryLookup) {
        nbt.putInt(NEXT_INDEX_KEY, nextAvailableIndex);
        NbtList rulesNbt = new NbtList();
        spawnRules.values().forEach(rules -> {
            rulesNbt.add(rules.writeNbt());
        });
        nbt.put(SPAWN_RULES_KEY, rulesNbt);
        return nbt;
    }
    public static PocketDimensionsRegistry createFromNbt(NbtCompound nbt, RegistryWrapper.WrapperLookup lookup) {
        PocketDimensionsRegistry state = new PocketDimensionsRegistry();
        nextAvailableIndex = nbt.getInt(NEXT_INDEX_KEY);
        if (nbt.contains(SPAWN_RULES_KEY)) {
            NbtList rulesNbt = nbt.getList(SPAWN_RULES_KEY, 10);
            rulesNbt.forEach(element -> {
                GridSpawnRules rules = GridSpawnRules.fromNbt((NbtCompound) element);
                state.spawnRules.put(rules.getGridIndex(), rules);
            });
        }
        return state;
    }
    private static PocketDimensionsRegistry getState(MinecraftServer server) {
        if (server.getOverworld() == null) {
            PocketPortals.LOGGER.warn("Tried to access persistent state before overworld was loaded!");
            return null;
        }
        return server.getOverworld().getPersistentStateManager()
                .getOrCreate(TYPE, PocketPortals.MOD_ID + "_registry");
    }
    private static void setRandomSpawnRules(GridSpawnRules rules) {
        Random random = new Random();
        int randomType = random.nextInt(4); // 0-3
        if (randomType == 0) {
            // 25% chance: Fully peaceful
            PocketPortals.LOGGER.info("Creating peaceful dimension space");
            MANAGED_MOBS.forEach(mob -> rules.setSpawnRule(mob, false));
        }
        else if (randomType == 1) {
            // 25% chance: Fully hostile
            PocketPortals.LOGGER.info("Creating hostile dimension space");
            MANAGED_MOBS.forEach(mob -> rules.setSpawnRule(mob, true));
        }
        else {
            // 50% chance: Random for each mob
            PocketPortals.LOGGER.info("Creating mixed dimension space");
            MANAGED_MOBS.forEach(mob -> {
                boolean allowed = random.nextBoolean();
                rules.setSpawnRule(mob, allowed);
                PocketPortals.LOGGER.debug("Set spawn rule for {}: {}", mob, allowed);
            });
        }
    }
    public static synchronized int findUnusedSlot(MinecraftServer server) {
        PocketDimensionsRegistry state = getState(server);
        if (state == null) {
            int index = nextAvailableIndex;
            nextAvailableIndex = (nextAvailableIndex + 1) % (ModDimensions.GRID_SIZE * ModDimensions.GRID_SIZE);
            return index;
        }
        int nextIndex = nextAvailableIndex;
        nextAvailableIndex = (nextAvailableIndex + 1) % (ModDimensions.GRID_SIZE * ModDimensions.GRID_SIZE);
        // Create new GridSpawnRules with random configuration
        GridSpawnRules rules = new GridSpawnRules(nextIndex);
        setRandomSpawnRules(rules);
        state.spawnRules.put(nextIndex, rules);
        state.markDirty();
        return nextIndex;
    }
    public static void init() {
        ServerLifecycleEvents.SERVER_STARTED.register(server -> {
            getState(server);
        });
    }
    public static RegistryKey<World> getDimensionKey() {
        return DIMENSION_KEY;
    }
    public static boolean canMobSpawn(MinecraftServer server, BlockPos pos, EntityType<?> entityType) {
        PocketDimensionsRegistry state = getState(server);
        if (state == null) return true;
        int gridX = Math.floorDiv(pos.getX(), ModDimensions.GRID_SPACING);
        int gridZ = Math.floorDiv(pos.getZ(), ModDimensions.GRID_SPACING);
        int index = gridX + (gridZ * ModDimensions.GRID_SIZE);
        GridSpawnRules rules = state.spawnRules.get(index);
        if (rules == null) {
            rules = new GridSpawnRules(index);
            setRandomSpawnRules(rules);
            state.spawnRules.put(index, rules);
            state.markDirty();
        }
        return rules.canSpawn(entityType);
    }
    public static void setMobSpawnRule(MinecraftServer server, int gridIndex,
                                       EntityType<?> entityType, boolean allowed) {
        PocketDimensionsRegistry state = getState(server);
        if (state == null) return;
        GridSpawnRules rules = state.spawnRules.computeIfAbsent(gridIndex,
                GridSpawnRules::new);
        rules.setSpawnRule(entityType, allowed);
        state.markDirty();
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/dimension/SkyIslandChunkGenerator.java">
package ninja.trek.pocketportals.dimension;
import com.mojang.serialization.Codec;
import com.mojang.serialization.MapCodec;
import com.mojang.serialization.codecs.RecordCodecBuilder;
import net.minecraft.block.BlockState;
import net.minecraft.block.Blocks;
import net.minecraft.registry.entry.RegistryEntry;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.ChunkRegion;
import net.minecraft.world.HeightLimitView;
import net.minecraft.world.Heightmap;
import net.minecraft.world.biome.Biome;
import net.minecraft.world.biome.source.BiomeAccess;
import net.minecraft.world.biome.source.BiomeSource;
import net.minecraft.world.chunk.Chunk;
import net.minecraft.world.gen.GenerationStep;
import net.minecraft.world.gen.StructureAccessor;
import net.minecraft.world.gen.chunk.Blender;
import net.minecraft.world.gen.chunk.ChunkGenerator;
import net.minecraft.world.gen.chunk.ChunkGeneratorSettings;
import net.minecraft.world.gen.chunk.NoiseChunkGenerator;
import net.minecraft.world.gen.chunk.VerticalBlockSample;
import net.minecraft.world.gen.noise.NoiseConfig;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executor;
public class SkyIslandChunkGenerator extends ChunkGenerator {
    public static final MapCodec<SkyIslandChunkGenerator> CODEC = RecordCodecBuilder.mapCodec(instance ->
            instance.group(
                    BiomeSource.CODEC.fieldOf("biome_source").forGetter(ChunkGenerator::getBiomeSource),
                    ChunkGeneratorSettings.REGISTRY_CODEC.fieldOf("settings").forGetter(generator -> generator.settings)
            ).apply(instance, SkyIslandChunkGenerator::new));
    private static final int BASE_HEIGHT = 64;
    private static final int ISLAND_RADIUS = 50;
    private static final double NOISE_SCALE = 0.05;
    private final RegistryEntry<ChunkGeneratorSettings> settings;
    private final NoiseChunkGenerator vanillaGenerator;
    public SkyIslandChunkGenerator(BiomeSource biomeSource, RegistryEntry<ChunkGeneratorSettings> settings) {
        super(biomeSource);
        this.settings = settings;
        this.vanillaGenerator = new NoiseChunkGenerator(biomeSource, settings);
    }
    @Override
    protected MapCodec<? extends ChunkGenerator> getCodec() {
        return CODEC;
    }
    private boolean isInIslandRange(int worldX, int worldZ) {
        // Convert to grid coordinates
        int gridX = Math.floorDiv(worldX, ModDimensions.GRID_SPACING);
        int gridZ = Math.floorDiv(worldZ, ModDimensions.GRID_SPACING);
        // Get center of current grid cell
        int centerX = (gridX * ModDimensions.GRID_SPACING) + (ModDimensions.GRID_SPACING / 2);
        int centerZ = (gridZ * ModDimensions.GRID_SPACING) + (ModDimensions.GRID_SPACING / 2);
        // Calculate distance from center
        double dx = worldX - centerX;
        double dz = worldZ - centerZ;
        double distanceSquared = dx * dx + dz * dz;
        return distanceSquared <= ISLAND_RADIUS * ISLAND_RADIUS;
    }
    private double getIslandNoise(int x, int z) {
        // Convert to grid coordinates
        int gridX = Math.floorDiv(x, ModDimensions.GRID_SPACING);
        int gridZ = Math.floorDiv(z, ModDimensions.GRID_SPACING);
        // Get center of current grid cell
        int centerX = (gridX * ModDimensions.GRID_SPACING) + (ModDimensions.GRID_SPACING / 2);
        int centerZ = (gridZ * ModDimensions.GRID_SPACING) + (ModDimensions.GRID_SPACING / 2);
        // Calculate normalized distance from center (0.0 to 1.0)
        double dx = x - centerX;
        double dz = z - centerZ;
        double distance = Math.sqrt(dx * dx + dz * dz);
        double normalizedDist = Math.min(1.0, distance / ISLAND_RADIUS);
        // Create smooth falloff from center
        double falloff = 1.0 - (normalizedDist * normalizedDist); // Quadratic falloff
        // Add some variation using sine waves
        double variation = Math.sin(x * NOISE_SCALE) * Math.cos(z * NOISE_SCALE) * 0.2;
        return Math.max(0.0, falloff + variation);
    }
    @Override
    public CompletableFuture<Chunk> populateNoise(Blender blender, NoiseConfig noiseConfig, StructureAccessor structureAccessor, Chunk chunk) {
        // First, let vanilla handle base generation
        return vanillaGenerator.populateNoise(blender, noiseConfig, structureAccessor, chunk).thenApply(populatedChunk -> {
            // Then modify it to create our island shape
            int chunkX = chunk.getPos().x * 16;
            int chunkZ = chunk.getPos().z * 16;
            BlockPos.Mutable mutable = new BlockPos.Mutable();
            for (int x = 0; x < 16; x++) {
                for (int z = 0; z < 16; z++) {
                    int worldX = chunkX + x;
                    int worldZ = chunkZ + z;
                    if (!isInIslandRange(worldX, worldZ)) {
                        // Outside island range - clear all blocks
                        for (int y = chunk.getBottomY(); y < chunk.getTopYInclusive(); y++) {
                            mutable.set(x, y, z);
                            chunk.setBlockState(mutable, Blocks.AIR.getDefaultState(), false);
                        }
                    } else {
                        // Inside island range - apply noise modification
                        double islandFactor = getIslandNoise(worldX, worldZ);
                        int currentHeight = chunk.getHeightmap(Heightmap.Type.WORLD_SURFACE).get(x, z);
                        int targetHeight = (int)(BASE_HEIGHT + (islandFactor * 30)); // 30 blocks of max variation
                        // Adjust terrain height
                        if (currentHeight > targetHeight) {
                            // Remove blocks above target height
                            for (int y = targetHeight + 1; y <= currentHeight; y++) {
                                mutable.set(x, y, z);
                                chunk.setBlockState(mutable, Blocks.AIR.getDefaultState(), false);
                            }
                        }
                    }
                }
            }
            return populatedChunk;
        });
    }
    @Override
    public void carve(ChunkRegion chunkRegion, long seed, NoiseConfig noiseConfig, BiomeAccess biomeAccess, StructureAccessor structureAccessor, Chunk chunk) {
// Delegate to vanilla for carving
        vanillaGenerator.carve(chunkRegion, seed, noiseConfig, biomeAccess, structureAccessor, chunk);
    }
    @Override
    public void buildSurface(ChunkRegion region, StructureAccessor structures, NoiseConfig noiseConfig, Chunk chunk) {
        // Delegate to vanilla for surface building
        vanillaGenerator.buildSurface(region, structures, noiseConfig, chunk);
    }
    @Override
    public void populateEntities(ChunkRegion region) {
    }
    @Override
    public int getHeight(int x, int z, Heightmap.Type heightmap, HeightLimitView world, NoiseConfig noiseConfig) {
        if (!isInIslandRange(x, z)) {
            return world.getBottomY();
        }
        return vanillaGenerator.getHeight(x, z, heightmap, world, noiseConfig);
    }
    @Override
    public VerticalBlockSample getColumnSample(int x, int z, HeightLimitView world, NoiseConfig noiseConfig) {
        return vanillaGenerator.getColumnSample(x, z, world, noiseConfig);
    }
    @Override
    public void appendDebugHudText(List<String> text, NoiseConfig noiseConfig, BlockPos pos) {
    }
    @Override
    public int getWorldHeight() {
        return vanillaGenerator.getWorldHeight();
    }
    @Override
    public int getSeaLevel() {
        return -64; // No sea in sky islands
    }
    @Override
    public int getMinimumY() {
        return vanillaGenerator.getMinimumY();
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/item/ModItems.java">
package ninja.trek.pocketportals.item;
import net.minecraft.item.Item;
import net.minecraft.registry.Registries;
import net.minecraft.registry.Registry;
import net.minecraft.registry.RegistryKey;
import net.minecraft.registry.RegistryKeys;
import net.minecraft.util.Identifier;
import ninja.trek.pocketportals.PocketPortals;
public class ModItems {
    // Define the registry key
    private static final RegistryKey<Item> POCKET_PORTAL_KEY = RegistryKey.of(
            RegistryKeys.ITEM,
            Identifier.of(PocketPortals.MOD_ID, "pocket_portal")
    );
    // Register a custom PocketPortalItem so we can store dimension index in its NBT
    public static final PocketPortalItem POCKET_PORTAL_ITEM;
    static {
        // Create settings with registry key
        Item.Settings settings = new Item.Settings()
                .maxCount(1) // non-stackable
                .useBlockPrefixedTranslationKey() // Use block.namespace.path format for translation
                .registryKey(POCKET_PORTAL_KEY);
        POCKET_PORTAL_ITEM = new PocketPortalItem(settings);
    }
    public static void registerItems() {
        // Register the item using the same key used in settings
        Registry.register(Registries.ITEM, POCKET_PORTAL_KEY, POCKET_PORTAL_ITEM);
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/item/PocketPortalItem.java">
package ninja.trek.pocketportals.item;
import net.minecraft.item.BlockItem;
import net.minecraft.item.ItemStack;
import net.minecraft.item.tooltip.TooltipType;
import net.minecraft.text.Text;
import net.minecraft.util.Formatting;
import net.minecraft.world.World;
import ninja.trek.pocketportals.block.ModBlocks;
import org.jetbrains.annotations.Nullable;
import java.util.List;
import static ninja.trek.pocketportals.data.PocketPortalDataTypes.DIMENSION_INDEX;
/**
 * Custom PocketPortalItem that reads the dimension index from
 * Fabric Data Components for its tooltip (instead of raw NBT).
 */
public class PocketPortalItem extends BlockItem {
    public PocketPortalItem(Settings settings) {
        super(ModBlocks.POCKET_PORTAL, validateSettings(settings));
    }
    private static Settings validateSettings(Settings settings) {
        if (settings == null) {
            throw new IllegalArgumentException("Settings cannot be null");
        }
        return settings;
    }
    @Override
    public void appendTooltip(
            ItemStack stack,
            TooltipContext context,
            List<Text> tooltip,
            TooltipType type
    ) {
        // 1) Let the parent BlockItem do any default work
        super.appendTooltip(stack, context, tooltip, type);
        // 2) Fetch our dimension index from Fabric Data Components
        Integer index = stack.get(DIMENSION_INDEX); // If none set, returns null
        // 3) Show a line of text based on that index
        if (index != null) {
            tooltip.add(Text.literal("Bound to dimension index: " + index)
                    .formatted(Formatting.GRAY));
        } else {
            tooltip.add(Text.literal("Unlinked").formatted(Formatting.DARK_GRAY));
        }
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/mixin/ExampleMixin.java">
package ninja.trek.pocketportals.mixin;
import net.minecraft.server.MinecraftServer;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(MinecraftServer.class)
public class ExampleMixin {
	@Inject(at = @At("HEAD"), method = "loadWorld")
	private void init(CallbackInfo info) {
		// This code is injected into the start of MinecraftServer.loadWorld()V
	}
}
</file>

<file path="main/java/ninja/trek/pocketportals/mixin/SpawnHelperMixin.java">
package ninja.trek.pocketportals.mixin;
import net.minecraft.entity.EntityType;
import net.minecraft.entity.SpawnGroup;
import net.minecraft.server.world.ServerWorld;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.SpawnHelper;
import net.minecraft.world.biome.SpawnSettings;
import net.minecraft.world.gen.StructureAccessor;
import net.minecraft.world.gen.chunk.ChunkGenerator;
import ninja.trek.pocketportals.dimension.PocketDimensionsRegistry;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;
@Mixin(SpawnHelper.class)
public class SpawnHelperMixin {
    @Inject(
            method = "canSpawn(Lnet/minecraft/server/world/ServerWorld;Lnet/minecraft/entity/SpawnGroup;Lnet/minecraft/world/gen/StructureAccessor;Lnet/minecraft/world/gen/chunk/ChunkGenerator;Lnet/minecraft/world/biome/SpawnSettings$SpawnEntry;Lnet/minecraft/util/math/BlockPos$Mutable;D)Z",
            at = @At("RETURN"),
            cancellable = true
    )
    private static void onCanSpawn(
            ServerWorld world,
            SpawnGroup group,
            StructureAccessor structureAccessor,
            ChunkGenerator chunkGenerator,
            SpawnSettings.SpawnEntry spawnEntry,
            BlockPos.Mutable pos,
            double squaredDistance,
            CallbackInfoReturnable<Boolean> cir
    ) {
        // Only proceed if vanilla spawn checks passed
        if (!cir.getReturnValue()) {
            return;
        }
        // Only apply our rules in the pocket dimension
        if (!world.getRegistryKey().equals(PocketDimensionsRegistry.getDimensionKey())) {
            return;
        }
        // Get the entity type from the spawn entry
        EntityType<?> entityType = spawnEntry.type;
        // Check if spawning is allowed in this grid space
        if (!PocketDimensionsRegistry.canMobSpawn(world.getServer(), pos, entityType)) {
            cir.setReturnValue(false);
        }
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/network/SpawnRulesPacket.java">
package ninja.trek.pocketportals.network;
import net.minecraft.entity.EntityType;
import net.minecraft.network.RegistryByteBuf;
import net.minecraft.network.packet.CustomPayload;
import net.minecraft.network.codec.PacketCodec;
import net.minecraft.registry.Registries;
import net.minecraft.util.Identifier;
import ninja.trek.pocketportals.PocketPortals;
import java.util.HashMap;
import java.util.Map;
public record SpawnRulesPacket(int dimensionIndex, Map<EntityType<?>, Boolean> rules)
        implements CustomPayload {
    public static final Id<SpawnRulesPacket> ID =
            new Id<>(Identifier.of(PocketPortals.MOD_ID, "spawn_rules_sync"));
    public static final PacketCodec<RegistryByteBuf, SpawnRulesPacket> CODEC =
            PacketCodec.of(SpawnRulesPacket::write, SpawnRulesPacket::new);
    // Constructor for decoding
    public SpawnRulesPacket(RegistryByteBuf buf) {
        this(buf.readVarInt(), readRules(buf));
    }
    // Write method for encoding
    public void write(RegistryByteBuf buf) {
        buf.writeVarInt(dimensionIndex);
        buf.writeVarInt(rules.size());
        rules.forEach((entityType, allowed) -> {
            buf.writeIdentifier(Registries.ENTITY_TYPE.getId(entityType));
            buf.writeBoolean(allowed);
        });
    }
    // Helper method to read rules map
    private static Map<EntityType<?>, Boolean> readRules(RegistryByteBuf buf) {
        int size = buf.readVarInt();
        Map<EntityType<?>, Boolean> rules = new HashMap<>();
        for (int i = 0; i < size; i++) {
            EntityType<?> entityType = Registries.ENTITY_TYPE.get(buf.readIdentifier());
            boolean allowed = buf.readBoolean();
            rules.put(entityType, allowed);
        }
        return rules;
    }
    @Override
    public Id<?> getId() {
        return ID;
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/PocketPortals.java">
package ninja.trek.pocketportals;
import net.fabricmc.api.ModInitializer;
import net.fabricmc.fabric.api.event.lifecycle.v1.ServerLifecycleEvents;
import net.fabricmc.fabric.api.networking.v1.ServerPlayNetworking;
import net.minecraft.registry.Registry;
import net.minecraft.registry.RegistryKeys;
import net.minecraft.server.MinecraftServer;
import ninja.trek.pocketportals.block.ModBlocks;
import ninja.trek.pocketportals.data.DataLoader;
import ninja.trek.pocketportals.dimension.ModDimensions;
import ninja.trek.pocketportals.dimension.PocketDimensionsRegistry;
import ninja.trek.pocketportals.item.ModItems;
import ninja.trek.pocketportals.network.SpawnRulesPacket;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class PocketPortals implements ModInitializer {
	public static final String MOD_ID = "pocketportals";
	public static final Logger LOGGER = LoggerFactory.getLogger(MOD_ID);
	private static MinecraftServer server;
	public static MinecraftServer getServer() {
		return server;
	}
	public static void setServer(MinecraftServer server) {
		PocketPortals.server = server;
	}
	@Override
	public void onInitialize() {
		// Add server lifecycle event
		ServerLifecycleEvents.SERVER_STARTING.register(server -> {
			PocketPortals.setServer(server);
		});
		ServerLifecycleEvents.SERVER_STOPPED.register(server -> {
			PocketPortals.setServer(null);
		});
		// First register blocks to ensure IDs are set
		if (System.getProperty("fabric.datagen") == null) {
			LOGGER.info("Registering blocks...");
			ModBlocks.registerBlocks();
		}
		// Then register items that might depend on blocks
		LOGGER.info("Registering items...");
		ModItems.registerItems();
		// Then register dimensions and related systems
		LOGGER.info("Registering dimensions...");
		ModDimensions.register();
		PocketDimensionsRegistry.init();
		// Register network packets
		LOGGER.info("Registering network packets...");
		// Register server-side receiver
//		ServerPlayNetworking.registerGlobalReceiver(SpawnRulesPacket.ID, (packet, context) -> {
//			// Handle the packet on the server side if needed
//			LOGGER.debug("Received spawn rules packet for dimension {}", packet.dimensionIndex());
//		});
		// Finally register data loaders
		LOGGER.info("Registering data loaders...");
		DataLoader.register();
		LOGGER.info("Pocket Portals mod initialized!");
	}
}
</file>

<file path="main/java/ninja/trek/pocketportals/SpawnRulesData.java">
package ninja.trek.pocketportals;
import net.minecraft.entity.EntityType;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
public class SpawnRulesData {
    // Use ConcurrentHashMap for thread safety when accessing from different threads
    private static final Map<Integer, Map<EntityType<?>, Boolean>> dimensionSpawnRules =
            new ConcurrentHashMap<>();
    public static void setSpawnRules(int dimensionIndex, Map<EntityType<?>, Boolean> rules) {
        dimensionSpawnRules.put(dimensionIndex, new HashMap<>(rules));
    }
    public static Map<EntityType<?>, Boolean> getSpawnRules(int dimensionIndex) {
        return dimensionSpawnRules.getOrDefault(dimensionIndex, new HashMap<>());
    }
    public static void clearAllRules() {
        dimensionSpawnRules.clear();
    }
    // Private constructor to prevent instantiation
    private SpawnRulesData() {}
}
</file>

<file path="main/resources/fabric.mod.json">
{
	"schemaVersion": 1,
	"id": "pocketportals",
	"version": "${version}",
	"name": "PocketPortals",
	"description": "This is an example description! Tell everyone what your mod is about!",
	"authors": [
		"Me!"
	],
	"contact": {
		"homepage": "https://fabricmc.net/",
		"sources": "https://github.com/FabricMC/fabric-example-mod"
	},
	"license": "CC0-1.0",
	"icon": "assets/pocketportals/icon.png",
	"environment": "*",
	"entrypoints": {
		"main": [
			"ninja.trek.pocketportals.PocketPortals"
		],
		"client": [
			"ninja.trek.pocketportals.PocketPortalsClient"
		],
		"fabric-datagen": [
			"ninja.trek.pocketportals.PocketPortalsDataGenerator"
		]
	},
	"mixins": [
		"pocketportals.mixins.json",
		{
			"config": "pocketportals.client.mixins.json",
			"environment": "client"
		}
	],
	"depends": {
		"fabricloader": ">=0.16.10",
		"minecraft": "~1.21.4",
		"java": ">=21",
		"fabric-api": "*"
	},
	"suggests": {
		"another-mod": "*"
	}
}
</file>

<file path="main/resources/pocket-portals.mixins.json">
{
	"required": true,
	"package": "ninja.trek.pocketportals.mixin",
	"compatibilityLevel": "JAVA_21",
	"mixins": [
		"ExampleMixin",
		"SpawnHelperMixin"
	],
	"injectors": {
		"defaultRequire": 1
	}
}
</file>

<file path="main/resources/pocketportals.mixins.json">
{
	"required": true,
	"package": "ninja.trek.pocketportals.mixin",
	"compatibilityLevel": "JAVA_21",
	"mixins": [
		"ExampleMixin"
	],
	"injectors": {
		"defaultRequire": 1
	}
}
</file>

<file path="repomixx.bat">
repomix --style xml --remove-empty-lines --copy --ignore "**/generated/**"
</file>

</files>
