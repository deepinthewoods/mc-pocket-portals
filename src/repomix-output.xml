This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-02T14:23:14.396Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
client/java/ninja/trek/pocketportals/mixin/client/ExampleClientMixin.java
client/java/ninja/trek/pocketportals/PocketPortalsClient.java
client/java/ninja/trek/pocketportals/PocketPortalsDataGenerator.java
client/resources/pocket-portals.client.mixins.json
main/java/ninja/trek/pocketportals/block/ModBlocks.java
main/java/ninja/trek/pocketportals/block/PocketPortalBlock.java
main/java/ninja/trek/pocketportals/block/PocketPortalBlockEntity.java
main/java/ninja/trek/pocketportals/block/PocketPortalFrame.java
main/java/ninja/trek/pocketportals/data/DataLoader.java
main/java/ninja/trek/pocketportals/dimension/ModDimensions.java
main/java/ninja/trek/pocketportals/dimension/PocketDimensionChunkGenerator.java
main/java/ninja/trek/pocketportals/item/ModItems.java
main/java/ninja/trek/pocketportals/mixin/ExampleMixin.java
main/java/ninja/trek/pocketportals/PocketPortals.java
main/resources/assets/pocket-portals/blockstates/pocket_portal_frame.json
main/resources/assets/pocket-portals/blockstates/pocket_portal.json
main/resources/assets/pocket-portals/models/block/pocket_portal_frame.json
main/resources/assets/pocket-portals/models/block/pocket_portal.json
main/resources/assets/pocket-portals/models/item/pocket_portal.json
main/resources/data/pocket-portals/dimension_type/pocket_dimension_type.json
main/resources/data/pocket-portals/dimension/pocket_dimension.json
main/resources/data/pocket-portals/loot_tables/blocks/pocket_portal.json
main/resources/fabric.mod.json
main/resources/pocket-portals.mixins.json
repomixx.bat
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="client/java/ninja/trek/pocketportals/mixin/client/ExampleClientMixin.java">
package ninja.trek.pocketportals.mixin.client;
import net.minecraft.client.MinecraftClient;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(MinecraftClient.class)
public class ExampleClientMixin {
	@Inject(at = @At("HEAD"), method = "run")
	private void init(CallbackInfo info) {
		// This code is injected into the start of MinecraftClient.run()V
	}
}
</file>

<file path="client/java/ninja/trek/pocketportals/PocketPortalsClient.java">
package ninja.trek.pocketportals;
import net.fabricmc.api.ClientModInitializer;
public class PocketPortalsClient implements ClientModInitializer {
	@Override
	public void onInitializeClient() {
		// This entrypoint is suitable for setting up client-specific logic, such as rendering.
	}
}
</file>

<file path="client/java/ninja/trek/pocketportals/PocketPortalsDataGenerator.java">
package ninja.trek.pocketportals;
import net.fabricmc.fabric.api.datagen.v1.DataGeneratorEntrypoint;
import net.fabricmc.fabric.api.datagen.v1.FabricDataGenerator;
public class PocketPortalsDataGenerator implements DataGeneratorEntrypoint {
	@Override
	public void onInitializeDataGenerator(FabricDataGenerator fabricDataGenerator) {
	}
}
</file>

<file path="client/resources/pocket-portals.client.mixins.json">
{
	"required": true,
	"package": "ninja.trek.pocketportals.mixin.client",
	"compatibilityLevel": "JAVA_21",
	"client": [
		"ExampleClientMixin"
	],
	"injectors": {
		"defaultRequire": 1
	}
}
</file>

<file path="main/java/ninja/trek/pocketportals/block/ModBlocks.java">
package ninja.trek.pocketportals.block;
import net.fabricmc.fabric.api.object.builder.v1.block.FabricBlockSettings;
import net.fabricmc.fabric.api.object.builder.v1.block.entity.FabricBlockEntityTypeBuilder;
import net.minecraft.block.entity.BlockEntityType;
import net.minecraft.registry.Registries;
import net.minecraft.registry.Registry;
import net.minecraft.util.Identifier;
import ninja.trek.pocketportals.PocketPortals;
public class ModBlocks {
    public static final PocketPortalBlock POCKET_PORTAL = new PocketPortalBlock(
            FabricBlockSettings.create()
                    .strength(3.0f)
                    .requiresTool()
                    .nonOpaque()
    );
    public static final PocketPortalFrame POCKET_PORTAL_FRAME = new PocketPortalFrame(
            FabricBlockSettings.create()
                    .luminance(state -> 11)
                    .noCollision()
                    .strength(-1.0F)
    );
    public static final BlockEntityType<PocketPortalBlockEntity> POCKET_PORTAL_BLOCK_ENTITY =
            FabricBlockEntityTypeBuilder.create(
                    PocketPortalBlockEntity::new,
                    POCKET_PORTAL
            ).build();
    public static void registerBlocks() {
        Registry.register(
                Registries.BLOCK,
                Identifier.of(PocketPortals.MOD_ID, "pocket_portal"),
                POCKET_PORTAL
        );
        Registry.register(
                Registries.BLOCK,
                Identifier.of(PocketPortals.MOD_ID, "pocket_portal_frame"),
                POCKET_PORTAL_FRAME
        );
        Registry.register(
                Registries.BLOCK_ENTITY_TYPE,
                Identifier.of(PocketPortals.MOD_ID, "pocket_portal_entity"),
                POCKET_PORTAL_BLOCK_ENTITY
        );
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/block/PocketPortalBlock.java">
package ninja.trek.pocketportals.block;
import com.mojang.serialization.MapCodec;
import net.minecraft.block.*;
import net.minecraft.block.entity.BlockEntity;
import net.minecraft.entity.Entity;
import net.minecraft.entity.LivingEntity;
import net.minecraft.item.ItemStack;
import net.minecraft.state.StateManager;
import net.minecraft.state.property.DirectionProperty;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.World;
import net.minecraft.block.Blocks;
public class PocketPortalBlock extends BlockWithEntity {
    public static final DirectionProperty FACING = HorizontalFacingBlock.FACING;
    public static final MapCodec<PocketPortalBlock> CODEC = createCodec(PocketPortalBlock::new);
    public PocketPortalBlock(Settings settings) {
        super(Settings.copy(Blocks.STONE)
                .strength(3.0f)
                .requiresTool()
                .nonOpaque());
        setDefaultState(getStateManager().getDefaultState());
    }
    @Override
    public BlockEntity createBlockEntity(BlockPos pos, BlockState state) {
        return new PocketPortalBlockEntity(pos, state);
    }
    @Override
    public void onPlaced(World world, BlockPos pos, BlockState state, LivingEntity placer, ItemStack stack) {
        if (!world.isClient) {
            // Create our custom portal blocks above instead of nether portal
            BlockPos portalPos1 = pos.up();
            BlockPos portalPos2 = portalPos1.up();
            world.setBlockState(portalPos1, ModBlocks.POCKET_PORTAL_FRAME.getDefaultState());
            world.setBlockState(portalPos2, ModBlocks.POCKET_PORTAL_FRAME.getDefaultState());
        }
    }
    @Override
    public void onStateReplaced(BlockState state, World world, BlockPos pos, BlockState newState, boolean moved) {
        if (!state.isOf(newState.getBlock())) {
            // Remove portal blocks when base block is broken
            world.setBlockState(pos.up(), Blocks.AIR.getDefaultState());
            world.setBlockState(pos.up(2), Blocks.AIR.getDefaultState());
        }
        super.onStateReplaced(state, world, pos, newState, moved);
    }
    @Override
    public void onEntityCollision(BlockState state, World world, BlockPos pos, Entity entity) {
        if (!world.isClient) {
            BlockEntity blockEntity = world.getBlockEntity(pos);
            if (blockEntity instanceof PocketPortalBlockEntity portalBlockEntity) {
                portalBlockEntity.handleEntityCollision(entity);
            }
        }
    }
    @Override
    protected void appendProperties(StateManager.Builder<Block, BlockState> builder) {
        builder.add(FACING);
    }
    @Override
    public BlockRenderType getRenderType(BlockState state) {
        return BlockRenderType.MODEL;
    }
    @Override
    protected MapCodec<? extends BlockWithEntity> getCodec() {
        return CODEC;
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/block/PocketPortalBlockEntity.java">
package ninja.trek.pocketportals.block;
import net.minecraft.block.BlockState;
import net.minecraft.block.entity.BlockEntity;
import net.minecraft.entity.Entity;
import net.minecraft.nbt.NbtCompound;
import net.minecraft.network.packet.s2c.play.PositionFlag;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.random.Random;
import net.minecraft.server.world.ServerWorld;
import net.minecraft.registry.RegistryKey;
import net.minecraft.registry.RegistryKeys;
import net.minecraft.registry.RegistryWrapper;
import net.minecraft.util.Identifier;
import net.minecraft.world.World;
import ninja.trek.pocketportals.PocketPortals;
import ninja.trek.pocketportals.dimension.ModDimensions;
import java.util.EnumSet;
public class PocketPortalBlockEntity extends BlockEntity {
    private Long seed;
    private static final String SEED_KEY = "PocketSeed";
    public PocketPortalBlockEntity(BlockPos pos, BlockState state) {
        super(ModBlocks.POCKET_PORTAL_BLOCK_ENTITY, pos, state);
    }
    @Override
    public void readNbt(NbtCompound nbt, RegistryWrapper.WrapperLookup registryLookup) {
        super.readNbt(nbt, registryLookup);
        if (nbt.contains(SEED_KEY)) {
            seed = nbt.getLong(SEED_KEY);
        }
    }
    @Override
    public void writeNbt(NbtCompound nbt, RegistryWrapper.WrapperLookup registryLookup) {
        super.writeNbt(nbt, registryLookup);
        if (seed != null) {
            nbt.putLong(SEED_KEY, seed);
        }
    }
    public void handleEntityCollision(Entity entity) {
        if (!entity.hasVehicle() && !entity.hasPassengers() && entity.canUsePortals(false)) {
            if (!(world instanceof ServerWorld serverWorld)) {
                return;
            }
            // Generate seed on first use if needed
            if (seed == null) {
                seed = Random.create().nextLong();
                markDirty();
            }
            // The dimension key should match our JSON configuration
            RegistryKey<World> pocketDimensionKey = RegistryKey.of(
                    RegistryKeys.WORLD,
                    Identifier.of(PocketPortals.MOD_ID, "pocket_dimension")
            );
            if (world.getRegistryKey() == pocketDimensionKey) {
                // If in pocket dimension, return to overworld at the portal location
                ServerWorld targetWorld = serverWorld.getServer().getOverworld();
                entity.teleport(
                        targetWorld,
                        pos.getX() + 0.5,
                        pos.getY() + 1,
                        pos.getZ() + 0.5,
                        EnumSet.noneOf(PositionFlag.class),
                        entity.getYaw(),
                        entity.getPitch()
                );
            } else {
                // Going to pocket dimension
                ServerWorld pocketWorld = ModDimensions.getOrCreatePocketDimension(
                        serverWorld.getServer(),
                        pocketDimensionKey,
                        seed
                );
                if (pocketWorld != null) {
                    entity.teleport(
                            pocketWorld,
                            0.5,
                            66,
                            0.5,
                            EnumSet.noneOf(PositionFlag.class),
                            entity.getYaw(),
                            entity.getPitch()
                    );
                } else {
                    PocketPortals.LOGGER.error("Failed to access pocket dimension!");
                }
            }
        }
    }
    public Long getSeed() {
        return seed;
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/block/PocketPortalFrame.java">
package ninja.trek.pocketportals.block;
import net.minecraft.block.Block;
import net.minecraft.block.BlockRenderType;
import net.minecraft.block.BlockState;
import net.minecraft.block.Blocks;
import net.minecraft.block.entity.BlockEntity;
import net.minecraft.entity.Entity;
import net.minecraft.particle.ParticleTypes;
import net.minecraft.sound.SoundCategory;
import net.minecraft.sound.SoundEvents;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.random.Random;
import net.minecraft.world.World;
import com.mojang.serialization.MapCodec;
public class PocketPortalFrame extends Block {
    public static final MapCodec<PocketPortalFrame> CODEC = createCodec(PocketPortalFrame::new);
    public PocketPortalFrame(Settings settings) {
        super(Settings.copy(Blocks.NETHER_PORTAL)
                .luminance(state -> 11)
                .noCollision()
                .strength(-1.0F)
        );
    }
    @Override
    public void onEntityCollision(BlockState state, World world, BlockPos pos, Entity entity) {
        if (!world.isClient && entity.canUsePortals(false)) {
            // Find the portal base block
            BlockPos basePos = findPortalBase(world, pos);
            if (basePos != null) {
                BlockEntity blockEntity = world.getBlockEntity(basePos);
                if (blockEntity instanceof PocketPortalBlockEntity portalBlockEntity) {
                    portalBlockEntity.handleEntityCollision(entity);
                }
            }
        }
    }
    private BlockPos findPortalBase(World world, BlockPos startPos) {
        // Search downward for the portal base block
        BlockPos.Mutable currentPos = startPos.mutableCopy();
        for (int y = 0; y > -3; y--) {
            currentPos.move(0, y, 0);
            if (world.getBlockState(currentPos).getBlock() instanceof PocketPortalBlock) {
                return currentPos.toImmutable();
            }
        }
        return null;
    }
    @Override
    public void randomDisplayTick(BlockState state, World world, BlockPos pos, Random random) {
        if (random.nextInt(100) == 0) {
            world.playSound(
                    pos.getX() + 0.5D,
                    pos.getY() + 0.5D,
                    pos.getZ() + 0.5D,
                    SoundEvents.BLOCK_PORTAL_AMBIENT,
                    SoundCategory.BLOCKS,
                    0.5F,
                    random.nextFloat() * 0.4F + 0.8F,
                    false
            );
        }
        for(int i = 0; i < 4; ++i) {
            double x = pos.getX() + random.nextDouble();
            double y = pos.getY() + random.nextDouble();
            double z = pos.getZ() + random.nextDouble();
            double dx = (random.nextDouble() - 0.5D) * 0.5D;
            double dy = (random.nextDouble() - 0.5D) * 0.5D;
            double dz = (random.nextDouble() - 0.5D) * 0.5D;
            world.addParticle(ParticleTypes.PORTAL, x, y, z, dx, dy, dz);
        }
    }
    @Override
    public BlockRenderType getRenderType(BlockState state) {
        return BlockRenderType.MODEL;
    }
    @Override
    protected MapCodec<? extends Block> getCodec() {
        return CODEC;
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/data/DataLoader.java">
package ninja.trek.pocketportals.data;
import net.fabricmc.fabric.api.resource.ResourceManagerHelper;
import net.fabricmc.fabric.api.resource.SimpleSynchronousResourceReloadListener;
import net.minecraft.resource.ResourceManager;
import net.minecraft.resource.ResourceType;
import net.minecraft.util.Identifier;
import ninja.trek.pocketportals.PocketPortals;
public class DataLoader {
    public static void register() {
        ResourceManagerHelper.get(ResourceType.SERVER_DATA).registerReloadListener(
                new SimpleSynchronousResourceReloadListener() {
                    @Override
                    public Identifier getFabricId() {
                        return Identifier.of(PocketPortals.MOD_ID, "dimension_loader");
                    }
                    @Override
                    public void reload(ResourceManager manager) {
                        // Check for dimension type file
                        Identifier dimTypeId = Identifier.of(PocketPortals.MOD_ID, "dimension_type/pocket_dimension_type.json");
                        if (manager.getResource(dimTypeId).isPresent()) {
                            PocketPortals.LOGGER.info("Found pocket dimension type configuration");
                        } else {
                            PocketPortals.LOGGER.error("Missing pocket dimension type configuration at {}", dimTypeId);
                        }
                        // Check for dimension file
                        Identifier dimId = Identifier.of(PocketPortals.MOD_ID, "dimension/pocket_dimension.json");
                        if (manager.getResource(dimId).isPresent()) {
                            PocketPortals.LOGGER.info("Found pocket dimension configuration");
                        } else {
                            PocketPortals.LOGGER.error("Missing pocket dimension configuration at {}", dimId);
                        }
                    }
                }
        );
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/dimension/ModDimensions.java">
package ninja.trek.pocketportals.dimension;
import net.fabricmc.fabric.api.event.lifecycle.v1.ServerLifecycleEvents;
import net.fabricmc.fabric.api.event.lifecycle.v1.ServerTickEvents;
import net.minecraft.registry.Registries;
import net.minecraft.registry.Registry;
import net.minecraft.registry.RegistryKey;
import net.minecraft.registry.RegistryKeys;
import net.minecraft.server.MinecraftServer;
import net.minecraft.server.world.ServerWorld;
import net.minecraft.util.Identifier;
import net.minecraft.world.World;
import net.minecraft.world.dimension.DimensionType;
import ninja.trek.pocketportals.PocketPortals;
import java.util.HashMap;
import java.util.Map;
public class ModDimensions {
    public static final RegistryKey<World> POCKET_DIMENSION_KEY = RegistryKey.of(
            RegistryKeys.WORLD,
            Identifier.of(PocketPortals.MOD_ID, "pocket_dimension")
    );
    public static final RegistryKey<DimensionType> POCKET_DIMENSION_TYPE_KEY = RegistryKey.of(
            RegistryKeys.DIMENSION_TYPE,
            Identifier.of(PocketPortals.MOD_ID, "pocket_dimension_type")
    );
    // Cache for dimension seeds
    private static final Map<Long, ServerWorld> DIMENSION_CACHE = new HashMap<>();
    public static void register() {
        // Register chunk generator
        Registry.register(
                Registries.CHUNK_GENERATOR,
                Identifier.of(PocketPortals.MOD_ID, "pocket_dimension"),
                PocketDimensionChunkGenerator.CODEC
        );
        // Server starting event - initialize dimension systems
        ServerLifecycleEvents.SERVER_STARTING.register(server -> {
            PocketPortals.LOGGER.info("Initializing pocket dimension system");
            initializeDimensionSystem(server);
        });
        // Server started event - verify dimensions
        ServerLifecycleEvents.SERVER_STARTED.register(server -> {
            verifyDimensionAccess(server);
        });
        // Server stopping event - cleanup
        ServerLifecycleEvents.SERVER_STOPPING.register(server -> {
            PocketPortals.LOGGER.info("Cleaning up pocket dimension system");
            DIMENSION_CACHE.clear();
        });
        // Server tick event - handle dimension maintenance
        ServerTickEvents.END_SERVER_TICK.register(server -> {
            maintainDimensions(server);
        });
    }
    private static void initializeDimensionSystem(MinecraftServer server) {
        try {
            // Ensure registry entries are available
            if (!server.getWorldRegistryKeys().contains(POCKET_DIMENSION_KEY)) {
                PocketPortals.LOGGER.warn("Pocket dimension registry entry not found - this is expected on first load");
            }
        } catch (Exception e) {
            PocketPortals.LOGGER.error("Failed to initialize dimension system", e);
        }
    }
    private static void verifyDimensionAccess(MinecraftServer server) {
        try {
            // Check if we can access the dimension type
            if (server.getRegistryManager().get(RegistryKeys.DIMENSION_TYPE).containsId(POCKET_DIMENSION_TYPE_KEY.getValue())) {
                PocketPortals.LOGGER.info("Pocket dimension type verified");
            } else {
                PocketPortals.LOGGER.warn("Pocket dimension type not found - check JSON configs");
            }
            // Try to access the dimension
            ServerWorld pocketWorld = server.getWorld(POCKET_DIMENSION_KEY);
            if (pocketWorld != null) {
                PocketPortals.LOGGER.info("Successfully verified pocket dimension access");
            } else {
                PocketPortals.LOGGER.warn("Pocket dimension not immediately available - this may be normal");
            }
        } catch (Exception e) {
            PocketPortals.LOGGER.error("Error during dimension verification", e);
        }
    }
    private static void maintainDimensions(MinecraftServer server) {
        // Clean up any stale dimension references
        DIMENSION_CACHE.entrySet().removeIf(entry ->
                !server.getWorldRegistryKeys().contains(POCKET_DIMENSION_KEY));
    }
    public static ServerWorld getOrCreatePocketDimension(MinecraftServer server, RegistryKey<World> key, long seed) {
        try {
            // First check the cache
            ServerWorld cachedWorld = DIMENSION_CACHE.get(seed);
            if (cachedWorld != null && cachedWorld.isClient()) {
                return cachedWorld;
            }
            // Then check if the dimension exists on the server
            ServerWorld existingWorld = server.getWorld(key);
            if (existingWorld != null) {
                DIMENSION_CACHE.put(seed, existingWorld);
                PocketPortals.LOGGER.info("Successfully accessed pocket dimension with seed: {}", seed);
                return existingWorld;
            }
            // Log detailed debug info
            PocketPortals.LOGGER.debug("Attempting to access dimension - Key: {}", key.getValue());
            PocketPortals.LOGGER.debug("Available dimensions: {}", server.getWorldRegistryKeys());
            PocketPortals.LOGGER.debug("Current seed: {}", seed);
            // Try one more time after logging
            ServerWorld world = server.getWorld(key);
            if (world != null) {
                DIMENSION_CACHE.put(seed, world);
            }
            return world;
        } catch (Exception e) {
            PocketPortals.LOGGER.error("Failed to access pocket dimension", e);
            e.printStackTrace();
        }
        return null;
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/dimension/PocketDimensionChunkGenerator.java">
package ninja.trek.pocketportals.dimension;
import com.mojang.serialization.Codec;
import com.mojang.serialization.MapCodec;
import com.mojang.serialization.codecs.RecordCodecBuilder;
import net.minecraft.block.BlockState;
import net.minecraft.block.Blocks;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.ChunkRegion;
import net.minecraft.world.HeightLimitView;
import net.minecraft.world.Heightmap;
import net.minecraft.world.biome.source.BiomeAccess;
import net.minecraft.world.biome.source.BiomeSource;
import net.minecraft.world.chunk.Chunk;
import net.minecraft.world.gen.GenerationStep;
import net.minecraft.world.gen.StructureAccessor;
import net.minecraft.world.gen.chunk.*;
import net.minecraft.world.gen.noise.NoiseConfig;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executor;
public class PocketDimensionChunkGenerator extends ChunkGenerator {
    private record GeneratorSettings(boolean generating, int islandSize, int baseHeight) {
        public static final MapCodec<GeneratorSettings> CODEC = RecordCodecBuilder.mapCodec(instance ->
                instance.group(
                        Codec.BOOL.fieldOf("generating").forGetter(GeneratorSettings::generating),
                        Codec.INT.fieldOf("island_size").forGetter(GeneratorSettings::islandSize),
                        Codec.INT.fieldOf("base_height").forGetter(GeneratorSettings::baseHeight)
                ).apply(instance, GeneratorSettings::new)
        );
    }
    private final GeneratorSettings settings;
    private final long seed;
    public static final MapCodec<PocketDimensionChunkGenerator> CODEC = RecordCodecBuilder.mapCodec(instance ->
            instance.group(
                    BiomeSource.CODEC.fieldOf("biome_source").forGetter(ChunkGenerator::getBiomeSource),
                    Codec.LONG.fieldOf("seed").forGetter(gen -> gen.seed),
                    GeneratorSettings.CODEC.fieldOf("settings").forGetter(gen -> gen.settings)
            ).apply(instance, PocketDimensionChunkGenerator::new)
    );
    public PocketDimensionChunkGenerator(BiomeSource biomeSource, long seed, GeneratorSettings settings) {
        super(biomeSource);
        this.seed = seed;
        this.settings = settings;
    }
    @Override
    protected MapCodec<? extends ChunkGenerator> getCodec() {
        return CODEC;
    }
    @Override
    public void carve(ChunkRegion chunkRegion, long seed, NoiseConfig noiseConfig, BiomeAccess biomeAccess, StructureAccessor structureAccessor, Chunk chunk, GenerationStep.Carver carverStep) {
    }
    @Override
    public void buildSurface(ChunkRegion region, StructureAccessor structures, NoiseConfig noiseConfig, Chunk chunk) {
        if (!settings.generating()) return;
        int chunkX = chunk.getPos().x * 16;
        int chunkZ = chunk.getPos().z * 16;
        BlockPos.Mutable mutable = new BlockPos.Mutable();
        for (int x = 0; x < 16; x++) {
            for (int z = 0; z < 16; z++) {
                int worldX = chunkX + x;
                int worldZ = chunkZ + z;
                double distance = Math.sqrt(worldX * worldX + worldZ * worldZ);
                if (distance <= settings.islandSize()) {
                    int height = settings.baseHeight() + (int)(5 * Math.cos(distance / 10));
                    for (int y = settings.baseHeight() - 5; y < height; y++) {
                        mutable.set(worldX, y, worldZ);
                        if (y == height - 1) {
                            region.setBlockState(mutable, Blocks.GRASS_BLOCK.getDefaultState(), 3);
                        } else {
                            region.setBlockState(mutable, Blocks.DIRT.getDefaultState(), 3);
                        }
                    }
                }
            }
        }
    }
    @Override
    public void populateEntities(ChunkRegion region) {
    }
    @Override
    public int getWorldHeight() {
        return 0;
    }
    @Override
    public CompletableFuture<Chunk> populateNoise(Blender blender, NoiseConfig noiseConfig, StructureAccessor structureAccessor, Chunk chunk) {
        return CompletableFuture.completedFuture(chunk);
    }
    @Override
    public int getSeaLevel() {
        return 0;
    }
    @Override
    public int getMinimumY() {
        return -64;
    }
    @Override
    public int getHeight(int x, int z, Heightmap.Type heightmap, HeightLimitView world, NoiseConfig noiseConfig) {
        double distance = Math.sqrt(x * x + z * z);
        if (distance <= settings.islandSize()) {
            return settings.baseHeight() + (int)(5 * Math.cos(distance / 10));
        }
        return world.getBottomY();
    }
    @Override
    public VerticalBlockSample getColumnSample(int x, int z, HeightLimitView world, NoiseConfig noiseConfig) {
        BlockState[] states = new BlockState[world.getHeight()];
        int baseY = world.getBottomY();
        double distance = Math.sqrt(x * x + z * z);
        if (distance <= settings.islandSize()) {
            int height = settings.baseHeight() + (int)(5 * Math.cos(distance / 10));
            for (int y = 0; y < world.getHeight(); y++) {
                int worldY = baseY + y;
                if (worldY < height - 1) {
                    states[y] = Blocks.DIRT.getDefaultState();
                } else if (worldY == height - 1) {
                    states[y] = Blocks.GRASS_BLOCK.getDefaultState();
                } else {
                    states[y] = Blocks.AIR.getDefaultState();
                }
            }
        } else {
            for (int y = 0; y < world.getHeight(); y++) {
                states[y] = Blocks.AIR.getDefaultState();
            }
        }
        return new VerticalBlockSample(baseY, states);
    }
    @Override
    public void getDebugHudText(List<String> text, NoiseConfig noiseConfig, BlockPos pos) {
        text.add("Pocket Dimension Generator");
        text.add(String.format("Generating: %s", settings.generating()));
        text.add(String.format("Island Size: %d", settings.islandSize()));
        text.add(String.format("Base Height: %d", settings.baseHeight()));
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/item/ModItems.java">
package ninja.trek.pocketportals.item;
import net.minecraft.item.BlockItem;
import net.minecraft.item.Item;
import net.minecraft.registry.Registries;
import net.minecraft.registry.Registry;
import net.minecraft.util.Identifier;
import ninja.trek.pocketportals.PocketPortals;
import ninja.trek.pocketportals.block.ModBlocks;
public class ModItems {
    public static final BlockItem POCKET_PORTAL = new BlockItem(
            ModBlocks.POCKET_PORTAL,
            new Item.Settings()
    );
    public static void registerItems() {
        Registry.register(
                Registries.ITEM,
                Identifier.of(PocketPortals.MOD_ID, "pocket_portal"),
                POCKET_PORTAL
        );
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/mixin/ExampleMixin.java">
package ninja.trek.pocketportals.mixin;
import net.minecraft.server.MinecraftServer;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(MinecraftServer.class)
public class ExampleMixin {
	@Inject(at = @At("HEAD"), method = "loadWorld")
	private void init(CallbackInfo info) {
		// This code is injected into the start of MinecraftServer.loadWorld()V
	}
}
</file>

<file path="main/java/ninja/trek/pocketportals/PocketPortals.java">
package ninja.trek.pocketportals;
import net.fabricmc.api.ModInitializer;
import net.fabricmc.fabric.api.event.lifecycle.v1.ServerLifecycleEvents;
import ninja.trek.pocketportals.block.ModBlocks;
import ninja.trek.pocketportals.data.DataLoader;
import ninja.trek.pocketportals.dimension.ModDimensions;
import ninja.trek.pocketportals.item.ModItems;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class PocketPortals implements ModInitializer {
	public static final String MOD_ID = "pocket-portals";
	public static final Logger LOGGER = LoggerFactory.getLogger(MOD_ID);
	@Override
	public void onInitialize() {
		// Register data loader first
		DataLoader.register();
		// Register dimension system first
		ModDimensions.register();
		// Then register blocks and items that might depend on dimensions
		ModBlocks.registerBlocks();
		ModItems.registerItems();
		// Add initialization verification
		ServerLifecycleEvents.SERVER_STARTED.register(server -> {
			LOGGER.info("Verifying EndNew mod initialization...");
			// Verify dimension registration
			if (server.getWorldRegistryKeys().contains(ModDimensions.POCKET_DIMENSION_KEY)) {
				LOGGER.info("Pocket dimension registration verified");
			} else {
				LOGGER.warn("Pocket dimension might need manual world creation - this is normal on first load");
			}
		});
		LOGGER.info("EndNew mod initialized!");
	}
}
</file>

<file path="main/resources/assets/pocket-portals/blockstates/pocket_portal_frame.json">
{
  "variants": {
    "": { "model": "pocket-portals:block/pocket_portal_frame" }
  }
}
</file>

<file path="main/resources/assets/pocket-portals/blockstates/pocket_portal.json">
{
  "variants": {
    "facing=north": { "model": "pocket-portals:block/pocket_portal", "y": 180 },
    "facing=east": { "model": "pocket-portals:block/pocket_portal", "y": 90 },
    "facing=south": { "model": "pocket-portals:block/pocket_portal", "y": 0 },
    "facing=west": { "model": "pocket-portals:block/pocket_portal", "y": 270 }
  }
}
</file>

<file path="main/resources/assets/pocket-portals/models/block/pocket_portal_frame.json">
{
  "parent": "block/cube",
  "textures": {
    "particle": "block/nether_portal",
    "portal": "block/nether_portal"
  },
  "elements": [
    {
      "from": [0, 0, 0],
      "to": [16, 16, 16],
      "faces": {
        "north": {"uv": [0, 0, 16, 16], "texture": "portal"},
        "east": {"uv": [0, 0, 16, 16], "texture": "portal"},
        "south": {"uv": [0, 0, 16, 16], "texture": "portal"},
        "west": {"uv": [0, 0, 16, 16], "texture": "portal"},
        "up": {"uv": [0, 0, 16, 16], "texture": "portal"},
        "down": {"uv": [0, 0, 16, 16], "texture": "portal"}
      }
    }
  ]
}
</file>

<file path="main/resources/assets/pocket-portals/models/block/pocket_portal.json">
{
  "parent": "block/cube_all",
  "textures": {
    "all": "pocket-portals:block/pocket_portal"
  }
}
</file>

<file path="main/resources/assets/pocket-portals/models/item/pocket_portal.json">
{
  "parent": "pocket-portals:block/pocket_portal"
}
</file>

<file path="main/resources/data/pocket-portals/dimension_type/pocket_dimension_type.json">
{
  "ultrawarm": false,
  "natural": true,
  "coordinate_scale": 1.0,
  "has_skylight": true,
  "has_ceiling": false,
  "ambient_light": 0.1,
  "fixed_time": 6000,
  "monster_spawn_light_level": 7,
  "monster_spawn_block_light_limit": 0,
  "piglin_safe": false,
  "bed_works": true,
  "respawn_anchor_works": false,
  "has_raids": false,
  "min_y": -64,
  "height": 384,
  "logical_height": 384,
  "infiniburn": "#minecraft:infiniburn_overworld",
  "effects": "minecraft:overworld"
}
</file>

<file path="main/resources/data/pocket-portals/dimension/pocket_dimension.json">
{
  "type": "pocket-portals:pocket_dimension_type",
  "generator": {
    "type": "pocket-portals:pocket_dimension",
    "seed": 0,
    "settings": {
      "generating": true,
      "island_size": 100,
      "base_height": 64
    },
    "biome_source": {
      "type": "minecraft:fixed",
      "biome": "minecraft:plains"
    }
  }
}
</file>

<file path="main/resources/data/pocket-portals/loot_tables/blocks/pocket_portal.json">
{
  "type": "minecraft:block",
  "pools": [
    {
      "rolls": 1,
      "entries": [
        {
          "type": "minecraft:item",
          "name": "pocket-portals:pocket_portal"
        }
      ]
    }
  ]
}
</file>

<file path="main/resources/fabric.mod.json">
{
	"schemaVersion": 1,
	"id": "pocket-portals",
	"version": "${version}",
	"name": "Pocket Portals",
	"description": "This is an example description! Tell everyone what your mod is about!",
	"authors": [
		"Me!"
	],
	"contact": {
		"homepage": "https://fabricmc.net/",
		"sources": "https://github.com/FabricMC/fabric-example-mod"
	},
	"license": "CC0-1.0",
	"icon": "assets/pocket-portals/icon.png",
	"environment": "*",
	"entrypoints": {
		"main": [
			"ninja.trek.pocketportals.PocketPortals"
		],
		"client": [
			"ninja.trek.pocketportals.PocketPortalsClient"
		],
		"fabric-datagen": [
			"ninja.trek.pocketportals.PocketPortalsDataGenerator"
		]
	},
	"mixins": [
		"pocket-portals.mixins.json",
		{
			"config": "pocket-portals.client.mixins.json",
			"environment": "client"
		}
	],
	"depends": {
		"fabricloader": ">=0.16.10",
		"minecraft": "~1.21",
		"java": ">=21",
		"fabric-api": "*"
	},
	"suggests": {
		"another-mod": "*"
	}
}
</file>

<file path="main/resources/pocket-portals.mixins.json">
{
	"required": true,
	"package": "ninja.trek.pocketportals.mixin",
	"compatibilityLevel": "JAVA_21",
	"mixins": [
		"ExampleMixin"
	],
	"injectors": {
		"defaultRequire": 1
	}
}
</file>

<file path="repomixx.bat">
repomix --style xml --remove-empty-lines --copy --ignore "**/generated/**"
</file>

</files>
