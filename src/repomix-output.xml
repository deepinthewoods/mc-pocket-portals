This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-17T19:07:05.838Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
client/java/ninja/trek/pocketportals/mixin/client/ClientWorldMixin.java
client/java/ninja/trek/pocketportals/mixin/client/ExampleClientMixin.java
client/java/ninja/trek/pocketportals/PocketPortalsClient.java
client/java/ninja/trek/pocketportals/PocketPortalsDataGenerator.java
client/java/ninja/trek/pocketportals/PortalOverlayText.java
client/resources/pocketportals.client.mixins.json
main/java/ninja/trek/pocketportals/block/ModBlocks.java
main/java/ninja/trek/pocketportals/block/PocketPortalBlock.java
main/java/ninja/trek/pocketportals/block/PocketPortalBlockEntity.java
main/java/ninja/trek/pocketportals/block/PocketPortalFrame.java
main/java/ninja/trek/pocketportals/block/ReturnPocketPortalBlock.java
main/java/ninja/trek/pocketportals/block/ReturnPocketPortalBlockEntity.java
main/java/ninja/trek/pocketportals/data/DataLoader.java
main/java/ninja/trek/pocketportals/data/PocketPortalDataTypes.java
main/java/ninja/trek/pocketportals/dimension/GridBiomeSource.java
main/java/ninja/trek/pocketportals/dimension/GridSpawnRules.java
main/java/ninja/trek/pocketportals/dimension/ModDimensions.java
main/java/ninja/trek/pocketportals/dimension/PocketDimensionJsonProvider.java
main/java/ninja/trek/pocketportals/dimension/PocketDimensionsRegistry.java
main/java/ninja/trek/pocketportals/dimension/SkyIslandChunkGenerator.java
main/java/ninja/trek/pocketportals/item/ModItems.java
main/java/ninja/trek/pocketportals/item/PocketPortalItem.java
main/java/ninja/trek/pocketportals/mixin/ExampleMixin.java
main/java/ninja/trek/pocketportals/mixin/SpawnHelperMixin.java
main/java/ninja/trek/pocketportals/network/RequestSpawnRulesPacket.java
main/java/ninja/trek/pocketportals/network/SpawnRulesPacket.java
main/java/ninja/trek/pocketportals/PocketPortals.java
main/java/ninja/trek/pocketportals/SpawnRulesData.java
main/resources/fabric.mod.json
main/resources/pocketportals.mixins.json
repomixx.bat
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="client/java/ninja/trek/pocketportals/mixin/client/ClientWorldMixin.java">
package ninja.trek.pocketportals.mixin.client;
import net.fabricmc.fabric.api.client.networking.v1.ClientPlayNetworking;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.world.ClientWorld;
import net.minecraft.util.hit.BlockHitResult;
import net.minecraft.util.hit.HitResult;
import net.minecraft.util.math.BlockPos;
import ninja.trek.pocketportals.PocketPortals;
import ninja.trek.pocketportals.PortalOverlayText;
import ninja.trek.pocketportals.SpawnRulesData;
import ninja.trek.pocketportals.block.ModBlocks;
import ninja.trek.pocketportals.block.PocketPortalBlockEntity;
import ninja.trek.pocketportals.network.RequestSpawnRulesPacket;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
import net.minecraft.block.entity.BlockEntity;
import java.util.Map;
import java.util.stream.Collectors;
@Mixin(ClientWorld.class)
public class ClientWorldMixin {
    private long lastSpawnRulesRequestTime = 0;
    @Inject(method = "tick", at = @At("HEAD"))
    private void onTick(CallbackInfo ci) {
        MinecraftClient client = MinecraftClient.getInstance();
        if (client.player == null) return;
        HitResult hit = client.crosshairTarget;
        if (hit == null || hit.getType() != HitResult.Type.BLOCK) {
            PortalOverlayText.clearText();
            return;
        }
        BlockHitResult blockHit = (BlockHitResult) hit;
        ClientWorld world = (ClientWorld) (Object) this;
        BlockPos portalBasePos = null;
        // Check if looking at frame or base
        if (world.getBlockState(blockHit.getBlockPos()).isOf(ModBlocks.POCKET_PORTAL_FRAME) ||
                world.getBlockState(blockHit.getBlockPos()).isOf(ModBlocks.POCKET_PORTAL)) {
            // Search for portal base
            for (int y = 0; y > -3; y--) {
                BlockPos checkPos = blockHit.getBlockPos().add(0, y, 0);
                if (world.getBlockState(checkPos).isOf(ModBlocks.POCKET_PORTAL)) {
                    portalBasePos = checkPos;
                    break;
                }
            }
        }
        if (portalBasePos != null) {
//            PocketPortals.LOGGER.info("found portal");
            // Request spawn rules if needed
            if (System.currentTimeMillis() - lastSpawnRulesRequestTime > 1250) {
                ClientPlayNetworking.getSender().sendPacket(new RequestSpawnRulesPacket(portalBasePos));
                lastSpawnRulesRequestTime = System.currentTimeMillis();
            }
            // Get block entity data for destination info
            BlockEntity be = world.getBlockEntity(portalBasePos);
            if (be instanceof PocketPortalBlockEntity portalBE) {
                Integer dimensionIndex = portalBE.getDimensionIndex();
//                PocketPortals.LOGGER.info("found portal be {}", dimensionIndex);
                if (dimensionIndex != null) {
                    // Get spawn rules for this dimension
                    Map<?, ?> rules = SpawnRulesData.getSpawnRules(dimensionIndex);
                    StringBuilder overlayText = new StringBuilder();
                    overlayText.append("§6✧ Pocket Dimension §7#").append(dimensionIndex).append("\n");
                    if (!rules.isEmpty()) {
//                        PocketPortals.LOGGER.info("rules not empty");
                        long disabledCount = rules.values().stream()
                                .filter(allowed -> !(Boolean) allowed)
                                .count();
                        if (disabledCount == rules.size()) {
                            overlayText.append("§a⚠ Peaceful");
                        } else if (disabledCount > 0) {
                            overlayText.append("§e⚠ Limited Spawns:\n")
                                    .append(rules.entrySet().stream()
                                            .filter(e -> !(Boolean) e.getValue())
                                            .map(e -> "§7" + formatEntityName(e.getKey().toString()))
                                            .collect(Collectors.joining("\n§8, ")));
                        } else {
                            overlayText.append("§c✓ Hostile");
                        }
                    }
                    PortalOverlayText.setText(overlayText.toString());
                }
            }
        } else {
            PortalOverlayText.clearText();
        }
    }
    private String formatEntityName(String entityId) {
        int index = entityId.lastIndexOf(":");
        if (index == -1) {
            index = entityId.lastIndexOf(".");
        }
        String name = entityId.substring(index + 1);
        return name.substring(0, 1).toUpperCase() + name.substring(1);
    }
}
</file>

<file path="client/java/ninja/trek/pocketportals/mixin/client/ExampleClientMixin.java">
package ninja.trek.pocketportals.mixin.client;
import net.minecraft.client.MinecraftClient;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(MinecraftClient.class)
public class ExampleClientMixin {
	@Inject(at = @At("HEAD"), method = "run")
	private void init(CallbackInfo info) {
		// This code is injected into the start of MinecraftClient.run()V
	}
}
</file>

<file path="client/java/ninja/trek/pocketportals/PocketPortalsClient.java">
package ninja.trek.pocketportals;
import net.fabricmc.api.ClientModInitializer;
import net.fabricmc.fabric.api.client.event.lifecycle.v1.ClientTickEvents;
import net.fabricmc.fabric.api.client.networking.v1.ClientPlayNetworking;
import net.fabricmc.fabric.api.client.rendering.v1.HudRenderCallback;
import net.fabricmc.fabric.api.client.rendering.v1.WorldRenderContext;
import net.fabricmc.fabric.api.client.rendering.v1.WorldRenderEvents;
import net.fabricmc.fabric.api.networking.v1.PayloadTypeRegistry;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.gui.DrawContext;
import net.minecraft.client.render.RenderTickCounter;
import net.minecraft.network.RegistryByteBuf;
import ninja.trek.pocketportals.network.SpawnRulesPacket;
import net.minecraft.client.render.GameRenderer;
public class PocketPortalsClient implements ClientModInitializer {
	@Override
	public void onInitializeClient() {
		PayloadTypeRegistry<RegistryByteBuf> playS2CRegistry = PayloadTypeRegistry.playS2C();
		playS2CRegistry.register(SpawnRulesPacket.ID, SpawnRulesPacket.CODEC);
		// Register client-side receiver
		ClientPlayNetworking.registerGlobalReceiver(SpawnRulesPacket.ID, (packet, context) -> {
			context.client().execute(() -> {
				SpawnRulesData.setSpawnRules(packet.dimensionIndex(), packet.rules());
//				PocketPortals.LOGGER.info("receive spawn rules {}", packet.rules());
			});
		});
		HudRenderCallback.EVENT.register((DrawContext context, RenderTickCounter tickDeltaManager) -> {
			float tickDelta = tickDeltaManager.getTickDelta(true);
			if (MinecraftClient.getInstance().currentScreen == null) {
//				PocketPortals.LOGGER.info("render overlay");
				PortalOverlayText.render(context);
			}
		});
	}
}
</file>

<file path="client/java/ninja/trek/pocketportals/PocketPortalsDataGenerator.java">
package ninja.trek.pocketportals;
import net.fabricmc.fabric.api.client.datagen.v1.provider.FabricModelProvider;
import net.fabricmc.fabric.api.datagen.v1.DataGeneratorEntrypoint;
import net.fabricmc.fabric.api.datagen.v1.FabricDataGenerator;
import net.fabricmc.fabric.api.datagen.v1.FabricDataOutput;
import net.minecraft.client.data.*;
import net.minecraft.state.property.Properties;
import net.minecraft.util.Identifier;
import ninja.trek.pocketportals.block.ModBlocks;
import ninja.trek.pocketportals.dimension.PocketDimensionJsonProvider;
import ninja.trek.pocketportals.item.ModItems;
import java.util.concurrent.CompletableFuture;
import net.minecraft.registry.RegistryWrapper;
public class PocketPortalsDataGenerator implements DataGeneratorEntrypoint {
    @Override
    public void onInitializeDataGenerator(FabricDataGenerator fabricDataGenerator) {
        FabricDataGenerator.Pack pack = fabricDataGenerator.createPack();
        // Add Dimension Data Provider
        pack.addProvider((FabricDataOutput output, CompletableFuture<RegistryWrapper.WrapperLookup> registriesFuture) ->
                new PocketDimensionJsonProvider(output));
        // Add Model Provider
        pack.addProvider((FabricDataOutput output, CompletableFuture<RegistryWrapper.WrapperLookup> registriesFuture) ->
                new FabricModelProvider(output) {
                    @Override
                    public void generateBlockStateModels(BlockStateModelGenerator blockStateModelGenerator) {
                        // Create texture identifiers
                        Identifier portalTexture = Identifier.of(PocketPortals.MOD_ID, "block/pocket_portal");
                        Identifier returnPortalTexture = Identifier.of(PocketPortals.MOD_ID, "block/return_pocket_portal");
                        Identifier frameTexture = Identifier.of(PocketPortals.MOD_ID, "block/pocket_portal_frame");
                        // Create texture mappings
                        TextureMap portalTextures = new TextureMap()
                                .put(TextureKey.ALL, portalTexture);
                        TextureMap returnPortalTextures = new TextureMap()
                                .put(TextureKey.ALL, returnPortalTexture);
                        TextureMap frameTextures = new TextureMap()
                                .put(TextureKey.ALL, frameTexture);
                        // Generate base models
                        Identifier portalModel = Models.CUBE_ALL.upload(
                                ModBlocks.POCKET_PORTAL,
                                portalTextures,
                                blockStateModelGenerator.modelCollector
                        );
                        Identifier returnPortalModel = Models.CUBE_ALL.upload(
                                ModBlocks.RETURN_POCKET_PORTAL,
                                returnPortalTextures,
                                blockStateModelGenerator.modelCollector
                        );
                        Identifier frameModel = Models.CUBE_ALL.upload(
                                ModBlocks.POCKET_PORTAL_FRAME,
                                frameTextures,
                                blockStateModelGenerator.modelCollector
                        );
                        // Generate blockstates with variants
                        // Pocket Portal (with facing variants)
                        blockStateModelGenerator.blockStateCollector.accept(
                                VariantsBlockStateSupplier.create(ModBlocks.POCKET_PORTAL)
                                        .coordinate(BlockStateVariantMap.create(Properties.HORIZONTAL_FACING)
                                                .register(net.minecraft.util.math.Direction.NORTH, BlockStateVariant.create().put(VariantSettings.MODEL, portalModel))
                                                .register(net.minecraft.util.math.Direction.SOUTH, BlockStateVariant.create().put(VariantSettings.MODEL, portalModel).put(VariantSettings.Y, VariantSettings.Rotation.R180))
                                                .register(net.minecraft.util.math.Direction.WEST, BlockStateVariant.create().put(VariantSettings.MODEL, portalModel).put(VariantSettings.Y, VariantSettings.Rotation.R270))
                                                .register(net.minecraft.util.math.Direction.EAST, BlockStateVariant.create().put(VariantSettings.MODEL, portalModel).put(VariantSettings.Y, VariantSettings.Rotation.R90)))
                        );
                        // Return Portal (simple block)
                        blockStateModelGenerator.blockStateCollector.accept(
                                BlockStateModelGenerator.createSingletonBlockState(
                                        ModBlocks.RETURN_POCKET_PORTAL,
                                        returnPortalModel
                                )
                        );
                        // Portal Frame (simple block)
                        blockStateModelGenerator.blockStateCollector.accept(
                                BlockStateModelGenerator.createSingletonBlockState(
                                        ModBlocks.POCKET_PORTAL_FRAME,
                                        frameModel
                                )
                        );
                    }
                    @Override
                    public void generateItemModels(ItemModelGenerator itemModelGenerator) {
                        // Generate item models that reference block models
                        itemModelGenerator.register(ModItems.POCKET_PORTAL_ITEM, Models.GENERATED);
                    }
                });
    }
}
</file>

<file path="client/java/ninja/trek/pocketportals/PortalOverlayText.java">
package ninja.trek.pocketportals;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.font.TextRenderer;
import net.minecraft.client.gui.DrawContext;
import net.minecraft.text.Text;
public class PortalOverlayText {
    private static String currentText = null;
    private static long lastUpdateTime = 0;
    private static final long DISPLAY_DURATION = 2000; // 2 seconds
    public static void setText(String text) {
        currentText = text;
        lastUpdateTime = System.currentTimeMillis();
    }
    public static void clearText() {
        currentText = null;
    }
    public static void render(DrawContext context) {
        if (currentText == null) return;
        // Clear text if it's been showing too long
        if (System.currentTimeMillis() - lastUpdateTime > DISPLAY_DURATION) {
            clearText();
            return;
        }
        MinecraftClient client = MinecraftClient.getInstance();
        TextRenderer textRenderer = client.textRenderer;
        // Split text into lines
        String[] lines = currentText.split("\n");
        // Calculate total height (adding a 2-pixel spacing between lines)
        int lineHeight = textRenderer.fontHeight + 2;
        int totalHeight = lines.length * lineHeight;
        // Get screen dimensions and define margins
        int screenWidth = client.getWindow().getScaledWidth();
        int screenHeight = client.getWindow().getScaledHeight();
        int sideMargin = 5;
        // Offset from bottom to clear the hotbar area; adjust this value as needed.
        int hotbarOffset = 30;
        // Set starting position above the hotbar.
        int baseX = sideMargin;
        int baseY = screenHeight - totalHeight - sideMargin - hotbarOffset;
        // Draw each line starting from the base position
        for (int i = 0; i < lines.length; i++) {
            String line = lines[i];
            int y = baseY + (i * lineHeight);
            // Draw the line with white color (0xFFFFFF) and with a shadow.
            context.drawText(textRenderer, Text.literal(line), baseX, y, 0xFFFFFF, true);
        }
    }
}
</file>

<file path="client/resources/pocketportals.client.mixins.json">
{
	"required": true,
	"package": "ninja.trek.pocketportals.mixin.client",
	"compatibilityLevel": "JAVA_21",
	"client": [
		"ExampleClientMixin",
		"ClientWorldMixin"
	],
	"injectors": {
		"defaultRequire": 1
	}
}
</file>

<file path="main/java/ninja/trek/pocketportals/block/ModBlocks.java">
package ninja.trek.pocketportals.block;
import net.minecraft.block.AbstractBlock;
import net.minecraft.block.Block;
import net.minecraft.registry.Registry;
import net.minecraft.registry.RegistryKey;
import net.minecraft.registry.RegistryKeys;
import net.minecraft.registry.Registries;
import net.minecraft.util.Identifier;
import ninja.trek.pocketportals.PocketPortals;
import net.fabricmc.fabric.api.object.builder.v1.block.entity.FabricBlockEntityTypeBuilder;
public class ModBlocks {
    // --- Blocks ---
    public static Block POCKET_PORTAL;
    public static Block RETURN_POCKET_PORTAL;
    public static Block POCKET_PORTAL_FRAME;
    // --- Block Entities ---
    public static net.minecraft.block.entity.BlockEntityType<PocketPortalBlockEntity> POCKET_PORTAL_BLOCK_ENTITY;
    public static net.minecraft.block.entity.BlockEntityType<ReturnPocketPortalBlockEntity> RETURN_PORTAL_BLOCK_ENTITY;
    public static void registerBlocks() {
        POCKET_PORTAL = registerBlock("pocket_portal",
                AbstractBlock.Settings.create()
                        .strength(3.0f)
                        .requiresTool()
                        .nonOpaque());
        RETURN_POCKET_PORTAL = registerBlock("return_pocket_portal",
                AbstractBlock.Settings.create()
                        .strength(3.0f)
                        .requiresTool()
                        .nonOpaque());
        POCKET_PORTAL_FRAME = registerBlock("pocket_portal_frame",
                AbstractBlock.Settings.create()
                        .luminance(state -> 11)
                        .noCollision()
                        .strength(-1.0F));
        // Register block entities
        POCKET_PORTAL_BLOCK_ENTITY = Registry.register(
                Registries.BLOCK_ENTITY_TYPE,
                Identifier.of(PocketPortals.MOD_ID, "pocket_portal_entity"),
                FabricBlockEntityTypeBuilder.create(PocketPortalBlockEntity::new, POCKET_PORTAL).build()
        );
        RETURN_PORTAL_BLOCK_ENTITY = Registry.register(
                Registries.BLOCK_ENTITY_TYPE,
                Identifier.of(PocketPortals.MOD_ID, "return_portal_entity"),
                FabricBlockEntityTypeBuilder.create(ReturnPocketPortalBlockEntity::new, RETURN_POCKET_PORTAL).build()
        );
    }
    private static Block registerBlock(String name, AbstractBlock.Settings settings) {
        Identifier id = Identifier.of(PocketPortals.MOD_ID, name);
        RegistryKey<Block> key = RegistryKey.of(RegistryKeys.BLOCK, id);
        // Always attach the registry key to the settings!
        PocketPortals.LOGGER.info("Registering block {} with registry key {}", name, key);
        AbstractBlock.Settings settingsWithKey = settings.registryKey(key);
        Block block = createBlock(name, settingsWithKey);
        return Registry.register(Registries.BLOCK, key, block);
    }
    private static Block createBlock(String name, AbstractBlock.Settings settings) {
        return switch (name) {
            case "pocket_portal" -> new PocketPortalBlock(settings);
            case "return_pocket_portal" -> new ReturnPocketPortalBlock(settings);
            case "pocket_portal_frame" -> new PocketPortalFrame(settings);
            default -> throw new IllegalArgumentException("Unknown block: " + name);
        };
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/block/PocketPortalBlock.java">
package ninja.trek.pocketportals.block;
import com.mojang.serialization.MapCodec;
import net.minecraft.block.*;
import net.minecraft.block.entity.BlockEntity;
import net.minecraft.entity.Entity;
import net.minecraft.entity.LivingEntity;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.item.ItemStack;
import net.minecraft.server.world.ServerWorld;
import net.minecraft.state.StateManager;
import net.minecraft.state.property.Property;
import net.minecraft.util.Identifier;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Direction;
import net.minecraft.world.World;
import ninja.trek.pocketportals.dimension.PocketDimensionsRegistry;
import static ninja.trek.pocketportals.data.PocketPortalDataTypes.DIMENSION_INDEX;
public class PocketPortalBlock extends BlockWithEntity {
    public static final Property<Direction> FACING = HorizontalFacingBlock.FACING;
    public static final MapCodec<PocketPortalBlock> CODEC = createCodec(PocketPortalBlock::new);
    public PocketPortalBlock(Settings settings) {
        super(validateSettings(settings));
        setDefaultState(getStateManager().getDefaultState().with(FACING, Direction.NORTH));
    }
    private static Settings validateSettings(Settings settings) {
        if (settings == null) {
            throw new IllegalArgumentException("Settings cannot be null");
        }
        return settings;
    }
    @Override
    protected MapCodec<? extends BlockWithEntity> getCodec() {
        return CODEC;
    }
    @Override
    public BlockRenderType getRenderType(BlockState state) {
        return BlockRenderType.MODEL;
    }
    @Override
    protected void appendProperties(StateManager.Builder<Block, BlockState> builder) {
        builder.add(FACING);
    }
    @Override
    public BlockEntity createBlockEntity(BlockPos pos, BlockState state) {
        return new PocketPortalBlockEntity(pos, state);
    }
    // In PocketPortalBlock.java, modify the onPlaced method:
    @Override
    public void onPlaced(World world, BlockPos pos, BlockState state, LivingEntity placer, ItemStack stack) {
        super.onPlaced(world, pos, state, placer, stack);
        if (!world.isClient) {
            BlockEntity blockEntity = world.getBlockEntity(pos);
            if (blockEntity instanceof PocketPortalBlockEntity portalBE) {
                // Read dimension index from the item's components
                Integer storedIndex = stack.get(DIMENSION_INDEX);
                // If none present, get a new unused one
                if (storedIndex == null) {
                    storedIndex = PocketDimensionsRegistry.findUnusedSlot(((ServerWorld)world).getServer());
                }
                // Set it in the block entity
                portalBE.setDimensionIndex(storedIndex);
                portalBE.markDirty();
                // Create frame blocks above
                BlockPos portalPos1 = pos.up();
                BlockPos portalPos2 = portalPos1.up();
                world.setBlockState(portalPos1, ModBlocks.POCKET_PORTAL_FRAME.getDefaultState());
                world.setBlockState(portalPos2, ModBlocks.POCKET_PORTAL_FRAME.getDefaultState());
            }
        }
    }
    @Override
    public void onEntityCollision(BlockState state, World world, BlockPos pos, Entity entity) {
        if (!world.isClient) {
            // Only allow teleportation from overworld
            if (!world.getRegistryKey().equals(World.OVERWORLD)) {
                return;
            }
            BlockEntity be = world.getBlockEntity(pos);
            if (be instanceof PocketPortalBlockEntity portalBE) {
                portalBE.handleEntityCollision(entity);
            }
        }
    }
    @Override
    public BlockState onBreak(World world, BlockPos pos, BlockState state, PlayerEntity player) {
        if (!world.isClient) {
            BlockEntity be = world.getBlockEntity(pos);
            if (be instanceof PocketPortalBlockEntity portalBE) {
                Integer dimIndex = portalBE.getDimensionIndex();
                // Create a new item with the dimension index
                ItemStack newStack = new ItemStack(ModBlocks.POCKET_PORTAL);
                if (dimIndex != null) {
                    // Store using item components
                    newStack.set(DIMENSION_INDEX, dimIndex);
                }
                // Drop the item
                Block.dropStack(world, pos, newStack);
            }
        }
        // Remove frames above
        world.setBlockState(pos.up(), Blocks.AIR.getDefaultState());
        world.setBlockState(pos.up(2), Blocks.AIR.getDefaultState());
        return super.onBreak(world, pos, state, player);
    }
    @Override
    public void onStateReplaced(BlockState state, World world, BlockPos pos,
                                BlockState newState, boolean moved) {
        if (!state.isOf(newState.getBlock())) {
            // Remove frame blocks
            world.setBlockState(pos.up(), Blocks.AIR.getDefaultState());
            world.setBlockState(pos.up(2), Blocks.AIR.getDefaultState());
        }
        super.onStateReplaced(state, world, pos, newState, moved);
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/block/PocketPortalBlockEntity.java">
package ninja.trek.pocketportals.block;
import net.fabricmc.fabric.api.networking.v1.ServerPlayNetworking;
import net.minecraft.block.BlockState;
import net.minecraft.block.Blocks;
import net.minecraft.block.entity.BlockEntity;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityType;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.nbt.NbtCompound;
import net.minecraft.network.packet.s2c.play.PositionFlag;
import net.minecraft.registry.RegistryWrapper;
import net.minecraft.server.network.ServerPlayerEntity;
import net.minecraft.server.world.ServerWorld;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.Heightmap;
import ninja.trek.pocketportals.PocketPortals;
import ninja.trek.pocketportals.dimension.GridSpawnRules;
import ninja.trek.pocketportals.dimension.ModDimensions;
import ninja.trek.pocketportals.dimension.PocketDimensionsRegistry;
import ninja.trek.pocketportals.network.SpawnRulesPacket;
import java.util.*;
public class PocketPortalBlockEntity extends BlockEntity {
    private static final String DIMENSION_INDEX_KEY = "PocketDimensionIndex";
    private Integer dimensionIndex = null; // store an index from 0..255
    public PocketPortalBlockEntity(BlockPos pos, BlockState state) {
        super(ModBlocks.POCKET_PORTAL_BLOCK_ENTITY, pos, state);
    }
    public Integer getDimensionIndex() {
        return dimensionIndex;
    }
    public void setDimensionIndex(Integer dimensionIndex) {
        this.dimensionIndex = dimensionIndex;
    }
    @Override
    public void readNbt(NbtCompound nbt, RegistryWrapper.WrapperLookup lookup) {
        super.readNbt(nbt, lookup);
        if (nbt.contains(DIMENSION_INDEX_KEY)) {
            dimensionIndex = nbt.getInt(DIMENSION_INDEX_KEY);
        }
    }
    @Override
    public void writeNbt(NbtCompound nbt, RegistryWrapper.WrapperLookup lookup) {
        super.writeNbt(nbt, lookup);
        if (dimensionIndex != null) {
            nbt.putInt(DIMENSION_INDEX_KEY, dimensionIndex);
        }
    }
    @Override
    public NbtCompound toInitialChunkDataNbt(RegistryWrapper.WrapperLookup registries) {
        NbtCompound tag = super.toInitialChunkDataNbt(registries);
        if (dimensionIndex != null) {
            tag.putInt(DIMENSION_INDEX_KEY, dimensionIndex);
        }
        return tag;
    }
    public void handleEntityCollision(Entity entity) {
        if (!(world instanceof ServerWorld serverWorld)) return;
        if (!entity.canUsePortals(false)) return;
        if (dimensionIndex == null) {
            PocketPortals.LOGGER.warn("Portal block has no dimension index assigned!");
            return;
        }
        if (entity.hasPortalCooldown()) {
            return;
        }
        // Set portal cooldown (20 ticks = 1 second)
        entity.setPortalCooldown(20);
        // Get the target dimension
        ServerWorld targetWorld = serverWorld.getServer().getWorld(PocketDimensionsRegistry.getDimensionKey());
        if (targetWorld == null) {
            PocketPortals.LOGGER.error("Pocket dimension is not loaded!");
            return;
        }
        // Are we already in the pocket dimension?
        if (serverWorld.getRegistryKey().equals(PocketDimensionsRegistry.getDimensionKey())) {
            // Then go back to Overworld
            ServerWorld overworld = serverWorld.getServer().getOverworld();
            teleportEntity(entity, overworld, pos.getX() + 0.5, pos.getY() + 1, pos.getZ() + 0.5);
        } else {
            // Calculate grid position from index
            PocketPortals.LOGGER.info("Portal teleport: dimension index={}", dimensionIndex);
            ModDimensions.GridPosition gridPos = ModDimensions.indexToGridPosition(dimensionIndex);
            ModDimensions.WorldPosition worldPos = ModDimensions.gridToWorldPosition(gridPos);
            PocketPortals.LOGGER.info("Calculated positions: grid=({},{}), world=({},{},{})",
                    gridPos.x(), gridPos.z(),
                    worldPos.x(), worldPos.y(), worldPos.z());
            PocketPortals.LOGGER.info("Portal teleport details: index={}, targetWorld={}",
                    dimensionIndex, targetWorld.getRegistryKey().getValue());
            // Store the entry portal's exact position
            BlockPos entryPortalPos = pos.toImmutable();
            // Before the teleport:
            PocketPortals.LOGGER.info("About to teleport to: x={}, y={}, z={}",
                    worldPos.x() + 0.5, worldPos.y() + 1, worldPos.z() + 0.5);
            // Teleport to the specific grid location in the pocket dimension
            teleportEntity(entity, targetWorld,
                    worldPos.x() + 0.5, worldPos.y() + 10, worldPos.z() + 0.5);
            // Calculate target position for return portal
            BlockPos returnPortalPos = new BlockPos(worldPos.x() , worldPos.y() + 10, worldPos.z());
            prepareReturnPortalArea(targetWorld, returnPortalPos);
            // Create RETURN portal block with the correct state
            targetWorld.setBlockState(returnPortalPos,
                    ModBlocks.RETURN_POCKET_PORTAL.getDefaultState());
            targetWorld.setBlockState(returnPortalPos.up(),
                    ModBlocks.POCKET_PORTAL_FRAME.getDefaultState());
            targetWorld.setBlockState(returnPortalPos.up(2),
                    ModBlocks.POCKET_PORTAL_FRAME.getDefaultState());
            // Set up the return portal block entity
            BlockEntity be = targetWorld.getBlockEntity(returnPortalPos);
            if (be instanceof ReturnPocketPortalBlockEntity returnPortalBE) {
                // Store the exact entry portal position and dimension
                returnPortalBE.setReturnPosition(pos.toImmutable(), world.getRegistryKey());
                returnPortalBE.markDirty();
                PocketPortals.LOGGER.info("Created return portal at {} with destination {}, {}",
                        returnPortalPos, pos, world.getRegistryKey().getValue());
            } else {
                PocketPortals.LOGGER.error("Failed to initialize return portal block entity at {}",
                        returnPortalPos);
            }
        }
    }
    private void prepareReturnPortalArea(ServerWorld world, BlockPos portalPos) {
        // Clear space for portal and frame
        for (int y = 0; y < 3; y++) {
            BlockPos clearPos = portalPos.up(y);
            world.setBlockState(clearPos, Blocks.AIR.getDefaultState());
        }
        // Create small platform underneath
        for (int x = -1; x <= 1; x++) {
            for (int z = -1; z <= 1; z++) {
                BlockPos platformPos = portalPos.down().add(x, 0, z);
                world.setBlockState(platformPos, Blocks.STONE.getDefaultState());
            }
        }
    }
    private void teleportEntity(Entity entity, ServerWorld targetWorld, double x, double y, double z) {
        // Ensure the chunk is loaded before teleporting
        BlockPos.Mutable checkPos = new BlockPos.Mutable((int)x, (int)y, (int)z);
        targetWorld.getChunk(checkPos); // Force chunk load
        // Get the actual height from the chunk generator
        int surfaceHeight = targetWorld.getChunkManager()
                .getChunkGenerator()
                .getHeight(checkPos.getX(), checkPos.getZ(),
                        Heightmap.Type.MOTION_BLOCKING,
                        targetWorld,
                        targetWorld.getChunkManager().getNoiseConfig());
        // Set our check position to the surface height
        checkPos.set((int)x, surfaceHeight, (int)z);
        // Ensure chunk is loaded and blocks are initialized
        targetWorld.getChunk(checkPos);
        // Move up until we have 2 blocks of air clearance
        int attempts = 0;
        int maxAttempts = 10; // Prevent infinite loops
        while (attempts < maxAttempts &&
                checkPos.getY() < targetWorld.getTopYInclusive() - 2 &&
                (!isValidTeleportLocation(targetWorld, checkPos))) {
            checkPos.move(0, 1, 0);
            attempts++;
        }
        // If we couldn't find a safe spot, create one
        if (!isValidTeleportLocation(targetWorld, checkPos)) {
            createSafeTeleportLocation(targetWorld, checkPos);
        }
        // Teleport to the safe position we found
        entity.teleport(
                targetWorld,
                checkPos.getX() + 0.5,
                checkPos.getY(),
                checkPos.getZ() + 0.5,
                EnumSet.noneOf(PositionFlag.class),
                entity.getYaw(),
                entity.getPitch(),
                true
        );
    }
    private boolean isValidTeleportLocation(ServerWorld world, BlockPos pos) {
        return world.getBlockState(pos).isAir() &&
                world.getBlockState(pos.up()).isAir() &&
                !world.getBlockState(pos.down()).isAir();
    }
    private void createSafeTeleportLocation(ServerWorld world, BlockPos pos) {
        // Create a safe platform
        world.setBlockState(pos.down(), Blocks.STONE.getDefaultState());
        world.setBlockState(pos, Blocks.AIR.getDefaultState());
        world.setBlockState(pos.up(), Blocks.AIR.getDefaultState());
        // Add some surrounding blocks for safety
        for (int dx = -1; dx <= 1; dx++) {
            for (int dz = -1; dz <= 1; dz++) {
                if (dx != 0 || dz != 0) {
                    BlockPos platformPos = pos.down().add(dx, 0, dz);
                    if (world.getBlockState(platformPos).isAir()) {
                        world.setBlockState(platformPos, Blocks.STONE.getDefaultState());
                    }
                }
            }
        }
    }
    public void syncSpawnRules(PlayerEntity player) {
        if (dimensionIndex == null || !(player instanceof ServerPlayerEntity serverPlayer)) return;
        // Get spawn rules for this dimension index
        GridSpawnRules rules = PocketDimensionsRegistry.getSpawnRules(world.getServer(), dimensionIndex);
        if (rules == null) {
            PocketPortals.LOGGER.warn("Null spawnrules in portal block entity for index: {}", dimensionIndex);
            return;
        }
        // Create map of spawn rules
        Map<EntityType<?>, Boolean> spawnRules = new HashMap<>();
        // Add all managed mobs to the map
        for (EntityType<?> entityType : PocketDimensionsRegistry.MANAGED_MOBS) {
            spawnRules.put(entityType, rules.canSpawn(entityType));
        }
        // Create and send packet
        SpawnRulesPacket packet = new SpawnRulesPacket(dimensionIndex, spawnRules);
        ServerPlayNetworking.send(serverPlayer, packet);
//        PocketPortals.LOGGER.info("Sent spawnrules for dimension {} to player {}",
//                dimensionIndex, player.getName().getString());
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/block/PocketPortalFrame.java">
package ninja.trek.pocketportals.block;
import com.mojang.serialization.MapCodec;
import net.minecraft.block.Block;
import net.minecraft.block.BlockRenderType;
import net.minecraft.block.BlockState;
import net.minecraft.block.Blocks;
import net.minecraft.block.entity.BlockEntity;
import net.minecraft.entity.Entity;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.particle.ParticleTypes;
import net.minecraft.sound.SoundCategory;
import net.minecraft.sound.SoundEvents;
import net.minecraft.util.ActionResult;
import net.minecraft.util.Hand;
import net.minecraft.util.hit.BlockHitResult;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.random.Random;
import net.minecraft.text.Text;
import net.minecraft.world.World;
public class PocketPortalFrame extends Block {
    public static final MapCodec<PocketPortalFrame> CODEC = createCodec(PocketPortalFrame::new);
    public PocketPortalFrame(Settings settings) {
        super(validateSettings(settings));
    }
    private static Settings validateSettings(Settings settings) {
        if (settings == null) {
            throw new IllegalArgumentException("Settings cannot be null");
        }
        return settings;
    }
    @Override
    public void onEntityCollision(BlockState state, World world, BlockPos pos, Entity entity) {
        if (!world.isClient && entity.canUsePortals(false)) {
            // Find the portal base block by searching downward
            BlockPos basePos = findPortalBase(world, pos);
            if (basePos != null) {
                BlockEntity blockEntity = world.getBlockEntity(basePos);
                // Handle both types of portal bases
                if (blockEntity instanceof PocketPortalBlockEntity portalBlockEntity) {
                    portalBlockEntity.handleEntityCollision(entity);
                } else if (blockEntity instanceof ReturnPocketPortalBlockEntity returnPortalBlockEntity) {
                    returnPortalBlockEntity.handleEntityCollision(entity);
                }
            }
        }
    }
    /**
     * Allow sneak-right-click to show dimension info in chat.
     */
    @Override
    public ActionResult onUse(BlockState state, World world, BlockPos pos,
                              PlayerEntity player, BlockHitResult hit) {
        if (!world.isClient) {
            BlockPos basePos = findPortalBase(world, pos);
            if (basePos != null) {
                BlockEntity be = world.getBlockEntity(basePos);
                if (be instanceof PocketPortalBlockEntity portalBE) {
                    portalBE.syncSpawnRules(player);
                }
            }
        }
        return ActionResult.SUCCESS;
    }
    private BlockPos findPortalBase(World world, BlockPos startPos) {
        // Search downward for either type of portal base block
        BlockPos.Mutable currentPos = startPos.mutableCopy();
        for (int y = 0; y > -3; y--) {
            currentPos.move(0, y, 0);
            if (world.getBlockState(currentPos).getBlock() instanceof PocketPortalBlock ||
                    world.getBlockState(currentPos).getBlock() instanceof ReturnPocketPortalBlock) {
                return currentPos.toImmutable();
            }
        }
        return null;
    }
    @Override
    public void randomDisplayTick(BlockState state, World world, BlockPos pos, Random random) {
        if (random.nextInt(100) == 0) {
            world.playSound(
                    pos.getX() + 0.5D,
                    pos.getY() + 0.5D,
                    pos.getZ() + 0.5D,
                    SoundEvents.BLOCK_PORTAL_AMBIENT,
                    SoundCategory.BLOCKS,
                    0.5F,
                    random.nextFloat() * 0.4F + 0.8F,
                    false
            );
        }
        for(int i = 0; i < 4; ++i) {
            double x = pos.getX() + random.nextDouble();
            double y = pos.getY() + random.nextDouble();
            double z = pos.getZ() + random.nextDouble();
            double dx = (random.nextDouble() - 0.5D) * 0.5D;
            double dy = (random.nextDouble() - 0.5D) * 0.5D;
            double dz = (random.nextDouble() - 0.5D) * 0.5D;
            world.addParticle(ParticleTypes.PORTAL, x, y, z, dx, dy, dz);
        }
    }
    @Override
    public BlockRenderType getRenderType(BlockState state) {
        return BlockRenderType.MODEL;
    }
    @Override
    protected MapCodec<? extends Block> getCodec() {
        return CODEC;
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/block/ReturnPocketPortalBlock.java">
package ninja.trek.pocketportals.block;
import com.mojang.serialization.MapCodec;
import net.minecraft.block.BlockRenderType;
import net.minecraft.block.BlockState;
import net.minecraft.block.BlockWithEntity;
import net.minecraft.block.Blocks;
import net.minecraft.block.entity.BlockEntity;
import net.minecraft.entity.Entity;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.World;
import ninja.trek.pocketportals.PocketPortals;
import ninja.trek.pocketportals.block.ReturnPocketPortalBlockEntity;
import ninja.trek.pocketportals.dimension.PocketDimensionsRegistry;
public class ReturnPocketPortalBlock extends BlockWithEntity {
    public static final MapCodec<ReturnPocketPortalBlock> CODEC = createCodec(ReturnPocketPortalBlock::new);
    public ReturnPocketPortalBlock(Settings settings) {
        super(validateSettings(settings));
    }
    private static Settings validateSettings(Settings settings) {
        if (settings == null) {
            throw new IllegalArgumentException("Settings cannot be null");
        }
        return settings;
    }
    @Override
    protected MapCodec<? extends BlockWithEntity> getCodec() {
        return CODEC;
    }
    @Override
    public BlockRenderType getRenderType(BlockState state) {
        return BlockRenderType.MODEL;
    }
    @Override
    public BlockEntity createBlockEntity(BlockPos pos, BlockState state) {
        return new ReturnPocketPortalBlockEntity(pos, state);
    }
    @Override
    public void onEntityCollision(BlockState state, World world, BlockPos pos, Entity entity) {
        if (!world.isClient) {
            // Only handle collision if we're in the pocket dimension
            if (!world.getRegistryKey().equals(PocketDimensionsRegistry.getDimensionKey())) {
                return;
            }
            BlockEntity be = world.getBlockEntity(pos);
            if (be instanceof ReturnPocketPortalBlockEntity returnPortalBE) {
                // Add debug logging
                PocketPortals.LOGGER.info("Entity {} collided with return portal at {}",
                        entity.getUuidAsString(), pos);
                returnPortalBE.handleEntityCollision(entity);
            }
        }
    }
    @Override
    public void onStateReplaced(BlockState state, World world, BlockPos pos,
                                BlockState newState, boolean moved) {
        if (!state.isOf(newState.getBlock())) {
            // Remove frame blocks
            world.setBlockState(pos.up(), Blocks.AIR.getDefaultState());
            world.setBlockState(pos.up(2), Blocks.AIR.getDefaultState());
        }
        super.onStateReplaced(state, world, pos, newState, moved);
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/block/ReturnPocketPortalBlockEntity.java">
package ninja.trek.pocketportals.block;
import net.minecraft.block.BlockState;
import net.minecraft.block.entity.BlockEntity;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityType;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.nbt.NbtCompound;
import net.minecraft.network.packet.s2c.play.PositionFlag;
import net.minecraft.registry.RegistryKey;
import net.minecraft.registry.RegistryKeys;
import net.minecraft.registry.RegistryWrapper;
import net.minecraft.server.network.ServerPlayerEntity;
import net.minecraft.server.world.ServerWorld;
import net.minecraft.sound.SoundCategory;
import net.minecraft.sound.SoundEvents;
import net.minecraft.util.Identifier;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.World;
import ninja.trek.pocketportals.PocketPortals;
import ninja.trek.pocketportals.dimension.GridSpawnRules;
import ninja.trek.pocketportals.dimension.PocketDimensionsRegistry;
import ninja.trek.pocketportals.network.SpawnRulesPacket;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.Map;
public class ReturnPocketPortalBlockEntity extends BlockEntity {
    private static final String RETURN_POS_X = "ReturnPosX";
    private static final String RETURN_POS_Y = "ReturnPosY";
    private static final String RETURN_POS_Z = "ReturnPosZ";
    private static final String RETURN_DIMENSION = "ReturnDimension";
    private BlockPos returnPosition;
    private RegistryKey<World> returnDimension;
    public ReturnPocketPortalBlockEntity(BlockPos pos, BlockState state) {
        super(ModBlocks.RETURN_PORTAL_BLOCK_ENTITY, pos, state);
    }
    public void setReturnPosition(BlockPos pos, RegistryKey<World> dimension) {
        this.returnPosition = pos;
        this.returnDimension = dimension;
        markDirty();
        PocketPortals.LOGGER.info("Set return portal destination: pos={}, dim={}",
                pos, dimension.getValue());
    }
    @Override
    public void readNbt(NbtCompound nbt, RegistryWrapper.WrapperLookup lookup) {
        super.readNbt(nbt, lookup);
        if (nbt.contains(RETURN_POS_X)) {
            int x = nbt.getInt(RETURN_POS_X);
            int y = nbt.getInt(RETURN_POS_Y);
            int z = nbt.getInt(RETURN_POS_Z);
            returnPosition = new BlockPos(x, y, z);
            String dimId = nbt.getString(RETURN_DIMENSION);
            returnDimension = RegistryKey.of(RegistryKeys.WORLD, Identifier.of(dimId));
//            PocketPortals.LOGGER.info("Loaded return portal data: pos={}, dim={}",
//                    returnPosition, returnDimension.getValue());
        }
    }
    @Override
    public void writeNbt(NbtCompound nbt, RegistryWrapper.WrapperLookup lookup) {
        super.writeNbt(nbt, lookup);
        if (returnPosition != null && returnDimension != null) {
            nbt.putInt(RETURN_POS_X, returnPosition.getX());
            nbt.putInt(RETURN_POS_Y, returnPosition.getY());
            nbt.putInt(RETURN_POS_Z, returnPosition.getZ());
            nbt.putString(RETURN_DIMENSION, returnDimension.getValue().toString());
//            PocketPortals.LOGGER.info("Saved return portal data: pos={}, dim={}",
//                    returnPosition, returnDimension.getValue());
        }
    }
    private BlockPos findSafeReturnLocation(ServerWorld targetWorld, BlockPos originalPos) {
        // First check if the original position still has a portal
        if (targetWorld.getBlockState(originalPos).isOf(ModBlocks.POCKET_PORTAL)) {
            // Portal is still there, use it!
            PocketPortals.LOGGER.info("Original portal found at {}, using it", originalPos);
            return originalPos;
        }
        // If portal is gone, start looking for safe spots
        if (isSafeSpot(targetWorld, originalPos)) {
            PocketPortals.LOGGER.info("Original position {} is safe, using it", originalPos);
            return originalPos;
        }
        BlockPos.Mutable checkPos = originalPos.mutableCopy();
        // First search near the original Y level (within ±2 blocks)
        for (int y = -2; y <= 2; y++) {
            checkPos.setY(originalPos.getY() + y);
            if (isSafeSpot(targetWorld, checkPos)) {
                PocketPortals.LOGGER.info("Found safe spot near original Y: {}", checkPos);
                return checkPos.toImmutable();
            }
        }
        // If that fails, search more extensively around the original Y
        int searchRadius = 10;
        // Search downward from original Y
        for (int y = originalPos.getY() - 3; y >= Math.max(targetWorld.getBottomY(), originalPos.getY() - searchRadius); y--) {
            checkPos.setY(y);
            if (isSafeSpot(targetWorld, checkPos)) {
                PocketPortals.LOGGER.info("Found safe spot below: {}", checkPos);
                return checkPos.toImmutable();
            }
        }
        // Then search upward from original Y
        for (int y = originalPos.getY() + 3; y <= Math.min(targetWorld.getTopYInclusive() - 2, originalPos.getY() + searchRadius); y++) {
            checkPos.setY(y);
            if (isSafeSpot(targetWorld, checkPos)) {
                PocketPortals.LOGGER.info("Found safe spot above: {}", checkPos);
                return checkPos.toImmutable();
            }
        }
        // If still no safe spot, find highest solid block below original position
        checkPos = originalPos.mutableCopy();
        for (int y = originalPos.getY(); y >= targetWorld.getBottomY(); y--) {
            checkPos.setY(y);
            if (targetWorld.getBlockState(checkPos).isSolid()) {
                BlockPos safePos = checkPos.up().toImmutable();
                PocketPortals.LOGGER.info("Using highest solid block method, found: {}", safePos);
                return safePos;
            }
        }
        // Absolute last resort - go to original Y but ensure there's air
        BlockPos lastResort = new BlockPos(originalPos.getX(), originalPos.getY(), originalPos.getZ());
        targetWorld.setBlockState(lastResort, net.minecraft.block.Blocks.AIR.getDefaultState());
        targetWorld.setBlockState(lastResort.up(), net.minecraft.block.Blocks.AIR.getDefaultState());
        PocketPortals.LOGGER.warn("Using last resort position: {}", lastResort);
        return lastResort;
    }
    private boolean isSafeSpot(ServerWorld world, BlockPos pos) {
        // Check for portal blocks and frames - we don't want to spawn inside these
        // unless it's our original portal (which is checked separately)
        if (world.getBlockState(pos).isOf(ModBlocks.POCKET_PORTAL_FRAME) ||
                world.getBlockState(pos.up()).isOf(ModBlocks.POCKET_PORTAL_FRAME) ||
                world.getBlockState(pos).isOf(ModBlocks.POCKET_PORTAL) ||
                world.getBlockState(pos.up()).isOf(ModBlocks.POCKET_PORTAL)) {
            return false;
        }
        // Must have two air blocks for player height
        if (!world.getBlockState(pos).isAir() || !world.getBlockState(pos.up()).isAir()) {
            return false;
        }
        // Must have solid ground below
        BlockPos groundPos = pos.down();
        return world.getBlockState(groundPos).isSolid() ||
                world.getBlockState(groundPos).blocksMovement();
    }
    public void handleEntityCollision(Entity entity) {
        if (!(world instanceof ServerWorld serverWorld)) {
            PocketPortals.LOGGER.error("Return portal not in server world!");
            return;
        }
        if (!entity.canUsePortals(false)) {
            PocketPortals.LOGGER.debug("Entity cannot use portals: {}", entity);
            return;
        }
        if (returnPosition == null || returnDimension == null) {
            PocketPortals.LOGGER.error("Return portal missing destination data: pos={}, dim={}",
                    returnPosition, returnDimension);
            return;
        }
        // Get the target world
        ServerWorld targetWorld = serverWorld.getServer().getWorld(returnDimension);
        if (targetWorld == null) {
            PocketPortals.LOGGER.error("Target world not found: {}", returnDimension.getValue());
            return;
        }
        // Find a safe return location (prioritizing original portal)
        BlockPos safePos = findSafeReturnLocation(targetWorld, returnPosition);
//        PocketPortals.LOGGER.info("Found safe return location: {} (original was {})",
//                safePos, returnPosition);
        // Only apply cooldown if teleport is successful
        if (entity.hasPortalCooldown()) {
//            PocketPortals.LOGGER.debug("Entity {} has portal cooldown", entity.getUuidAsString());
            return;
        }
        // Calculate target position
        double targetX = safePos.getX() + 0.5;
        double targetY = safePos.getY();
        double targetZ = safePos.getZ() + 0.5;
        // If returning to original portal, adjust Y position to be inside the portal
        if (targetWorld.getBlockState(safePos).isOf(ModBlocks.POCKET_PORTAL)) {
            targetY += 0.5; // Position entity in middle of portal block
        }
        // Reduced cooldown from 1000 to 100 ticks (5 seconds)
        entity.setPortalCooldown(100);
        // Perform the teleport
        boolean success = entity.teleport(
                targetWorld,
                targetX,
                targetY,
                targetZ,
                EnumSet.noneOf(PositionFlag.class),
                entity.getYaw(),
                entity.getPitch(),
                true
        );
        if (success) {
            // Play portal sound
            world.playSound(null, pos,
                    SoundEvents.BLOCK_PORTAL_TRAVEL,
                    SoundCategory.BLOCKS,
                    0.25f,
                    1.0f);
            PocketPortals.LOGGER.info("Successfully teleported entity {} to {}",
                    entity.getUuidAsString(), safePos);
        } else {
            PocketPortals.LOGGER.error("Failed to teleport entity {} to {}",
                    entity.getUuidAsString(), safePos);
        }
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/data/DataLoader.java">
package ninja.trek.pocketportals.data;
import net.fabricmc.fabric.api.resource.ResourceManagerHelper;
import net.fabricmc.fabric.api.resource.SimpleSynchronousResourceReloadListener;
import net.minecraft.resource.ResourceManager;
import net.minecraft.resource.ResourceType;
import net.minecraft.util.Identifier;
import ninja.trek.pocketportals.PocketPortals;
public class DataLoader {
    public static void register() {
        ResourceManagerHelper.get(ResourceType.SERVER_DATA).registerReloadListener(
                new SimpleSynchronousResourceReloadListener() {
                    @Override
                    public Identifier getFabricId() {
                        return Identifier.of(PocketPortals.MOD_ID, "dimension_loader");
                    }
                    @Override
                    public void reload(ResourceManager manager) {
                        // Check for dimension type file
                        Identifier dimTypeId = Identifier.of(PocketPortals.MOD_ID, "dimension_type/pocket_dimension_type.json");
                        if (manager.getResource(dimTypeId).isPresent()) {
                            PocketPortals.LOGGER.info("Found pocket dimension type configuration");
                        } else {
                            PocketPortals.LOGGER.error("Missing pocket dimension type configuration at {}", dimTypeId);
                        }
                        // Check for dimension file
                        Identifier dimId = Identifier.of(PocketPortals.MOD_ID, "dimension/pocket_dimension.json");
                        if (manager.getResource(dimId).isPresent()) {
                            PocketPortals.LOGGER.info("Found pocket dimension configuration");
                        } else {
                            PocketPortals.LOGGER.error("Missing pocket dimension configuration at {}", dimId);
                        }
                    }
                }
        );
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/data/PocketPortalDataTypes.java">
package ninja.trek.pocketportals.data;
import com.mojang.serialization.Codec;
import net.minecraft.component.ComponentType;
import net.minecraft.network.RegistryByteBuf;
import net.minecraft.network.codec.PacketCodec;
import net.minecraft.util.Identifier;
/**
 * Defines a custom ComponentType<Integer> for storing a dimension index
 * in an item or block entity, using Minecraft 1.21's new item component system.
 */
public final class PocketPortalDataTypes {
    /**
     * Our custom component type that stores an Integer (dimension index).
     *
     * - Codec: Handles saving/loading from NBT and JSON.
     * - PacketCodec: Handles network sync and serialization.
     */
    public static final ComponentType<Integer> DIMENSION_INDEX = new ComponentType.Builder<Integer>()
            .codec(Codec.INT) // Set up codec for serialization
            .packetCodec(new PacketCodec<RegistryByteBuf, Integer>() {
                @Override
                public Integer decode(RegistryByteBuf buf) {
                    return buf.readVarInt(); // Read the dimension index from the network buffer
                }
                @Override
                public void encode(RegistryByteBuf buf, Integer value) {
                    buf.writeVarInt(value); // Write the dimension index to the network buffer
                }
            })
            .build(); // Build the ComponentType
    // Prevent instantiation
    private PocketPortalDataTypes() {}
}
</file>

<file path="main/java/ninja/trek/pocketportals/dimension/GridBiomeSource.java">
package ninja.trek.pocketportals.dimension;
import com.mojang.serialization.Codec;
import com.mojang.serialization.MapCodec;
import com.mojang.serialization.codecs.RecordCodecBuilder;
import net.minecraft.registry.Registry;
import net.minecraft.registry.RegistryKeys;
import net.minecraft.registry.entry.RegistryEntry;
import net.minecraft.util.Identifier;
import net.minecraft.util.math.random.Random;
import net.minecraft.world.biome.Biome;
import net.minecraft.world.biome.BiomeKeys;
import net.minecraft.world.biome.source.BiomeSource;
import net.minecraft.world.biome.source.util.MultiNoiseUtil;
import ninja.trek.pocketportals.PocketPortals;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.stream.Stream;
public class GridBiomeSource extends BiomeSource {
    private final long seed;
    private Registry<Biome> biomeRegistry;
    private final List<RegistryEntry<Biome>> biomes;
    private RegistryEntry<Biome> fallbackBiome;
    public static final MapCodec<GridBiomeSource> CODEC = RecordCodecBuilder.mapCodec(instance ->
            instance.group(
                    Codec.LONG.fieldOf("seed").stable().forGetter(source -> source.seed)
            ).apply(instance, GridBiomeSource::new));
    public GridBiomeSource(long seed) {
        this.seed = seed;
        this.biomes = new CopyOnWriteArrayList<>(); // Thread-safe list
    }
    @Override
    protected MapCodec<? extends BiomeSource> getCodec() {
        return CODEC;
    }
    @Override
    public RegistryEntry<Biome> getBiome(int x, int z, int y, MultiNoiseUtil.MultiNoiseSampler noise) {
        initializeBiomesIfNeeded();
        if (biomes.isEmpty()) {
            return getFallbackBiome();
        }
        // x and z are already in quarter-block coordinates (divided by 4)
        // Convert to block coordinates properly
        int blockX = x * 4;
        int blockZ = z * 4;
        // Calculate grid position
        // Note: Using Math.floorDiv to handle negative numbers correctly
        int gridX = Math.floorDiv(blockX, ModDimensions.GRID_SPACING) + (ModDimensions.GRID_SIZE / 2);
        int gridZ = Math.floorDiv(blockZ, ModDimensions.GRID_SPACING) + (ModDimensions.GRID_SIZE / 2);
        // Calculate dimension index
        int dimensionIndex = gridX + (gridZ * ModDimensions.GRID_SIZE);
        // Create a deterministic but varied selection based on position and seed
        int uniqueSeed = (int)(seed + dimensionIndex);
        int hash = (gridX * 31183 + gridZ * 27917) ^ uniqueSeed;
        var random = Random.create(hash);
        // Select a biome based on the hash
        int index = random.nextInt(biomes.size());
        return biomes.get(index);
    }
    private RegistryEntry<Biome> getFallbackBiome() {
        if (fallbackBiome == null && biomeRegistry != null) {
            // Try to get plains biome
            var plainsId = BiomeKeys.PLAINS.getValue();
            if (biomeRegistry.containsId(plainsId)) {
                var plainsBiome = biomeRegistry.get(plainsId);
                if (plainsBiome != null) {
                    fallbackBiome = biomeRegistry.getEntry(plainsBiome);
                }
            }
            // If plains isn't available, use the first biome in the registry
            if (fallbackBiome == null) {
                var firstEntry = biomeRegistry.getEntrySet().stream().findFirst();
                if (firstEntry.isPresent()) {
                    fallbackBiome = biomeRegistry.getEntry(firstEntry.get().getValue());
                }
            }
        }
        return fallbackBiome;
    }
    @Override
    public Stream<RegistryEntry<Biome>> biomeStream() {
        initializeBiomesIfNeeded();
        return biomes.stream();
    }
    private synchronized void initializeBiomesIfNeeded() {
        if (biomeRegistry == null || biomes.isEmpty()) {
            var server = PocketPortals.getServer();
            if (server == null) {
                PocketPortals.LOGGER.warn("Server not yet available for biome initialization");
                return;
            }
            var overworld = server.getOverworld();
            if (overworld == null) {
                PocketPortals.LOGGER.warn("Overworld not yet available for biome initialization");
                return;
            }
            biomeRegistry = overworld.getRegistryManager().getOrThrow(RegistryKeys.BIOME);
            if (biomeRegistry != null) {
                populateBiomes();
            }
        }
    }
    private synchronized void populateBiomes() {
        if (biomeRegistry == null) {
            PocketPortals.LOGGER.warn("Null biome registry");
            return;
        }
        biomes.clear();
        List<RegistryEntry<Biome>> tempBiomes = new ArrayList<>();
        // Add all valid overworld biomes to temporary list first
        biomeRegistry.getEntrySet().forEach(entry -> {
            if (isValidOverworldBiome(entry.getKey().getValue())) {
                tempBiomes.add(biomeRegistry.getEntry(entry.getValue()));
            }
        });
        // If no valid biomes found, add plains as fallback
        if (tempBiomes.isEmpty()) {
            PocketPortals.LOGGER.warn("No valid overworld biomes found, adding plains as fallback");
            var plainsId = BiomeKeys.PLAINS.getValue();
            if (biomeRegistry.containsId(plainsId)) {
                var plainsBiome = biomeRegistry.get(plainsId);
                if (plainsBiome != null) {
                    tempBiomes.add(biomeRegistry.getEntry(plainsBiome));
                }
            }
        }
        // Now safely add all biomes to our thread-safe list
        biomes.addAll(tempBiomes);
    }
    private boolean isValidOverworldBiome(Identifier id) {
        String path = id.getPath();
        return !path.contains("end") &&
                !path.contains("nether") &&
                !path.contains("basalt") &&
                !path.contains("void") &&
                !path.contains("small") &&
                !path.startsWith("debug_") &&
                !path.equals("custom");
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/dimension/GridSpawnRules.java">
package ninja.trek.pocketportals.dimension;
import net.minecraft.entity.EntityType;
import net.minecraft.nbt.NbtCompound;
import net.minecraft.nbt.NbtList;
import net.minecraft.registry.Registries;
import net.minecraft.util.Identifier;
import java.util.HashMap;
import java.util.Map;
public class GridSpawnRules {
    private final int gridIndex;
    private final Map<EntityType<?>, Boolean> spawnRules;
    public GridSpawnRules(int gridIndex) {
        this.gridIndex = gridIndex;
        this.spawnRules = new HashMap<>();
        // Default to allowing all standard hostile mobs
        setDefaultRules();
    }
    private void setDefaultRules() {
        // Allow common hostile mobs by default
        spawnRules.put(EntityType.ZOMBIE, true);
        spawnRules.put(EntityType.SKELETON, true);
        spawnRules.put(EntityType.SPIDER, true);
        spawnRules.put(EntityType.CREEPER, true);
        spawnRules.put(EntityType.ENDERMAN, true);
        spawnRules.put(EntityType.WITCH, true);
        spawnRules.put(EntityType.PHANTOM, true);
        spawnRules.put(EntityType.SLIME, true);
    }
    public boolean canSpawn(EntityType<?> entityType) {
        return spawnRules.getOrDefault(entityType, true);
    }
    public void setSpawnRule(EntityType<?> entityType, boolean allowed) {
        spawnRules.put(entityType, allowed);
    }
    public NbtCompound writeNbt() {
        NbtCompound nbt = new NbtCompound();
        nbt.putInt("GridIndex", gridIndex);
        NbtList rulesList = new NbtList();
        spawnRules.forEach((entityType, allowed) -> {
            NbtCompound ruleNbt = new NbtCompound();
            ruleNbt.putString("EntityType", Registries.ENTITY_TYPE.getId(entityType).toString());
            ruleNbt.putBoolean("Allowed", allowed);
            rulesList.add(ruleNbt);
        });
        nbt.put("SpawnRules", rulesList);
        return nbt;
    }
    public static GridSpawnRules fromNbt(NbtCompound nbt) {
        int gridIndex = nbt.getInt("GridIndex");
        GridSpawnRules rules = new GridSpawnRules(gridIndex);
        NbtList rulesList = nbt.getList("SpawnRules", 10); // 10 is the NBT type for compound tags
        rulesList.forEach(element -> {
            NbtCompound ruleNbt = (NbtCompound) element;
            EntityType<?> entityType = Registries.ENTITY_TYPE.get(
                    Identifier.tryParse(ruleNbt.getString("EntityType")));
            boolean allowed = ruleNbt.getBoolean("Allowed");
            rules.setSpawnRule(entityType, allowed);
        });
        return rules;
    }
    public int getGridIndex() {
        return gridIndex;
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/dimension/ModDimensions.java">
package ninja.trek.pocketportals.dimension;
import com.mojang.serialization.Codec;
import com.mojang.serialization.MapCodec;
import net.minecraft.registry.Registry;
import net.minecraft.registry.Registries;
import net.minecraft.registry.RegistryKey;
import net.minecraft.util.Identifier;
import net.minecraft.world.biome.source.BiomeSource;
import net.minecraft.world.gen.chunk.ChunkGenerator;
import ninja.trek.pocketportals.PocketPortals;
public class ModDimensions {
    public static final int GRID_SPACING = 100_000; // Blocks between each portal location
    public static final int GRID_SIZE = 600; // 600x600 grid
    public static void register() {
        // Register chunk generator - this works fine
        Registry.register(
                Registries.CHUNK_GENERATOR,
                Identifier.of(PocketPortals.MOD_ID, "sky_island"),
                SkyIslandChunkGenerator.CODEC
        );
        // Get the proper registry type for biome source
        Registry<MapCodec<? extends BiomeSource>> biomeSourceRegistry =
                (Registry<MapCodec<? extends BiomeSource>>)(Registry<?>) Registries.BIOME_SOURCE;
        // Convert GridBiomeSource.CODEC to MapCodec
        MapCodec<GridBiomeSource> biomeSourceMapCodec = GridBiomeSource.CODEC;
        Registry.register(
                biomeSourceRegistry,
                Identifier.of(PocketPortals.MOD_ID, "grid_biome_source"),
                biomeSourceMapCodec
        );
    }
    /**
     * Convert a dimension index (0-359999) to grid coordinates
     */
    public static GridPosition indexToGridPosition(int index) {
        if (index < 0 || index >= GRID_SIZE * GRID_SIZE) {
            throw new IllegalArgumentException("Index out of bounds: " + index);
        }
        int x = index % GRID_SIZE;
        int z = index / GRID_SIZE;
        return new GridPosition(x, z);
    }
    /**
     * Convert grid coordinates to world coordinates
     */
    public static WorldPosition gridToWorldPosition(GridPosition grid) {
        int worldX = (grid.x() - (GRID_SIZE / 2)) * GRID_SPACING + 50_000;
        int worldZ = (grid.z() - (GRID_SIZE / 2)) * GRID_SPACING + 50_000;
        PocketPortals.LOGGER.info("Converting grid ({},{}) to world ({},{},64)",
                grid.x(), grid.z(), worldX, worldZ);
        return new WorldPosition(worldX, 64, worldZ);
    }
    public record GridPosition(int x, int z) {}
    public record WorldPosition(int x, int y, int z) {}
}
</file>

<file path="main/java/ninja/trek/pocketportals/dimension/PocketDimensionJsonProvider.java">
package ninja.trek.pocketportals.dimension;
import com.google.gson.JsonObject;
import net.fabricmc.fabric.api.datagen.v1.FabricDataOutput;
import net.minecraft.data.DataProvider;
import net.minecraft.data.DataWriter;
import net.minecraft.util.Identifier;
import ninja.trek.pocketportals.PocketPortals;
import java.util.concurrent.CompletableFuture;
public class PocketDimensionJsonProvider implements DataProvider {
    private final FabricDataOutput output;
    private static final long DIMENSION_SEED = new java.util.Random().nextLong(); // Changed from 12345678L
    public PocketDimensionJsonProvider(FabricDataOutput output) {
        this.output = output;
    }
    @Override
    public CompletableFuture<?> run(DataWriter writer) {
        // Generate both files concurrently
        return CompletableFuture.allOf(
                generateDimensionType(writer),
                generateDimension(writer)
        );
    }
    private CompletableFuture<?> generateDimensionType(DataWriter writer) {
        JsonObject typeJson = new JsonObject();
        // Configure dimension type properties
        typeJson.addProperty("ultrawarm", false);
        typeJson.addProperty("natural", true);
        typeJson.addProperty("coordinate_scale", 1.0);
        typeJson.addProperty("has_skylight", true);
        typeJson.addProperty("has_ceiling", false);
        typeJson.addProperty("ambient_light", 0.0);
        typeJson.addProperty("fixed_time", 6000L);
        typeJson.addProperty("piglin_safe", false);
        typeJson.addProperty("bed_works", true);
        typeJson.addProperty("respawn_anchor_works", false);
        typeJson.addProperty("has_raids", false);
        typeJson.addProperty("logical_height", 384);
        typeJson.addProperty("min_y", -64);
        typeJson.addProperty("height", 384);
        typeJson.addProperty("infiniburn", "#minecraft:infiniburn_overworld");
        typeJson.addProperty("effects", "minecraft:overworld");
        typeJson.addProperty("monster_spawn_light_level", 0);
        typeJson.addProperty("monster_spawn_block_light_limit", 0);
        return DataProvider.writeToPath(
                writer,
                typeJson,
                output.getPath()
                        .resolve("data")
                        .resolve(PocketPortals.MOD_ID)
                        .resolve("dimension_type")
                        .resolve("pocket_dimension_type.json")
        );
    }
    private CompletableFuture<?> generateDimension(DataWriter writer) {
        JsonObject dimensionJson = new JsonObject();
        // Set dimension type reference
        dimensionJson.addProperty("type", PocketPortals.MOD_ID + ":pocket_dimension_type");
        // Configure generator
        JsonObject generator = new JsonObject();
        generator.addProperty("type", PocketPortals.MOD_ID + ":sky_island");
        generator.addProperty("seed", DIMENSION_SEED);
        generator.addProperty("settings", "minecraft:overworld");
        // Configure biome source
        JsonObject biomeSource = new JsonObject();
        biomeSource.addProperty("type", PocketPortals.MOD_ID + ":grid_biome_source");
        biomeSource.addProperty("seed", DIMENSION_SEED);
        // Add biome source to generator
        generator.add("biome_source", biomeSource);
        // Add generator to dimension
        dimensionJson.add("generator", generator);
        return DataProvider.writeToPath(
                writer,
                dimensionJson,
                output.getPath()
                        .resolve("data")
                        .resolve(PocketPortals.MOD_ID)
                        .resolve("dimension")
                        .resolve("pocket_dimension.json")
        );
    }
    @Override
    public String getName() {
        return "Pocket Dimension Configurations";
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/dimension/PocketDimensionsRegistry.java">
package ninja.trek.pocketportals.dimension;
import net.fabricmc.fabric.api.event.lifecycle.v1.ServerLifecycleEvents;
import net.minecraft.entity.EntityType;
import net.minecraft.nbt.NbtCompound;
import net.minecraft.nbt.NbtList;
import net.minecraft.registry.RegistryKey;
import net.minecraft.registry.RegistryKeys;
import net.minecraft.registry.RegistryWrapper;
import net.minecraft.server.MinecraftServer;
import net.minecraft.util.Identifier;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.PersistentState;
import net.minecraft.world.World;
import ninja.trek.pocketportals.PocketPortals;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;
import java.util.List;
import java.util.Arrays;
public class PocketDimensionsRegistry extends PersistentState {
    private static final String NEXT_INDEX_KEY = "NextPortalIndex";
    private static final String SPAWN_RULES_KEY = "SpawnRules";
    private static int nextAvailableIndex = 0;
    private final Map<Integer, GridSpawnRules> spawnRules = new HashMap<>();
    // List of common hostile mobs that we'll manage spawn rules for
    public static final List<EntityType<?>> MANAGED_MOBS = Arrays.asList(
            EntityType.ZOMBIE,
            EntityType.SKELETON,
            EntityType.SPIDER,
            EntityType.CREEPER,
            EntityType.ENDERMAN,
            EntityType.WITCH,
            EntityType.PHANTOM,
            EntityType.SLIME
    );
    public static GridSpawnRules getSpawnRules(MinecraftServer server, int index) {
        PocketDimensionsRegistry state = getState(server);
        if (state == null) return null;
        // Get or create rules for this index
        GridSpawnRules rules = state.spawnRules.get(index);
        if (rules == null) {
            rules = new GridSpawnRules(index);
            setRandomSpawnRules(rules);
            state.spawnRules.put(index, rules);
            state.markDirty();
        }
        return rules;
    }
    private static final Type<PocketDimensionsRegistry> TYPE = new Type<>(
            PocketDimensionsRegistry::new,
            (nbt, lookup) -> createFromNbt(nbt, lookup),
            null
    );
    private static final RegistryKey<World> DIMENSION_KEY = RegistryKey.of(
            RegistryKeys.WORLD,
            Identifier.of(PocketPortals.MOD_ID, "pocket_dimension")
    );
    public PocketDimensionsRegistry() {
        super();
    }
    @Override
    public NbtCompound writeNbt(NbtCompound nbt, RegistryWrapper.WrapperLookup registryLookup) {
        nbt.putInt(NEXT_INDEX_KEY, nextAvailableIndex);
        NbtList rulesNbt = new NbtList();
        spawnRules.values().forEach(rules -> {
            rulesNbt.add(rules.writeNbt());
        });
        nbt.put(SPAWN_RULES_KEY, rulesNbt);
        return nbt;
    }
    public static PocketDimensionsRegistry createFromNbt(NbtCompound nbt, RegistryWrapper.WrapperLookup lookup) {
        PocketDimensionsRegistry state = new PocketDimensionsRegistry();
        nextAvailableIndex = nbt.getInt(NEXT_INDEX_KEY);
        if (nbt.contains(SPAWN_RULES_KEY)) {
            NbtList rulesNbt = nbt.getList(SPAWN_RULES_KEY, 10);
            rulesNbt.forEach(element -> {
                GridSpawnRules rules = GridSpawnRules.fromNbt((NbtCompound) element);
                state.spawnRules.put(rules.getGridIndex(), rules);
            });
        }
        return state;
    }
    private static PocketDimensionsRegistry getState(MinecraftServer server) {
        if (server.getOverworld() == null) {
            PocketPortals.LOGGER.warn("Tried to access persistent state before overworld was loaded!");
            return null;
        }
        return server.getOverworld().getPersistentStateManager()
                .getOrCreate(TYPE, PocketPortals.MOD_ID + "_registry");
    }
    private static void setRandomSpawnRules(GridSpawnRules rules) {
        Random random = new Random();
        int randomType = random.nextInt(4); // 0-3
        if (randomType == 0) {
            // 25% chance: Fully peaceful
//            PocketPortals.LOGGER.info("Creating peaceful dimension space");
            MANAGED_MOBS.forEach(mob -> rules.setSpawnRule(mob, false));
        }
        else if (randomType == 1) {
            // 25% chance: Fully hostile
//            PocketPortals.LOGGER.info("Creating hostile dimension space");
            MANAGED_MOBS.forEach(mob -> rules.setSpawnRule(mob, true));
        }
        else {
            // 50% chance: Random for each mob
//            PocketPortals.LOGGER.info("Creating mixed dimension space");
            MANAGED_MOBS.forEach(mob -> {
                boolean allowed = random.nextBoolean();
                rules.setSpawnRule(mob, allowed);
//                PocketPortals.LOGGER.debug("Set spawn rule for {}: {}", mob, allowed);
            });
        }
    }
    public static synchronized int findUnusedSlot(MinecraftServer server) {
        PocketDimensionsRegistry state = getState(server);
        if (state == null) {
            int index = nextAvailableIndex;
            nextAvailableIndex = (nextAvailableIndex + 1) % (ModDimensions.GRID_SIZE * ModDimensions.GRID_SIZE);
            return index;
        }
        int nextIndex = nextAvailableIndex;
        nextAvailableIndex = (nextAvailableIndex + 1) % (ModDimensions.GRID_SIZE * ModDimensions.GRID_SIZE);
        // Create new GridSpawnRules with random configuration
        GridSpawnRules rules = new GridSpawnRules(nextIndex);
        setRandomSpawnRules(rules);
        state.spawnRules.put(nextIndex, rules);
        state.markDirty();
        return nextIndex;
    }
    public static void init() {
        ServerLifecycleEvents.SERVER_STARTED.register(server -> {
            getState(server);
        });
    }
    public static RegistryKey<World> getDimensionKey() {
        return DIMENSION_KEY;
    }
    public static boolean canMobSpawn(MinecraftServer server, BlockPos pos, EntityType<?> entityType) {
        PocketDimensionsRegistry state = getState(server);
        if (state == null) return true;
        int gridX = Math.floorDiv(pos.getX(), ModDimensions.GRID_SPACING);
        int gridZ = Math.floorDiv(pos.getZ(), ModDimensions.GRID_SPACING);
        int index = gridX + (gridZ * ModDimensions.GRID_SIZE);
        GridSpawnRules rules = state.spawnRules.get(index);
        if (rules == null) {
            rules = new GridSpawnRules(index);
            setRandomSpawnRules(rules);
            state.spawnRules.put(index, rules);
            state.markDirty();
        }
        return rules.canSpawn(entityType);
    }
    public static void setMobSpawnRule(MinecraftServer server, int gridIndex,
                                       EntityType<?> entityType, boolean allowed) {
        PocketDimensionsRegistry state = getState(server);
        if (state == null) return;
        GridSpawnRules rules = state.spawnRules.computeIfAbsent(gridIndex,
                GridSpawnRules::new);
        rules.setSpawnRule(entityType, allowed);
        state.markDirty();
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/dimension/SkyIslandChunkGenerator.java">
package ninja.trek.pocketportals.dimension;
import com.mojang.serialization.MapCodec;
import com.mojang.serialization.codecs.RecordCodecBuilder;
import net.minecraft.block.BlockState;
import net.minecraft.block.Blocks;
import net.minecraft.registry.entry.RegistryEntry;
import net.minecraft.registry.entry.RegistryEntryList;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.noise.PerlinNoiseSampler;
import net.minecraft.util.math.random.Random;
import net.minecraft.world.ChunkRegion;
import net.minecraft.world.HeightLimitView;
import net.minecraft.world.Heightmap;
import net.minecraft.world.biome.Biome;
import net.minecraft.world.biome.source.BiomeAccess;
import net.minecraft.world.biome.source.BiomeSource;
import net.minecraft.world.chunk.Chunk;
import net.minecraft.world.gen.StructureAccessor;
import net.minecraft.world.gen.chunk.Blender;
import net.minecraft.world.gen.chunk.ChunkGenerator;
import net.minecraft.world.gen.chunk.ChunkGeneratorSettings;
import net.minecraft.world.gen.chunk.VerticalBlockSample;
import net.minecraft.world.gen.feature.PlacedFeature;
import net.minecraft.world.gen.noise.NoiseConfig;
import ninja.trek.pocketportals.PocketPortals;
import ninja.trek.pocketportals.block.ModBlocks;
import java.util.List;
import java.util.concurrent.CompletableFuture;
public class SkyIslandChunkGenerator extends ChunkGenerator {
    private static final int ISLAND_RADIUS = 32; // Increased from 15
    private static final int BASE_HEIGHT = 64;
    private static final int ISLAND_HEIGHT = 12; // Reduced for flatter islands
    private static final double NOISE_SCALE = 0.1; // Controls the "bumpiness" of the terrain
    private static final double NOISE_AMPLITUDE = 4; // How much the noise affects height
    private PerlinNoiseSampler noiseSampler;
    public static final MapCodec<SkyIslandChunkGenerator> CODEC = RecordCodecBuilder.mapCodec(instance ->
            instance.group(
                    BiomeSource.CODEC.fieldOf("biome_source").forGetter(ChunkGenerator::getBiomeSource),
                    ChunkGeneratorSettings.REGISTRY_CODEC.fieldOf("settings").forGetter(generator -> generator.settings)
            ).apply(instance, SkyIslandChunkGenerator::new));
    private final RegistryEntry<ChunkGeneratorSettings> settings;
    public SkyIslandChunkGenerator(BiomeSource biomeSource, RegistryEntry<ChunkGeneratorSettings> settings) {
        super(biomeSource);
        this.settings = settings;
        // Initialize noise sampler with a random seed
        this.noiseSampler = new PerlinNoiseSampler(Random.create(1234));
    }
    @Override
    protected MapCodec<? extends ChunkGenerator> getCodec() {
        return CODEC;
    }
    @Override
    public void carve(ChunkRegion chunkRegion, long seed, NoiseConfig noiseConfig,
                      BiomeAccess biomeAccess, StructureAccessor structureAccessor, Chunk chunk) {
        // No carving needed
    }
    @Override
    public CompletableFuture<Chunk> populateNoise(Blender blender, NoiseConfig noiseConfig,
                                                  StructureAccessor structureAccessor, Chunk chunk) {
        int chunkX = chunk.getPos().x * 16;
        int chunkZ = chunk.getPos().z * 16;
        // Calculate grid position
        int gridX = Math.floorDiv(chunkX, ModDimensions.GRID_SPACING);
        int gridZ = Math.floorDiv(chunkZ, ModDimensions.GRID_SPACING);
        // Calculate center of current grid cell
        int centerX = (gridX * ModDimensions.GRID_SPACING) + (ModDimensions.GRID_SPACING / 2);
        int centerZ = (gridZ * ModDimensions.GRID_SPACING) + (ModDimensions.GRID_SPACING / 2);
        // For each block in the chunk
        for (int x = 0; x < 16; x++) {
            for (int z = 0; z < 16; z++) {
                int worldX = chunkX + x;
                int worldZ = chunkZ + z;
                // Calculate distance from center
                double dx = worldX - centerX;
                double dz = worldZ - centerZ;
                double distanceSquared = dx * dx + dz * dz;
                // If within radius, generate island
                if (distanceSquared <= ISLAND_RADIUS * ISLAND_RADIUS) {
                    // Calculate base height using smooth falloff
                    double normalizedDistance = Math.sqrt(distanceSquared) / ISLAND_RADIUS;
                    double falloff = 1 - Math.pow(normalizedDistance, 2);
                    // Add noise variation
                    double noise = noiseSampler.sample(
                            worldX * NOISE_SCALE,
                            0,
                            worldZ * NOISE_SCALE
                    ) * NOISE_AMPLITUDE;
                    // Calculate final height including noise
                    int height = (int) (ISLAND_HEIGHT * falloff + noise);
                    // Generate the island with more natural layers
                    for (int y = BASE_HEIGHT - height; y <= BASE_HEIGHT + height; y++) {
                        BlockPos pos = new BlockPos(x, y, z);
                        if (y == BASE_HEIGHT + height) {
                            chunk.setBlockState(pos, Blocks.GRASS_BLOCK.getDefaultState(), false);
                        } else if (y >= BASE_HEIGHT + height - 3) {
                            chunk.setBlockState(pos, Blocks.DIRT.getDefaultState(), false);
                        } else if (y >= BASE_HEIGHT + height - 5) {
                            chunk.setBlockState(pos,
                                    Random.create().nextBoolean() ?
                                            Blocks.DIRT.getDefaultState() :
                                            Blocks.STONE.getDefaultState(),
                                    false);
                        } else {
                            chunk.setBlockState(pos, Blocks.STONE.getDefaultState(), false);
                        }
                    }
                }
            }
        }
        return CompletableFuture.completedFuture(chunk);
    }
    @Override
    public void buildSurface(ChunkRegion region, StructureAccessor structures,
                             NoiseConfig noiseConfig, Chunk chunk) {
        // Surface building handled in populateNoise
    }
    @Override
    public void populateEntities(ChunkRegion region) {
        int chunkX = region.getCenterPos().x;
        int chunkZ = region.getCenterPos().z;
        Random random = Random.create(region.getSeed() + chunkX * 341873128712L + chunkZ * 132897987541L);
        // Calculate island center for this chunk's grid position
        int gridX = Math.floorDiv(chunkX * 16, ModDimensions.GRID_SPACING);
        int gridZ = Math.floorDiv(chunkZ * 16, ModDimensions.GRID_SPACING);
        int centerX = (gridX * ModDimensions.GRID_SPACING) + (ModDimensions.GRID_SPACING / 2);
        int centerZ = (gridZ * ModDimensions.GRID_SPACING) + (ModDimensions.GRID_SPACING / 2);
        // Get chunk bounds
        int startX = chunkX * 16;
        int startZ = chunkZ * 16;
        BlockPos.Mutable pos = new BlockPos.Mutable();
        for (int x = 0; x < 16; x++) {
            for (int z = 0; z < 16; z++) {
                int worldX = startX + x;
                int worldZ = startZ + z;
                double dx = worldX - centerX;
                double dz = worldZ - centerZ;
                double distanceSquared = dx * dx + dz * dz;
                // Only generate features within island radius (slightly smaller than terrain radius)
                if (distanceSquared <= (ISLAND_RADIUS - 4) * (ISLAND_RADIUS - 4)) {
                    int y = region.getTopY(Heightmap.Type.WORLD_SURFACE, worldX, worldZ);
                    pos.set(worldX, y, worldZ);
                    // Get biome and features for this position
                    RegistryEntry<Biome> biome = region.getBiome(pos);
                    var features = biome.value().getGenerationSettings().getFeatures();
                    // Generate features with adjusted probabilities
                    for (int step = 0; step < features.size(); step++) {
                        RegistryEntryList<PlacedFeature> stepFeatures = features.get(step);
                        for (RegistryEntry<PlacedFeature> feature : stepFeatures) {
                            // Adjust probability based on feature type and distance from center
                            float baseChance = step == 0 ? 0.2f : 0.2f;
                            float distanceMultiplier = (float) (1 - Math.sqrt(distanceSquared) / ISLAND_RADIUS);
                            if (random.nextFloat() < baseChance * distanceMultiplier) {
                                try {
                                    feature.value().generateUnregistered(region, this, random, pos);
                                } catch (Exception e) {
                                    PocketPortals.LOGGER.error(
                                            "Error placing feature at {}: {}",
                                            pos, e.getMessage());
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    @Override
    public int getHeight(int x, int z, Heightmap.Type heightmap, HeightLimitView world,
                         NoiseConfig noiseConfig) {
        int gridX = Math.floorDiv(x, ModDimensions.GRID_SPACING);
        int gridZ = Math.floorDiv(z, ModDimensions.GRID_SPACING);
        int centerX = (gridX * ModDimensions.GRID_SPACING) + (ModDimensions.GRID_SPACING / 2);
        int centerZ = (gridZ * ModDimensions.GRID_SPACING) + (ModDimensions.GRID_SPACING / 2);
        double dx = x - centerX;
        double dz = z - centerZ;
        double distanceSquared = dx * dx + dz * dz;
        if (distanceSquared <= ISLAND_RADIUS * ISLAND_RADIUS) {
            double normalizedDistance = Math.sqrt(distanceSquared) / ISLAND_RADIUS;
            double falloff = 1 - Math.pow(normalizedDistance, 2);
            double noise = noiseSampler.sample(x * NOISE_SCALE, 0, z * NOISE_SCALE) * NOISE_AMPLITUDE;
            int height = (int) (ISLAND_HEIGHT * falloff + noise);
            return BASE_HEIGHT + height + 1;
        }
        return world.getBottomY();
    }
    @Override
    public VerticalBlockSample getColumnSample(int x, int z, HeightLimitView world,
                                               NoiseConfig noiseConfig) {
        BlockState[] states = new BlockState[world.getHeight()];
        for (int y = 0; y < world.getHeight(); y++) {
            states[y] = Blocks.AIR.getDefaultState();
        }
        int gridX = Math.floorDiv(x, ModDimensions.GRID_SPACING);
        int gridZ = Math.floorDiv(z, ModDimensions.GRID_SPACING);
        int centerX = (gridX * ModDimensions.GRID_SPACING) + (ModDimensions.GRID_SPACING / 2);
        int centerZ = (gridZ * ModDimensions.GRID_SPACING) + (ModDimensions.GRID_SPACING / 2);
        double dx = x - centerX;
        double dz = z - centerZ;
        double distanceSquared = dx * dx + dz * dz;
        if (distanceSquared <= ISLAND_RADIUS * ISLAND_RADIUS) {
            double normalizedDistance = Math.sqrt(distanceSquared) / ISLAND_RADIUS;
            double falloff = 1 - Math.pow(normalizedDistance, 2);
            double noise = noiseSampler.sample(x * NOISE_SCALE, 0, z * NOISE_SCALE) * NOISE_AMPLITUDE;
            int height = (int) (ISLAND_HEIGHT * falloff + noise);
            for (int y = BASE_HEIGHT - height; y <= BASE_HEIGHT + height; y++) {
                int idx = y - world.getBottomY();
                if (idx >= 0 && idx < states.length) {
                    if (y == BASE_HEIGHT + height) {
                        states[idx] = Blocks.GRASS_BLOCK.getDefaultState();
                    } else if (y >= BASE_HEIGHT + height - 3) {
                        states[idx] = Blocks.DIRT.getDefaultState();
                    } else if (y >= BASE_HEIGHT + height - 5) {
                        states[idx] = Random.create().nextBoolean() ?
                                Blocks.DIRT.getDefaultState() :
                                Blocks.STONE.getDefaultState();
                    } else {
                        states[idx] = Blocks.STONE.getDefaultState();
                    }
                }
            }
        }
        return new VerticalBlockSample(world.getBottomY(), states);
    }
    @Override
    public int getWorldHeight() {
        return this.settings.value().generationShapeConfig().height();
    }
    @Override
    public int getSeaLevel() {
        return this.settings.value().seaLevel();
    }
    @Override
    public int getMinimumY() {
        return this.settings.value().generationShapeConfig().minimumY();
    }
    @Override
    public void appendDebugHudText(List<String> text, NoiseConfig noiseConfig, BlockPos pos) {
        // Add debug information if needed
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/item/ModItems.java">
package ninja.trek.pocketportals.item;
import net.minecraft.item.Item;
import net.minecraft.registry.Registries;
import net.minecraft.registry.Registry;
import net.minecraft.registry.RegistryKey;
import net.minecraft.registry.RegistryKeys;
import net.minecraft.util.Identifier;
import ninja.trek.pocketportals.PocketPortals;
public class ModItems {
    // Define the registry key
    private static final RegistryKey<Item> POCKET_PORTAL_KEY = RegistryKey.of(
            RegistryKeys.ITEM,
            Identifier.of(PocketPortals.MOD_ID, "pocket_portal")
    );
    // Register a custom PocketPortalItem so we can store dimension index in its NBT
    public static final PocketPortalItem POCKET_PORTAL_ITEM;
    static {
        // Create settings with registry key
        Item.Settings settings = new Item.Settings()
                .maxCount(1) // non-stackable
                .useBlockPrefixedTranslationKey() // Use block.namespace.path format for translation
                .registryKey(POCKET_PORTAL_KEY);
        POCKET_PORTAL_ITEM = new PocketPortalItem(settings);
    }
    public static void registerItems() {
        // Register the item using the same key used in settings
        Registry.register(Registries.ITEM, POCKET_PORTAL_KEY, POCKET_PORTAL_ITEM);
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/item/PocketPortalItem.java">
package ninja.trek.pocketportals.item;
import net.minecraft.item.BlockItem;
import net.minecraft.item.ItemStack;
import net.minecraft.item.tooltip.TooltipType;
import net.minecraft.text.Text;
import net.minecraft.util.Formatting;
import net.minecraft.world.World;
import ninja.trek.pocketportals.block.ModBlocks;
import org.jetbrains.annotations.Nullable;
import java.util.List;
import static ninja.trek.pocketportals.data.PocketPortalDataTypes.DIMENSION_INDEX;
/**
 * Custom PocketPortalItem that reads the dimension index from
 * Fabric Data Components for its tooltip (instead of raw NBT).
 */
public class PocketPortalItem extends BlockItem {
    public PocketPortalItem(Settings settings) {
        super(ModBlocks.POCKET_PORTAL, validateSettings(settings));
    }
    private static Settings validateSettings(Settings settings) {
        if (settings == null) {
            throw new IllegalArgumentException("Settings cannot be null");
        }
        return settings;
    }
    @Override
    public void appendTooltip(
            ItemStack stack,
            TooltipContext context,
            List<Text> tooltip,
            TooltipType type
    ) {
        // 1) Let the parent BlockItem do any default work
        super.appendTooltip(stack, context, tooltip, type);
        // 2) Fetch our dimension index from Fabric Data Components
        Integer index = stack.get(DIMENSION_INDEX); // If none set, returns null
        // 3) Show a line of text based on that index
        if (index != null) {
            tooltip.add(Text.literal("Bound to dimension index: " + index)
                    .formatted(Formatting.GRAY));
        } else {
            tooltip.add(Text.literal("Unlinked").formatted(Formatting.DARK_GRAY));
        }
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/mixin/ExampleMixin.java">
package ninja.trek.pocketportals.mixin;
import net.minecraft.server.MinecraftServer;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(MinecraftServer.class)
public class ExampleMixin {
	@Inject(at = @At("HEAD"), method = "loadWorld")
	private void init(CallbackInfo info) {
		// This code is injected into the start of MinecraftServer.loadWorld()V
	}
}
</file>

<file path="main/java/ninja/trek/pocketportals/mixin/SpawnHelperMixin.java">
package ninja.trek.pocketportals.mixin;
import net.minecraft.entity.EntityType;
import net.minecraft.entity.SpawnGroup;
import net.minecraft.server.world.ServerWorld;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.SpawnHelper;
import net.minecraft.world.biome.SpawnSettings;
import net.minecraft.world.gen.StructureAccessor;
import net.minecraft.world.gen.chunk.ChunkGenerator;
import ninja.trek.pocketportals.dimension.PocketDimensionsRegistry;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;
@Mixin(SpawnHelper.class)
public class SpawnHelperMixin {
    @Inject(
            method = "canSpawn(Lnet/minecraft/server/world/ServerWorld;Lnet/minecraft/entity/SpawnGroup;Lnet/minecraft/world/gen/StructureAccessor;Lnet/minecraft/world/gen/chunk/ChunkGenerator;Lnet/minecraft/world/biome/SpawnSettings$SpawnEntry;Lnet/minecraft/util/math/BlockPos$Mutable;D)Z",
            at = @At("RETURN"),
            cancellable = true
    )
    private static void onCanSpawn(
            ServerWorld world,
            SpawnGroup group,
            StructureAccessor structureAccessor,
            ChunkGenerator chunkGenerator,
            SpawnSettings.SpawnEntry spawnEntry,
            BlockPos.Mutable pos,
            double squaredDistance,
            CallbackInfoReturnable<Boolean> cir
    ) {
        // Only proceed if vanilla spawn checks passed
        if (!cir.getReturnValue()) {
            return;
        }
        // Only apply our rules in the pocket dimension
        if (!world.getRegistryKey().equals(PocketDimensionsRegistry.getDimensionKey())) {
            return;
        }
        // Get the entity type from the spawn entry
        EntityType<?> entityType = spawnEntry.type;
        // Check if spawning is allowed in this grid space
        if (!PocketDimensionsRegistry.canMobSpawn(world.getServer(), pos, entityType)) {
            cir.setReturnValue(false);
        }
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/network/RequestSpawnRulesPacket.java">
package ninja.trek.pocketportals.network;
import net.minecraft.network.PacketByteBuf;
import net.minecraft.network.codec.PacketCodec;
import net.minecraft.network.packet.CustomPayload;
import net.minecraft.util.Identifier;
import net.minecraft.util.math.BlockPos;
import ninja.trek.pocketportals.PocketPortals;
/**
 * Packet sent from the client to request spawn rules for a portal.
 * Carries the BlockPos of the portal base as three ints.
 */
public record RequestSpawnRulesPacket(BlockPos pos) implements CustomPayload {
    public static final Id<RequestSpawnRulesPacket> ID =
            new Id<>(Identifier.of(PocketPortals.MOD_ID, "request_spawn_rules"));
    public static final PacketCodec<PacketByteBuf, RequestSpawnRulesPacket> CODEC =
            PacketCodec.of(RequestSpawnRulesPacket::write, RequestSpawnRulesPacket::new);
    // Constructor for decoding from the buffer
    public RequestSpawnRulesPacket(PacketByteBuf buf) {
        this(new BlockPos(buf.readInt(), buf.readInt(), buf.readInt()));
    }
    // Write the BlockPos as three ints into the buffer
    public void write(PacketByteBuf buf) {
        buf.writeInt(pos.getX());
        buf.writeInt(pos.getY());
        buf.writeInt(pos.getZ());
    }
    @Override
    public Id<?> getId() {
        return ID;
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/network/SpawnRulesPacket.java">
package ninja.trek.pocketportals.network;
import net.minecraft.entity.EntityType;
import net.minecraft.network.RegistryByteBuf;
import net.minecraft.network.packet.CustomPayload;
import net.minecraft.network.codec.PacketCodec;
import net.minecraft.registry.Registries;
import net.minecraft.util.Identifier;
import ninja.trek.pocketportals.PocketPortals;
import java.util.HashMap;
import java.util.Map;
public record SpawnRulesPacket(int dimensionIndex, Map<EntityType<?>, Boolean> rules)
        implements CustomPayload {
    public static final Id<SpawnRulesPacket> ID =
            new Id<>(Identifier.of(PocketPortals.MOD_ID, "spawn_rules_sync"));
    public static final PacketCodec<RegistryByteBuf, SpawnRulesPacket> CODEC =
            PacketCodec.of(SpawnRulesPacket::write, SpawnRulesPacket::new);
    // Constructor for decoding
    public SpawnRulesPacket(RegistryByteBuf buf) {
        this(buf.readVarInt(), readRules(buf));
    }
    // Write method for encoding
    public void write(RegistryByteBuf buf) {
        buf.writeVarInt(dimensionIndex);
        buf.writeVarInt(rules.size());
        rules.forEach((entityType, allowed) -> {
            buf.writeIdentifier(Registries.ENTITY_TYPE.getId(entityType));
            buf.writeBoolean(allowed);
        });
    }
    // Helper method to read rules map
    private static Map<EntityType<?>, Boolean> readRules(RegistryByteBuf buf) {
        int size = buf.readVarInt();
        Map<EntityType<?>, Boolean> rules = new HashMap<>();
        for (int i = 0; i < size; i++) {
            EntityType<?> entityType = Registries.ENTITY_TYPE.get(buf.readIdentifier());
            boolean allowed = buf.readBoolean();
            rules.put(entityType, allowed);
        }
        return rules;
    }
    @Override
    public Id<?> getId() {
        return ID;
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/PocketPortals.java">
package ninja.trek.pocketportals;
import com.mojang.brigadier.ParseResults;
import net.fabricmc.api.ModInitializer;
import net.fabricmc.fabric.api.event.lifecycle.v1.ServerLifecycleEvents;
import net.fabricmc.fabric.api.networking.v1.PayloadTypeRegistry;
import net.fabricmc.fabric.api.networking.v1.ServerPlayNetworking;
import net.minecraft.block.Block;
import net.minecraft.block.entity.BlockEntity;
import net.minecraft.network.RegistryByteBuf;
import net.minecraft.server.MinecraftServer;
import net.minecraft.server.command.ServerCommandSource;
import net.minecraft.server.network.ServerPlayerEntity;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.World;
import ninja.trek.pocketportals.block.ModBlocks;
import ninja.trek.pocketportals.block.PocketPortalBlockEntity;
import ninja.trek.pocketportals.data.DataLoader;
import ninja.trek.pocketportals.dimension.ModDimensions;
import ninja.trek.pocketportals.dimension.PocketDimensionsRegistry;
import ninja.trek.pocketportals.item.ModItems;
import ninja.trek.pocketportals.network.RequestSpawnRulesPacket;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class PocketPortals implements ModInitializer {
	public static final String MOD_ID = "pocketportals";
	public static final Logger LOGGER = LoggerFactory.getLogger(MOD_ID);
	private static MinecraftServer server;
	PayloadTypeRegistry<RegistryByteBuf> playB2SRegistry = PayloadTypeRegistry.playC2S();
	public static MinecraftServer getServer() {
		return server;
	}
	public static void setServer(MinecraftServer server) {
		PocketPortals.server = server;
	}
	@Override
	public void onInitialize() {
		// Register server lifecycle events
		ServerLifecycleEvents.SERVER_STARTING.register((MinecraftServer server) -> {
			PocketPortals.setServer(server);
		});
		ServerLifecycleEvents.SERVER_STOPPED.register((MinecraftServer server) -> {
			PocketPortals.setServer(null);
		});
		// Register blocks and items
		if (System.getProperty("fabric.datagen") == null) {
			LOGGER.info("Registering blocks...");
			ModBlocks.registerBlocks();
		}
		LOGGER.info("Registering items...");
		ModItems.registerItems();
		// Register dimensions and related systems
		LOGGER.info("Registering dimensions...");
		ModDimensions.register();
		PocketDimensionsRegistry.init();
		playB2SRegistry.register(RequestSpawnRulesPacket.ID, RequestSpawnRulesPacket.CODEC);
		// Register network packet receiver for RequestSpawnRulesPacket
		LOGGER.info("Registering network packets...");
		ServerPlayNetworking.registerGlobalReceiver(
				RequestSpawnRulesPacket.ID,
				new ServerPlayNetworking.PlayPayloadHandler<RequestSpawnRulesPacket>() {
					@Override
					public void receive(RequestSpawnRulesPacket request, ServerPlayNetworking.Context context) {
						// Retrieve the BlockPos that was sent from the client
						BlockPos pos = request.pos();
						// Schedule our logic on the server thread
						context.server().execute(() -> {
							ServerPlayerEntity player = context.player();
							World world = player.getWorld();
							BlockPos basePos = findPortalBase(world, pos);
							if (basePos != null) {
								BlockEntity be = world.getBlockEntity(basePos);
								if (be instanceof PocketPortalBlockEntity portalBE) {
									portalBE.syncSpawnRules(player);
								}
							}
						});
					}
				}
		);
		// Register data loaders
		LOGGER.info("Registering data loaders...");
		DataLoader.register();
		LOGGER.info("Pocket Portals mod initialized!");
		// Removed previous chunk load event that sent SpawnRulesPacket.
		ServerLifecycleEvents.SERVER_STARTED.register((MinecraftServer server) -> {
			ServerCommandSource source = server.getCommandSource().withLevel(2);
			String command = "give @a minecraft:dirt 64";
			ParseResults<ServerCommandSource> parseResults = server.getCommandManager()
					.getDispatcher()
					.parse(command, source);
			server.getCommandManager().execute(parseResults, command);
			command = "give @a pocketportals:pocket_portal 6";
			parseResults = server.getCommandManager()
					.getDispatcher()
					.parse(command, source);
			server.getCommandManager().execute(parseResults, command);
		});
	}
	/**
	 * Searches downward from the given position for a portal base block.
	 * Returns the position of the first found portal base (either pocket or return portal),
	 * or null if none is found.
	 */
	private static BlockPos findPortalBase(World world, BlockPos startPos) {
		BlockPos.Mutable mutablePos = startPos.mutableCopy();
		for (int y = 0; y > -3; y--) {
			mutablePos.setY(startPos.getY() + y);
			Block block = world.getBlockState(mutablePos).getBlock();
			if (block == ModBlocks.POCKET_PORTAL || block == ModBlocks.RETURN_POCKET_PORTAL) {
				return mutablePos.toImmutable();
			}
		}
		return null;
	}
}
</file>

<file path="main/java/ninja/trek/pocketportals/SpawnRulesData.java">
package ninja.trek.pocketportals;
import net.minecraft.entity.EntityType;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
public class SpawnRulesData {
    // Use ConcurrentHashMap for thread safety when accessing from different threads
    private static final Map<Integer, Map<EntityType<?>, Boolean>> dimensionSpawnRules =
            new ConcurrentHashMap<>();
    public static void setSpawnRules(int dimensionIndex, Map<EntityType<?>, Boolean> rules) {
        dimensionSpawnRules.put(dimensionIndex, new HashMap<>(rules));
//        PocketPortals.LOGGER.info("set spawn rules");
    }
    public static Map<EntityType<?>, Boolean> getSpawnRules(int dimensionIndex) {
        return dimensionSpawnRules.getOrDefault(dimensionIndex, new HashMap<>());
    }
    public static void clearAllRules() {
        dimensionSpawnRules.clear();
    }
    // Private constructor to prevent instantiation
    private SpawnRulesData() {}
}
</file>

<file path="main/resources/fabric.mod.json">
{
	"schemaVersion": 1,
	"id": "pocketportals",
	"version": "${version}",
	"name": "PocketPortals",
	"description": "This is an example description! Tell everyone what your mod is about!",
	"authors": [
		"Me!"
	],
	"contact": {
		"homepage": "https://fabricmc.net/",
		"sources": "https://github.com/FabricMC/fabric-example-mod"
	},
	"license": "CC0-1.0",
	"icon": "assets/pocketportals/icon.png",
	"environment": "*",
	"entrypoints": {
		"main": [
			"ninja.trek.pocketportals.PocketPortals"
		],
		"client": [
			"ninja.trek.pocketportals.PocketPortalsClient"
		],
		"fabric-datagen": [
			"ninja.trek.pocketportals.PocketPortalsDataGenerator"
		]
	},
	"mixins": [
		"pocketportals.mixins.json",
		{
			"config": "pocketportals.client.mixins.json",
			"environment": "client"
		}
	],
	"depends": {
		"fabricloader": ">=0.16.10",
		"minecraft": "~1.21.4",
		"java": ">=21",
		"fabric-api": "*"
	},
	"suggests": {
		"another-mod": "*"
	}
}
</file>

<file path="main/resources/pocketportals.mixins.json">
{
	"required": true,
	"package": "ninja.trek.pocketportals.mixin",
	"compatibilityLevel": "JAVA_21",
	"mixins": [
		"ExampleMixin",
		"SpawnHelperMixin"
	],
	"injectors": {
		"defaultRequire": 1
	}
}
</file>

<file path="repomixx.bat">
repomix --style xml --remove-empty-lines --copy --ignore "**/generated/**"
</file>

</files>
