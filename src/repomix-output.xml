This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-14T07:21:17.103Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
client/java/ninja/trek/pocketportals/mixin/client/ExampleClientMixin.java
client/java/ninja/trek/pocketportals/PocketPortalsClient.java
client/java/ninja/trek/pocketportals/PocketPortalsDataGenerator.java
client/resources/pocket-portals.client.mixins.json
main/java/ninja/trek/pocketportals/block/ModBlocks.java
main/java/ninja/trek/pocketportals/block/PocketPortalBlock.java
main/java/ninja/trek/pocketportals/block/PocketPortalBlockEntity.java
main/java/ninja/trek/pocketportals/block/PocketPortalFrame.java
main/java/ninja/trek/pocketportals/data/DataLoader.java
main/java/ninja/trek/pocketportals/data/PocketPortalDataTypes.java
main/java/ninja/trek/pocketportals/dimension/BiomeSurfaceCache.java
main/java/ninja/trek/pocketportals/dimension/GridBiomeSource.java
main/java/ninja/trek/pocketportals/dimension/ModDimensions.java
main/java/ninja/trek/pocketportals/dimension/PocketDimensionJsonProvider.java
main/java/ninja/trek/pocketportals/dimension/PocketDimensionsRegistry.java
main/java/ninja/trek/pocketportals/dimension/SkyIslandChunkGenerator.java
main/java/ninja/trek/pocketportals/item/ModItems.java
main/java/ninja/trek/pocketportals/item/PocketPortalItem.java
main/java/ninja/trek/pocketportals/mixin/ExampleMixin.java
main/java/ninja/trek/pocketportals/PocketPortals.java
main/java/ninja/trek/pocketportals/PocketPortalsDataGenerator.java
main/resources/assets/pocket-portals/models/block/pocket_portal_frame.json
main/resources/fabric.mod.json
main/resources/pocket-portals.mixins.json
repomixx.bat
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="client/java/ninja/trek/pocketportals/mixin/client/ExampleClientMixin.java">
package ninja.trek.pocketportals.mixin.client;
import net.minecraft.client.MinecraftClient;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(MinecraftClient.class)
public class ExampleClientMixin {
	@Inject(at = @At("HEAD"), method = "run")
	private void init(CallbackInfo info) {
		// This code is injected into the start of MinecraftClient.run()V
	}
}
</file>

<file path="client/java/ninja/trek/pocketportals/PocketPortalsClient.java">
package ninja.trek.pocketportals;
import net.fabricmc.api.ClientModInitializer;
public class PocketPortalsClient implements ClientModInitializer {
	@Override
	public void onInitializeClient() {
		// This entrypoint is suitable for setting up client-specific logic, such as rendering.
	}
}
</file>

<file path="client/java/ninja/trek/pocketportals/PocketPortalsDataGenerator.java">
package ninja.trek.pocketportals;
import net.fabricmc.fabric.api.datagen.v1.DataGeneratorEntrypoint;
import net.fabricmc.fabric.api.datagen.v1.FabricDataGenerator;
public class PocketPortalsDataGenerator implements DataGeneratorEntrypoint {
	@Override
	public void onInitializeDataGenerator(FabricDataGenerator fabricDataGenerator) {
	}
}
</file>

<file path="client/resources/pocket-portals.client.mixins.json">
{
	"required": true,
	"package": "ninja.trek.pocketportals.mixin.client",
	"compatibilityLevel": "JAVA_21",
	"client": [
		"ExampleClientMixin"
	],
	"injectors": {
		"defaultRequire": 1
	}
}
</file>

<file path="main/java/ninja/trek/pocketportals/block/ModBlocks.java">
package ninja.trek.pocketportals.block;
import net.fabricmc.fabric.api.object.builder.v1.block.FabricBlockSettings;
import net.fabricmc.fabric.api.object.builder.v1.block.entity.FabricBlockEntityTypeBuilder;
import net.minecraft.block.entity.BlockEntityType;
import net.minecraft.registry.Registries;
import net.minecraft.registry.Registry;
import net.minecraft.util.Identifier;
import ninja.trek.pocketportals.PocketPortals;
public class ModBlocks {
    public static final PocketPortalBlock POCKET_PORTAL = new PocketPortalBlock(
            FabricBlockSettings.create()
                    .strength(3.0f)
                    .requiresTool()
                    .nonOpaque()
    );
    public static final PocketPortalFrame POCKET_PORTAL_FRAME = new PocketPortalFrame(
            FabricBlockSettings.create()
                    .luminance(state -> 11)
                    .noCollision()
                    .strength(-1.0F)
    );
    public static final BlockEntityType<PocketPortalBlockEntity> POCKET_PORTAL_BLOCK_ENTITY =
            FabricBlockEntityTypeBuilder.create(
                    PocketPortalBlockEntity::new,
                    POCKET_PORTAL
            ).build();
    public static void registerBlocks() {
        Registry.register(
                Registries.BLOCK,
                Identifier.of(PocketPortals.MOD_ID, "pocket_portal"),
                POCKET_PORTAL
        );
        Registry.register(
                Registries.BLOCK,
                Identifier.of(PocketPortals.MOD_ID, "pocket_portal_frame"),
                POCKET_PORTAL_FRAME
        );
        Registry.register(
                Registries.BLOCK_ENTITY_TYPE,
                Identifier.of(PocketPortals.MOD_ID, "pocket_portal_entity"),
                POCKET_PORTAL_BLOCK_ENTITY
        );
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/block/PocketPortalBlock.java">
package ninja.trek.pocketportals.block;
import com.mojang.serialization.MapCodec;
import net.minecraft.block.Block;
import net.minecraft.block.BlockRenderType;
import net.minecraft.block.BlockState;
import net.minecraft.block.Blocks;
import net.minecraft.block.BlockWithEntity;
import net.minecraft.block.HorizontalFacingBlock;
import net.minecraft.block.entity.BlockEntity;
import net.minecraft.entity.Entity;
import net.minecraft.entity.LivingEntity;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.item.ItemStack;
import net.minecraft.state.StateManager;
import net.minecraft.state.property.DirectionProperty;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.World;
import ninja.trek.pocketportals.dimension.PocketDimensionsRegistry;
import ninja.trek.pocketportals.item.ModItems;
import static ninja.trek.pocketportals.data.PocketPortalDataTypes.DIMENSION_INDEX;
/**
 * Manages creation of the block entity and uses Fabric Data Components
 * to store the dimension index in the item. No direct NBT usage.
 */
public class PocketPortalBlock extends BlockWithEntity {
    public static final DirectionProperty FACING = HorizontalFacingBlock.FACING;
    public static final MapCodec<PocketPortalBlock> CODEC = createCodec(PocketPortalBlock::new);
    public PocketPortalBlock(Settings settings) {
        super(Settings.copy(Blocks.STONE)
                .strength(3.0f)
                .requiresTool()
                .nonOpaque());
        setDefaultState(getStateManager().getDefaultState());
    }
    @Override
    protected MapCodec<? extends BlockWithEntity> getCodec() {
        return CODEC;
    }
    @Override
    public BlockRenderType getRenderType(BlockState state) {
        return BlockRenderType.MODEL;
    }
    @Override
    protected void appendProperties(StateManager.Builder<Block, BlockState> builder) {
        builder.add(FACING);
    }
    @Override
    public BlockEntity createBlockEntity(BlockPos pos, BlockState state) {
        return new PocketPortalBlockEntity(pos, state);
    }
    /**
     * Called after the block is placed in the world.
     * We read the dimension index from the itemâ€™s DataComponent,
     * or assign a new one if it's missing.
     */
    @Override
    public void onPlaced(World world, BlockPos pos, BlockState state,
                         LivingEntity placer, ItemStack stack) {
        super.onPlaced(world, pos, state, placer, stack);
        if (!world.isClient) {
            BlockEntity blockEntity = world.getBlockEntity(pos);
            if (blockEntity instanceof PocketPortalBlockEntity portalBE) {
                // 1) Read dimension index from the placed item
                Integer storedIndex = stack.get(DIMENSION_INDEX);
                // 2) If none present, pick a new unused one
                if (storedIndex == null) {
                    storedIndex = PocketDimensionsRegistry.findUnusedSlot();
                }
                // 3) Assign it to the block entity
                portalBE.setDimensionIndex(storedIndex);
                portalBE.markDirty();
                // 4) (Optional) Create "frame" blocks above
                BlockPos portalPos1 = pos.up();
                BlockPos portalPos2 = portalPos1.up();
                world.setBlockState(portalPos1, ModBlocks.POCKET_PORTAL_FRAME.getDefaultState());
                world.setBlockState(portalPos2, ModBlocks.POCKET_PORTAL_FRAME.getDefaultState());
            }
        }
    }
    /**
     * Called when the block is broken. We create a new item that has the
     * dimension index from the block entity stored in its DataComponent,
     * then drop it in the world.
     *
     * @return
     */
    @Override
    public BlockState onBreak(World world, BlockPos pos, BlockState state, PlayerEntity player) {
        if (!world.isClient) {
            BlockEntity be = world.getBlockEntity(pos);
            if (be instanceof PocketPortalBlockEntity portalBE) {
                Integer dimIndex = portalBE.getDimensionIndex();
                // Create a new item with that dimension index
                ItemStack newStack = new ItemStack(ModItems.POCKET_PORTAL);
                if (dimIndex != null) {
                    // Store the dimension index using data components
                    newStack.set(DIMENSION_INDEX, dimIndex);
                }
                // Drop it
                Block.dropStack(world, pos, newStack);
            }
        }
        // Remove frames above, then proceed with normal break logic
        return super.onBreak(world, pos, state, player);
//        return state;
    }
    /**
     * Pass collision handling to the block entity, which handles dimension teleports.
     */
    @Override
    public void onEntityCollision(BlockState state, World world, BlockPos pos, Entity entity) {
        if (!world.isClient) {
            BlockEntity be = world.getBlockEntity(pos);
            if (be instanceof PocketPortalBlockEntity portalBE) {
                portalBE.handleEntityCollision(entity);
            }
        }
    }
    /**
     * If the block is replaced with a different block, remove the frame blocks above it.
     */
    @Override
    public void onStateReplaced(BlockState state, World world,
                                BlockPos pos, BlockState newState, boolean moved) {
        if (!state.isOf(newState.getBlock())) {
            // Remove frames
            world.setBlockState(pos.up(), Blocks.AIR.getDefaultState());
            world.setBlockState(pos.up(2), Blocks.AIR.getDefaultState());
        }
        super.onStateReplaced(state, world, pos, newState, moved);
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/block/PocketPortalBlockEntity.java">
package ninja.trek.pocketportals.block;
import net.minecraft.block.BlockState;
import net.minecraft.block.entity.BlockEntity;
import net.minecraft.entity.Entity;
import net.minecraft.nbt.NbtCompound;
import net.minecraft.network.packet.s2c.play.PositionFlag;
import net.minecraft.registry.RegistryWrapper;
import net.minecraft.server.world.ServerWorld;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.Heightmap;
import ninja.trek.pocketportals.PocketPortals;
import ninja.trek.pocketportals.dimension.ModDimensions;
import ninja.trek.pocketportals.dimension.PocketDimensionsRegistry;
import java.util.EnumSet;
public class PocketPortalBlockEntity extends BlockEntity {
    private static final String DIMENSION_INDEX_KEY = "PocketDimensionIndex";
    private Integer dimensionIndex = null; // store an index from 0..255
    public PocketPortalBlockEntity(BlockPos pos, BlockState state) {
        super(ModBlocks.POCKET_PORTAL_BLOCK_ENTITY, pos, state);
    }
    public Integer getDimensionIndex() {
        return dimensionIndex;
    }
    public void setDimensionIndex(Integer dimensionIndex) {
        this.dimensionIndex = dimensionIndex;
    }
    @Override
    public void readNbt(NbtCompound nbt, RegistryWrapper.WrapperLookup lookup) {
        super.readNbt(nbt, lookup);
        if (nbt.contains(DIMENSION_INDEX_KEY)) {
            dimensionIndex = nbt.getInt(DIMENSION_INDEX_KEY);
        }
    }
    @Override
    public void writeNbt(NbtCompound nbt, RegistryWrapper.WrapperLookup lookup) {
        super.writeNbt(nbt, lookup);
        if (dimensionIndex != null) {
            nbt.putInt(DIMENSION_INDEX_KEY, dimensionIndex);
        }
    }
    public void handleEntityCollision(Entity entity) {
        if (!(world instanceof ServerWorld serverWorld)) return;
        if (!entity.canUsePortals(false)) return;
        if (dimensionIndex == null) {
            PocketPortals.LOGGER.warn("Portal block has no dimension index assigned!");
            return;
        }
        // Get the target dimension
        ServerWorld targetWorld = serverWorld.getServer().getWorld(PocketDimensionsRegistry.getDimensionKey());
        if (targetWorld == null) {
            PocketPortals.LOGGER.error("Pocket dimension is not loaded!");
            return;
        }
        // Are we already in the pocket dimension?
        if (serverWorld.getRegistryKey().equals(PocketDimensionsRegistry.getDimensionKey())) {
            // Then go back to Overworld
            ServerWorld overworld = serverWorld.getServer().getOverworld();
            teleportEntity(entity, overworld, pos.getX() + 0.5, pos.getY() + 1, pos.getZ() + 0.5);
        } else {
            // Calculate grid position from index
            ModDimensions.GridPosition gridPos = ModDimensions.indexToGridPosition(dimensionIndex);
            ModDimensions.WorldPosition worldPos = ModDimensions.gridToWorldPosition(gridPos);
            // Teleport to the specific grid location in the pocket dimension
            teleportEntity(entity, targetWorld,
                    worldPos.x() + 0.5, worldPos.y() + 1, worldPos.z() + 0.5);
            // Build return portal at the destination
            buildReturnPortal(targetWorld, new BlockPos(worldPos.x(), worldPos.y(), worldPos.z()));
        }
    }
    private void teleportEntity(Entity entity, ServerWorld targetWorld, double x, double y, double z) {
        BlockPos.Mutable checkPos = new BlockPos.Mutable((int)x, (int)y, (int)z);
        // Get the actual height from the chunk generator
        int surfaceHeight = targetWorld.getChunkManager()
                .getChunkGenerator()
                .getHeight((int)x, (int)z,
                        Heightmap.Type.MOTION_BLOCKING,
                        targetWorld,
                        targetWorld.getChunkManager().getNoiseConfig());
        // Set our check position to the surface height
        checkPos.set((int)x, surfaceHeight, (int)z);
        // Move up until we have 2 blocks of air clearance
        while (checkPos.getY() < targetWorld.getTopY() &&
                (!targetWorld.getBlockState(checkPos).isAir() ||
                        !targetWorld.getBlockState(checkPos.up()).isAir())) {
            checkPos.move(0, 1, 0);
        }
        // Teleport to the safe position we found
        entity.teleport(
                targetWorld,
                x, checkPos.getY(), z,
                EnumSet.noneOf(PositionFlag.class),
                entity.getYaw(),
                entity.getPitch()
        );
    }
    /**
     * (Optional) Build a return portal in the remote dimension.
     * That portal block can store the same dimensionIndex or a separate route.
     */
    private void buildReturnPortal(ServerWorld targetWorld, BlockPos nearPos) {
        // Example: build our PocketPortalBlock + frames at nearPos + some offset
        BlockPos base = nearPos.add(2, 0, 0);
        targetWorld.setBlockState(base, ModBlocks.POCKET_PORTAL.getDefaultState());
        // Place frame blocks above
        targetWorld.setBlockState(base.up(), ModBlocks.POCKET_PORTAL_FRAME.getDefaultState());
        targetWorld.setBlockState(base.up(2), ModBlocks.POCKET_PORTAL_FRAME.getDefaultState());
        // Then set the dimensionIndex in that new block entity so it knows
        // which dimension it references (for return).
        BlockEntity be = targetWorld.getBlockEntity(base);
        if (be instanceof PocketPortalBlockEntity pbe) {
            // Option 1: set the same index so if used in that dimension,
            // you go back to Overworld (the dimension you came from).
            pbe.setDimensionIndex(this.dimensionIndex);
            pbe.markDirty();
        }
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/block/PocketPortalFrame.java">
package ninja.trek.pocketportals.block;
import com.mojang.serialization.MapCodec;
import net.minecraft.block.Block;
import net.minecraft.block.BlockRenderType;
import net.minecraft.block.BlockState;
import net.minecraft.block.Blocks;
import net.minecraft.block.entity.BlockEntity;
import net.minecraft.entity.Entity;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.particle.ParticleTypes;
import net.minecraft.sound.SoundCategory;
import net.minecraft.sound.SoundEvents;
import net.minecraft.util.ActionResult;
import net.minecraft.util.Hand;
import net.minecraft.util.hit.BlockHitResult;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.random.Random;
import net.minecraft.text.Text;
import net.minecraft.world.World;
public class PocketPortalFrame extends Block {
    public static final MapCodec<PocketPortalFrame> CODEC = createCodec(PocketPortalFrame::new);
    public PocketPortalFrame(Settings settings) {
        super(Settings.copy(Blocks.NETHER_PORTAL)
                .luminance(state -> 11)
                .noCollision()
                .strength(-1.0F)
        );
    }
    @Override
    public void onEntityCollision(BlockState state, World world, BlockPos pos, Entity entity) {
        if (!world.isClient && entity.canUsePortals(false)) {
            // Find the portal base block
            BlockPos basePos = findPortalBase(world, pos);
            if (basePos != null) {
                BlockEntity blockEntity = world.getBlockEntity(basePos);
                if (blockEntity instanceof PocketPortalBlockEntity portalBlockEntity) {
                    portalBlockEntity.handleEntityCollision(entity);
                }
            }
        }
    }
    /**
     * Allow sneak-right-click to show dimension info in chat.
     */
    @Override
    public ActionResult onUse(BlockState state, World world,
                              BlockPos pos, PlayerEntity player,
                              BlockHitResult hit) {
        if (!world.isClient && player.isSneaking()) {
            BlockPos basePos = findPortalBase(world, pos);
            if (basePos != null) {
                BlockEntity be = world.getBlockEntity(basePos);
                if (be instanceof PocketPortalBlockEntity portalBE) {
                    Integer idx = portalBE.getDimensionIndex();
                    if (idx == null) {
                        player.sendMessage(Text.literal("Portal dimension index: Unlinked"), false);
                    } else {
                        player.sendMessage(Text.literal("Portal dimension index: " + idx), false);
                    }
                }
            }
            return ActionResult.SUCCESS;
        }
        return ActionResult.PASS;
    }
    private BlockPos findPortalBase(World world, BlockPos startPos) {
        // Search downward for the portal base block
        BlockPos.Mutable currentPos = startPos.mutableCopy();
        for (int y = 0; y > -3; y--) {
            currentPos.move(0, y, 0);
            if (world.getBlockState(currentPos).getBlock() instanceof PocketPortalBlock) {
                return currentPos.toImmutable();
            }
        }
        return null;
    }
    @Override
    public void randomDisplayTick(BlockState state, World world, BlockPos pos, Random random) {
        if (random.nextInt(100) == 0) {
            world.playSound(
                    pos.getX() + 0.5D,
                    pos.getY() + 0.5D,
                    pos.getZ() + 0.5D,
                    SoundEvents.BLOCK_PORTAL_AMBIENT,
                    SoundCategory.BLOCKS,
                    0.5F,
                    random.nextFloat() * 0.4F + 0.8F,
                    false
            );
        }
        for(int i = 0; i < 4; ++i) {
            double x = pos.getX() + random.nextDouble();
            double y = pos.getY() + random.nextDouble();
            double z = pos.getZ() + random.nextDouble();
            double dx = (random.nextDouble() - 0.5D) * 0.5D;
            double dy = (random.nextDouble() - 0.5D) * 0.5D;
            double dz = (random.nextDouble() - 0.5D) * 0.5D;
            world.addParticle(ParticleTypes.PORTAL, x, y, z, dx, dy, dz);
        }
    }
    @Override
    public BlockRenderType getRenderType(BlockState state) {
        return BlockRenderType.MODEL;
    }
    @Override
    protected MapCodec<? extends Block> getCodec() {
        return CODEC;
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/data/DataLoader.java">
package ninja.trek.pocketportals.data;
import net.fabricmc.fabric.api.resource.ResourceManagerHelper;
import net.fabricmc.fabric.api.resource.SimpleSynchronousResourceReloadListener;
import net.minecraft.resource.ResourceManager;
import net.minecraft.resource.ResourceType;
import net.minecraft.util.Identifier;
import ninja.trek.pocketportals.PocketPortals;
public class DataLoader {
    public static void register() {
        ResourceManagerHelper.get(ResourceType.SERVER_DATA).registerReloadListener(
                new SimpleSynchronousResourceReloadListener() {
                    @Override
                    public Identifier getFabricId() {
                        return Identifier.of(PocketPortals.MOD_ID, "dimension_loader");
                    }
                    @Override
                    public void reload(ResourceManager manager) {
                        // Check for dimension type file
                        Identifier dimTypeId = Identifier.of(PocketPortals.MOD_ID, "dimension_type/pocket_dimension_type.json");
                        if (manager.getResource(dimTypeId).isPresent()) {
                            PocketPortals.LOGGER.info("Found pocket dimension type configuration");
                        } else {
                            PocketPortals.LOGGER.error("Missing pocket dimension type configuration at {}", dimTypeId);
                        }
                        // Check for dimension file
                        Identifier dimId = Identifier.of(PocketPortals.MOD_ID, "dimension/pocket_dimension.json");
                        if (manager.getResource(dimId).isPresent()) {
                            PocketPortals.LOGGER.info("Found pocket dimension configuration");
                        } else {
                            PocketPortals.LOGGER.error("Missing pocket dimension configuration at {}", dimId);
                        }
                    }
                }
        );
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/data/PocketPortalDataTypes.java">
package ninja.trek.pocketportals.data;
import com.mojang.serialization.Codec;
import net.minecraft.component.ComponentType;
import net.minecraft.network.RegistryByteBuf;
import net.minecraft.network.codec.PacketCodec;
import net.minecraft.util.Identifier;
/**
 * Defines a custom ComponentType<Integer> for storing a dimension index
 * in an item or block entity, using Minecraft 1.21's new item component system.
 */
public final class PocketPortalDataTypes {
    /**
     * Our custom component type that stores an Integer (dimension index).
     *
     * - Codec: Handles saving/loading from NBT and JSON.
     * - PacketCodec: Handles network sync and serialization.
     */
    public static final ComponentType<Integer> DIMENSION_INDEX = new ComponentType.Builder<Integer>()
            .codec(Codec.INT) // Set up codec for serialization
            .packetCodec(new PacketCodec<RegistryByteBuf, Integer>() {
                @Override
                public Integer decode(RegistryByteBuf buf) {
                    return buf.readVarInt(); // Read the dimension index from the network buffer
                }
                @Override
                public void encode(RegistryByteBuf buf, Integer value) {
                    buf.writeVarInt(value); // Write the dimension index to the network buffer
                }
            })
            .build(); // Build the ComponentType
    // Prevent instantiation
    private PocketPortalDataTypes() {}
}
</file>

<file path="main/java/ninja/trek/pocketportals/dimension/BiomeSurfaceCache.java">
package ninja.trek.pocketportals.dimension;
import net.minecraft.block.BlockState;
import net.minecraft.block.Blocks;
import net.minecraft.registry.RegistryKey;
import net.minecraft.util.Identifier;
import net.minecraft.world.biome.BiomeKeys;
import java.util.HashMap;
import java.util.Map;
public class BiomeSurfaceCache {
    private static final Map<RegistryKey<?>, BlockState> BIOME_TOP_BLOCKS = new HashMap<>();
    private static final Map<RegistryKey<?>, BlockState> BIOME_UNDER_BLOCKS = new HashMap<>();
    static {
        // Plains-like biomes
        BIOME_TOP_BLOCKS.put(BiomeKeys.PLAINS, Blocks.GRASS_BLOCK.getDefaultState());
        BIOME_UNDER_BLOCKS.put(BiomeKeys.PLAINS, Blocks.DIRT.getDefaultState());
        // Desert biomes
        BIOME_TOP_BLOCKS.put(BiomeKeys.DESERT, Blocks.SAND.getDefaultState());
        BIOME_UNDER_BLOCKS.put(BiomeKeys.DESERT, Blocks.SANDSTONE.getDefaultState());
        // Forest biomes
        BIOME_TOP_BLOCKS.put(BiomeKeys.FOREST, Blocks.GRASS_BLOCK.getDefaultState());
        BIOME_UNDER_BLOCKS.put(BiomeKeys.FOREST, Blocks.DIRT.getDefaultState());
        // Snowy biomes
        BIOME_TOP_BLOCKS.put(BiomeKeys.SNOWY_PLAINS, Blocks.SNOW_BLOCK.getDefaultState());
        BIOME_UNDER_BLOCKS.put(BiomeKeys.SNOWY_PLAINS, Blocks.DIRT.getDefaultState());
        // Jungle biomes
        BIOME_TOP_BLOCKS.put(BiomeKeys.JUNGLE, Blocks.GRASS_BLOCK.getDefaultState());
        BIOME_UNDER_BLOCKS.put(BiomeKeys.JUNGLE, Blocks.DIRT.getDefaultState());
        // Mushroom biomes
        BIOME_TOP_BLOCKS.put(BiomeKeys.MUSHROOM_FIELDS, Blocks.MYCELIUM.getDefaultState());
        BIOME_UNDER_BLOCKS.put(BiomeKeys.MUSHROOM_FIELDS, Blocks.DIRT.getDefaultState());
        // Cherry grove
        BIOME_TOP_BLOCKS.put(BiomeKeys.CHERRY_GROVE, Blocks.GRASS_BLOCK.getDefaultState());
        BIOME_UNDER_BLOCKS.put(BiomeKeys.CHERRY_GROVE, Blocks.DIRT.getDefaultState());
        // Meadow
        BIOME_TOP_BLOCKS.put(BiomeKeys.MEADOW, Blocks.GRASS_BLOCK.getDefaultState());
        BIOME_UNDER_BLOCKS.put(BiomeKeys.MEADOW, Blocks.DIRT.getDefaultState());
    }
    public static BlockState getTopBlock(Identifier biomeId) {
        for (Map.Entry<RegistryKey<?>, BlockState> entry : BIOME_TOP_BLOCKS.entrySet()) {
            if (entry.getKey().getValue().equals(biomeId)) {
                return entry.getValue();
            }
        }
        return Blocks.GRASS_BLOCK.getDefaultState();
    }
    public static BlockState getUnderBlock(Identifier biomeId) {
        for (Map.Entry<RegistryKey<?>, BlockState> entry : BIOME_UNDER_BLOCKS.entrySet()) {
            if (entry.getKey().getValue().equals(biomeId)) {
                return entry.getValue();
            }
        }
        return Blocks.DIRT.getDefaultState();
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/dimension/GridBiomeSource.java">
package ninja.trek.pocketportals.dimension;
import com.mojang.serialization.Codec;
import com.mojang.serialization.MapCodec;
import com.mojang.serialization.codecs.RecordCodecBuilder;
import net.minecraft.registry.Registry;
import net.minecraft.registry.RegistryKey;
import net.minecraft.registry.entry.RegistryEntry;
import net.minecraft.world.biome.Biome;
import net.minecraft.world.biome.BiomeKeys;
import net.minecraft.world.biome.source.BiomeSource;
import net.minecraft.world.biome.source.util.MultiNoiseUtil;
import java.util.List;
import java.util.Random;
import java.util.Optional;
import java.util.stream.Stream;
public class GridBiomeSource extends BiomeSource {
    private static final Codec<GridBiomeSource> GRID_CODEC = RecordCodecBuilder.create(instance ->
            instance.group(
                    Codec.LONG.fieldOf("seed").forGetter(source -> source.seed)
            ).apply(instance, GridBiomeSource::new));
    private final long seed;
    private final List<RegistryKey<Biome>> biomeKeys;
    private Registry<Biome> biomeRegistry;
    public GridBiomeSource(long seed) {
        this.seed = seed;
        this.biomeKeys = List.of(
                BiomeKeys.PLAINS,
                BiomeKeys.FOREST,
                BiomeKeys.DESERT,
                BiomeKeys.SNOWY_PLAINS,
                BiomeKeys.JUNGLE,
                BiomeKeys.MUSHROOM_FIELDS,
                BiomeKeys.CHERRY_GROVE,
                BiomeKeys.MEADOW
        );
    }
    public void setBiomeRegistry(Registry<Biome> registry) {
        this.biomeRegistry = registry;
    }
    @Override
    public MapCodec<? extends BiomeSource> getCodec() {
        return (MapCodec<? extends BiomeSource>) GRID_CODEC;
    }
    @Override
    public Stream<RegistryEntry<Biome>> biomeStream() {
        if (biomeRegistry == null) {
            return Stream.empty();
        }
        return biomeKeys.stream()
                .map(key -> biomeRegistry.getEntry(key))
                .filter(Optional::isPresent)
                .map(Optional::get);
    }
    @Override
    public RegistryEntry<Biome> getBiome(int x, int y, int z, MultiNoiseUtil.MultiNoiseSampler noise) {
        if (biomeRegistry == null) {
            // Default to plains if registry not set
            return biomeRegistry.getEntry(BiomeKeys.PLAINS).orElseThrow();
        }
        // Convert to grid coordinates
        int gridX = Math.floorDiv(x, ModDimensions.GRID_SPACING);
        int gridZ = Math.floorDiv(z, ModDimensions.GRID_SPACING);
        // Create a random number generator using the grid position and seed
        Random random = new Random(seed ^ ((long)gridX << 32 | (long)gridZ));
        // Pick a consistent biome key for this grid cell
        RegistryKey<Biome> biomeKey = biomeKeys.get(random.nextInt(biomeKeys.size()));
        // Get the actual biome entry from the registry
        return biomeRegistry.getEntry(biomeKey).orElseThrow(() ->
                new RuntimeException("Could not find biome for key: " + biomeKey.getValue()));
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/dimension/ModDimensions.java">
package ninja.trek.pocketportals.dimension;
import net.minecraft.registry.Registry;
import net.minecraft.registry.Registries;
import net.minecraft.util.Identifier;
import ninja.trek.pocketportals.PocketPortals;
public class ModDimensions {
    public static final int GRID_SPACING = 100_000; // Blocks between each portal location
    public static final int GRID_SIZE = 600; // 600x600 grid
    public static void register() {
        // Register our new SkyIslandChunkGenerator
        Registry.register(
                Registries.CHUNK_GENERATOR,
                Identifier.of(PocketPortals.MOD_ID, "sky_island"),
                SkyIslandChunkGenerator.CODEC
        );
    }
    /**
     * Convert a dimension index (0-359999) to grid coordinates
     */
    public static GridPosition indexToGridPosition(int index) {
        if (index < 0 || index >= GRID_SIZE * GRID_SIZE) {
            throw new IllegalArgumentException("Index out of bounds: " + index);
        }
        int x = index % GRID_SIZE;
        int z = index / GRID_SIZE;
        return new GridPosition(x, z);
    }
    /**
     * Convert grid coordinates to world coordinates
     */
    public static WorldPosition gridToWorldPosition(GridPosition grid) {
        // Convert grid coordinates to world coordinates, centered in each cell
        // Add 50,000 block offset to keep away from world border
        int worldX = (grid.x() - (GRID_SIZE / 2)) * GRID_SPACING + 50_000;
        int worldZ = (grid.z() - (GRID_SIZE / 2)) * GRID_SPACING + 50_000;
        return new WorldPosition(worldX, 64, worldZ); // Y=64 is base height
    }
    public record GridPosition(int x, int z) {}
    public record WorldPosition(int x, int y, int z) {}
}
</file>

<file path="main/java/ninja/trek/pocketportals/dimension/PocketDimensionJsonProvider.java">
package ninja.trek.pocketportals.dimension;
import com.google.gson.JsonObject;
import net.fabricmc.fabric.api.datagen.v1.FabricDataOutput;
import net.minecraft.data.DataProvider;
import net.minecraft.data.DataWriter;
import net.minecraft.util.Identifier;
import ninja.trek.pocketportals.PocketPortals;
import java.util.concurrent.CompletableFuture;
public class PocketDimensionJsonProvider implements DataProvider {
    private final FabricDataOutput output;
    private static final long DIMENSION_SEED = 12345678L; // Added seed constant
    public PocketDimensionJsonProvider(FabricDataOutput output) {
        this.output = output;
    }
    @Override
    public CompletableFuture<?> run(DataWriter writer) {
        return CompletableFuture.allOf(
                generateDimensionType(writer),
                generateDimension(writer)
        );
    }
    private CompletableFuture<?> generateDimensionType(DataWriter writer) {
        JsonObject typeJson = new JsonObject();
        typeJson.addProperty("ultrawarm", false);
        typeJson.addProperty("natural", true);
        typeJson.addProperty("coordinate_scale", 1.0);
        typeJson.addProperty("has_skylight", true);
        typeJson.addProperty("has_ceiling", false);
        typeJson.addProperty("ambient_light", 0.0);
        typeJson.addProperty("fixed_time", 6000L);
        typeJson.addProperty("piglin_safe", false);
        typeJson.addProperty("bed_works", true);
        typeJson.addProperty("respawn_anchor_works", false);
        typeJson.addProperty("has_raids", false);
        typeJson.addProperty("logical_height", 384);
        typeJson.addProperty("min_y", -64);
        typeJson.addProperty("height", 384);
        typeJson.addProperty("infiniburn", "#minecraft:infiniburn_overworld");
        typeJson.addProperty("effects", "minecraft:overworld");
        typeJson.addProperty("monster_spawn_light_level", 0);
        typeJson.addProperty("monster_spawn_block_light_limit", 0);
        return DataProvider.writeToPath(
                writer,
                typeJson,
                output.getPath()
                        .resolve("data")
                        .resolve(PocketPortals.MOD_ID)
                        .resolve("dimension_type")
                        .resolve("pocket_dimension_type.json")
        );
    }
    private CompletableFuture<?> generateDimension(DataWriter writer) {
        JsonObject dimensionJson = new JsonObject();
        // Set dimension type
        dimensionJson.addProperty("type", PocketPortals.MOD_ID + ":pocket_dimension_type");
        // Generator settings
        JsonObject generator = new JsonObject();
        generator.addProperty("type", PocketPortals.MOD_ID + ":sky_island");
        generator.addProperty("seed", DIMENSION_SEED); // Added required seed value
        // Biome source configuration
        JsonObject biomeSource = new JsonObject();
        biomeSource.addProperty("type", "minecraft:fixed");
        biomeSource.addProperty("biome", "minecraft:plains");
        generator.add("biome_source", biomeSource);
        // Add generator to main json
        dimensionJson.add("generator", generator);
        return DataProvider.writeToPath(
                writer,
                dimensionJson,
                output.getPath()
                        .resolve("data")
                        .resolve(PocketPortals.MOD_ID)
                        .resolve("dimension")
                        .resolve("pocket_dimension.json")
        );
    }
    @Override
    public String getName() {
        return "Pocket Dimension Configurations";
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/dimension/PocketDimensionsRegistry.java">
package ninja.trek.pocketportals.dimension;
import net.minecraft.registry.RegistryKey;
import net.minecraft.registry.RegistryKeys;
import net.minecraft.server.MinecraftServer;
import net.minecraft.server.world.ServerWorld;
import net.minecraft.util.Identifier;
import net.minecraft.world.World;
import net.minecraft.world.dimension.DimensionType;
import ninja.trek.pocketportals.PocketPortals;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
public class PocketDimensionsRegistry {
    // We now only need one dimension
    private static final RegistryKey<World> DIMENSION_KEY = RegistryKey.of(
            RegistryKeys.WORLD,
            Identifier.of(PocketPortals.MOD_ID, "pocket_dimension")
    );
    public static void init() {
        // No initialization needed anymore
    }
    public static RegistryKey<World> getDimensionKey() {
        return DIMENSION_KEY;
    }
    public static int findUnusedSlot() {
        // This could be enhanced to track used positions if needed
        // For now, just return the next available index
        return 0; // Implement your slot allocation strategy
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/dimension/SkyIslandChunkGenerator.java">
package ninja.trek.pocketportals.dimension;
import com.mojang.serialization.Codec;
import com.mojang.serialization.MapCodec;
import com.mojang.serialization.codecs.RecordCodecBuilder;
import net.minecraft.block.BlockState;
import net.minecraft.block.Blocks;
import net.minecraft.registry.entry.RegistryEntry;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.ChunkRegion;
import net.minecraft.world.HeightLimitView;
import net.minecraft.world.Heightmap;
import net.minecraft.world.biome.Biome;
import net.minecraft.world.biome.source.BiomeAccess;
import net.minecraft.world.biome.source.BiomeSource;
import net.minecraft.world.chunk.Chunk;
import net.minecraft.world.gen.GenerationStep;
import net.minecraft.world.gen.StructureAccessor;
import net.minecraft.world.gen.chunk.Blender;
import net.minecraft.world.gen.chunk.ChunkGenerator;
import net.minecraft.world.gen.chunk.VerticalBlockSample;
import net.minecraft.world.gen.noise.NoiseConfig;
import java.util.List;
import java.util.concurrent.CompletableFuture;
public class SkyIslandChunkGenerator extends ChunkGenerator {
    // Constants for island generation
    private static final int BASE_HEIGHT = 64;
    private static final int ISLAND_RADIUS = 50;
    private static final int ISLAND_HEIGHT = 30;
    private static final double NOISE_SCALE = 0.05;
    public static final MapCodec<SkyIslandChunkGenerator> CODEC = RecordCodecBuilder.mapCodec(instance ->
            instance.group(
                    BiomeSource.CODEC.fieldOf("biome_source").forGetter(ChunkGenerator::getBiomeSource),
                    Codec.LONG.fieldOf("seed").forGetter(gen -> gen.seed)
            ).apply(instance, SkyIslandChunkGenerator::new));
    private final long seed;
    public SkyIslandChunkGenerator(BiomeSource biomeSource, long seed) {
        super(biomeSource);
        this.seed = seed;
    }
    @Override
    protected MapCodec<? extends ChunkGenerator> getCodec() {
        return CODEC;
    }
    private boolean isInIslandRange(int worldX, int worldZ) {
        // Convert to grid coordinates
        int gridX = Math.floorDiv(worldX, ModDimensions.GRID_SPACING);
        int gridZ = Math.floorDiv(worldZ, ModDimensions.GRID_SPACING);
        // Get center of current grid cell
        int centerX = (gridX * ModDimensions.GRID_SPACING) + (ModDimensions.GRID_SPACING / 2);
        int centerZ = (gridZ * ModDimensions.GRID_SPACING) + (ModDimensions.GRID_SPACING / 2);
        // Calculate distance from center of nearest island
        double dx = worldX - centerX;
        double dz = worldZ - centerZ;
        double distanceSquared = dx * dx + dz * dz;
        return distanceSquared <= ISLAND_RADIUS * ISLAND_RADIUS;
    }
    private double getNoise(int x, int z) {
        double nx = x * NOISE_SCALE;
        double nz = z * NOISE_SCALE;
        return Math.sin(nx) * Math.cos(nz) * 5.0;
    }
    private int getIslandHeight(int x, int z) {
        if (!isInIslandRange(x, z)) {
            return -1; // Not on an island
        }
        // Get grid coordinates
        int gridX = Math.floorDiv(x, ModDimensions.GRID_SPACING);
        int gridZ = Math.floorDiv(z, ModDimensions.GRID_SPACING);
        // Get center of current grid cell
        int centerX = (gridX * ModDimensions.GRID_SPACING) + (ModDimensions.GRID_SPACING / 2);
        int centerZ = (gridZ * ModDimensions.GRID_SPACING) + (ModDimensions.GRID_SPACING / 2);
        // Calculate distance from center and normalize
        double dx = x - centerX;
        double dz = z - centerZ;
        double distance = Math.sqrt(dx * dx + dz * dz);
        double normalizedDist = distance / ISLAND_RADIUS;
        // Calculate height with smooth falloff and noise
        double falloff = 1.0 - (normalizedDist * normalizedDist); // Quadratic falloff
        double noiseHeight = getNoise(x, z);
        return BASE_HEIGHT + (int)(ISLAND_HEIGHT * falloff) + (int)noiseHeight;
    }
    @Override
    public void buildSurface(ChunkRegion region, StructureAccessor structures, NoiseConfig noiseConfig, Chunk chunk) {
        BlockPos.Mutable mutable = new BlockPos.Mutable();
        int chunkX = chunk.getPos().x * 16;
        int chunkZ = chunk.getPos().z * 16;
        for (int x = 0; x < 16; x++) {
            for (int z = 0; z < 16; z++) {
                int worldX = chunkX + x;
                int worldZ = chunkZ + z;
                int height = getIslandHeight(worldX, worldZ);
                if (height > 0) {
                    // Get biome for this position
                    RegistryEntry<Biome> biome = region.getBiome(mutable.set(worldX, height, worldZ));
                    BlockState topBlock = BiomeSurfaceCache.getTopBlock(biome.getKey().get().getValue());
                    BlockState underBlock = BiomeSurfaceCache.getUnderBlock(biome.getKey().get().getValue());
                    // Build the column
                    for (int y = height - 5; y <= height; y++) {
                        mutable.set(worldX, y, worldZ);
                        if (y == height) {
                            region.setBlockState(mutable, topBlock, 3);
                        } else {
                            region.setBlockState(mutable, underBlock, 3);
                        }
                    }
                }
            }
        }
    }
    @Override
    public CompletableFuture<Chunk> populateNoise(Blender blender, NoiseConfig noiseConfig,
                                                  StructureAccessor structureAccessor, Chunk chunk) {
        return CompletableFuture.completedFuture(chunk);
    }
    @Override
    public int getHeight(int x, int z, Heightmap.Type heightmap, HeightLimitView world, NoiseConfig noiseConfig) {
        int height = getIslandHeight(x, z);
        return height > 0 ? height : world.getBottomY();
    }
    @Override
    public VerticalBlockSample getColumnSample(int x, int z, HeightLimitView world, NoiseConfig noiseConfig) {
        int height = getIslandHeight(x, z);
        BlockState[] states = new BlockState[world.getHeight()];
        if (height > 0) {
            for (int y = 0; y < world.getHeight(); y++) {
                if (y < height - 5) {
                    states[y] = Blocks.AIR.getDefaultState();
                } else if (y < height) {
                    states[y] = Blocks.DIRT.getDefaultState();
                } else if (y == height) {
                    states[y] = Blocks.GRASS_BLOCK.getDefaultState();
                } else {
                    states[y] = Blocks.AIR.getDefaultState();
                }
            }
        } else {
            for (int y = 0; y < world.getHeight(); y++) {
                states[y] = Blocks.AIR.getDefaultState();
            }
        }
        return new VerticalBlockSample(world.getBottomY(), states);
    }
    // Required method implementations
    @Override
    public void carve(ChunkRegion region, long seed, NoiseConfig noiseConfig, BiomeAccess biomeAccess,
                      StructureAccessor structureAccessor, Chunk chunk, GenerationStep.Carver carverStep) {
        // No carving in sky islands
    }
    @Override
    public void populateEntities(ChunkRegion region) {
        // Optional: Add entity spawning logic here
    }
    @Override
    public int getWorldHeight() {
        return 384; // Matches vanilla world height
    }
    @Override
    public int getSeaLevel() {
        return -64; // No sea in sky islands
    }
    @Override
    public int getMinimumY() {
        return -64;
    }
    @Override
    public void getDebugHudText(List<String> text, NoiseConfig noiseConfig, BlockPos pos) {
        text.add("Sky Island Generator");
        text.add("Position: " + pos.getX() + ", " + pos.getY() + ", " + pos.getZ());
        text.add("Island Height: " + getIslandHeight(pos.getX(), pos.getZ()));
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/item/ModItems.java">
package ninja.trek.pocketportals.item;
import net.minecraft.item.Item;
import net.minecraft.registry.Registries;
import net.minecraft.registry.Registry;
import net.minecraft.util.Identifier;
import ninja.trek.pocketportals.PocketPortals;
public class ModItems {
    // Register a custom PocketPortalItem so we can store dimension index in its NBT
    public static final PocketPortalItem POCKET_PORTAL = new PocketPortalItem(
            new Item.Settings().maxCount(1) // non-stackable
    );
    public static void registerItems() {
        Registry.register(
                Registries.ITEM,
                Identifier.of(PocketPortals.MOD_ID, "pocket_portal"),
                POCKET_PORTAL
        );
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/item/PocketPortalItem.java">
package ninja.trek.pocketportals.item;
import net.minecraft.item.BlockItem;
import net.minecraft.item.ItemStack;
import net.minecraft.item.tooltip.TooltipType;
import net.minecraft.text.Text;
import net.minecraft.util.Formatting;
import net.minecraft.world.World;
import ninja.trek.pocketportals.block.ModBlocks;
import org.jetbrains.annotations.Nullable;
import java.util.List;
import static ninja.trek.pocketportals.data.PocketPortalDataTypes.DIMENSION_INDEX;
/**
 * Custom PocketPortalItem that reads the dimension index from
 * Fabric Data Components for its tooltip (instead of raw NBT).
 */
public class PocketPortalItem extends BlockItem {
    public PocketPortalItem(Settings settings) {
        super(ModBlocks.POCKET_PORTAL, settings);
    }
    @Override
    public void appendTooltip(
            ItemStack stack,
            TooltipContext context,
            List<Text> tooltip,
            TooltipType type
    ) {
        // 1) Let the parent BlockItem do any default work
        super.appendTooltip(stack, context, tooltip, type);
        // 2) Fetch our dimension index from Fabric Data Components
        Integer index = stack.get(DIMENSION_INDEX); // If none set, returns null
        // 3) Show a line of text based on that index
        if (index != null) {
            tooltip.add(Text.literal("Bound to dimension index: " + index)
                    .formatted(Formatting.GRAY));
        } else {
            tooltip.add(Text.literal("Unlinked").formatted(Formatting.DARK_GRAY));
        }
    }
}
</file>

<file path="main/java/ninja/trek/pocketportals/mixin/ExampleMixin.java">
package ninja.trek.pocketportals.mixin;
import net.minecraft.server.MinecraftServer;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(MinecraftServer.class)
public class ExampleMixin {
	@Inject(at = @At("HEAD"), method = "loadWorld")
	private void init(CallbackInfo info) {
		// This code is injected into the start of MinecraftServer.loadWorld()V
	}
}
</file>

<file path="main/java/ninja/trek/pocketportals/PocketPortals.java">
package ninja.trek.pocketportals;
import net.fabricmc.api.ModInitializer;
import net.fabricmc.fabric.api.event.lifecycle.v1.ServerLifecycleEvents;
import ninja.trek.pocketportals.block.ModBlocks;
import ninja.trek.pocketportals.data.DataLoader;
import ninja.trek.pocketportals.dimension.ModDimensions;
import ninja.trek.pocketportals.dimension.PocketDimensionsRegistry;
import ninja.trek.pocketportals.item.ModItems;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class PocketPortals implements ModInitializer {
	public static final String MOD_ID = "pocket-portals";
	public static final Logger LOGGER = LoggerFactory.getLogger(MOD_ID);
	@Override
	public void onInitialize() {
		// Register data loader first
		DataLoader.register();
		// Register dimension system first
		PocketDimensionsRegistry.init();
		ModDimensions.register();
		// Then register blocks and items that might depend on dimensions
		ModBlocks.registerBlocks();
		ModItems.registerItems();
		LOGGER.info("EndNew mod initialized!");
	}
}
</file>

<file path="main/java/ninja/trek/pocketportals/PocketPortalsDataGenerator.java">
package ninja.trek.pocketportals;
import net.fabricmc.fabric.api.datagen.v1.DataGeneratorEntrypoint;
import net.fabricmc.fabric.api.datagen.v1.FabricDataGenerator;
import net.fabricmc.fabric.api.datagen.v1.provider.*;
import net.minecraft.data.client.*;
import net.minecraft.data.server.recipe.RecipeExporter;
import net.minecraft.registry.RegistryWrapper;
import net.minecraft.util.Identifier;
import ninja.trek.pocketportals.block.ModBlocks;
import ninja.trek.pocketportals.dimension.PocketDimensionJsonProvider;
import ninja.trek.pocketportals.item.ModItems;
import net.minecraft.item.Items;
import net.minecraft.recipe.book.RecipeCategory;
import net.minecraft.data.server.recipe.ShapedRecipeJsonBuilder;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
public class PocketPortalsDataGenerator implements DataGeneratorEntrypoint {
    @Override
    public void onInitializeDataGenerator(FabricDataGenerator fabricDataGenerator) {
        FabricDataGenerator.Pack pack = fabricDataGenerator.createPack();
        // Models and Blockstates
        pack.addProvider((output, registriesLookup) -> new FabricModelProvider(output) {
            @Override
            public void generateBlockStateModels(BlockStateModelGenerator blockStateModelGenerator) {
                // Register block models
                blockStateModelGenerator.registerSimpleCubeAll(ModBlocks.POCKET_PORTAL);
                blockStateModelGenerator.registerSimpleState(ModBlocks.POCKET_PORTAL_FRAME);
            }
            @Override
            public void generateItemModels(ItemModelGenerator itemModelGenerator) {
                // Generate item model for the portal item using the block texture
                TextureMap portalTexture = new TextureMap()
                        .put(TextureKey.LAYER0, Identifier.of(PocketPortals.MOD_ID, "block/pocket_portal"));
                Model portalModel = new Model(Optional.empty(), Optional.empty(), TextureKey.LAYER0);
                itemModelGenerator.register(ModItems.POCKET_PORTAL, portalModel);
            }
        });
        // Rest of providers remain unchanged
        pack.addProvider((output, registriesLookup) -> new FabricRecipeProvider(output, registriesLookup) {
            @Override
            public void generate(RecipeExporter exporter) {
                ShapedRecipeJsonBuilder.create(RecipeCategory.MISC, ModItems.POCKET_PORTAL)
                        .pattern("OEO")
                        .pattern("EDE")
                        .pattern("OEO")
                        .input('O', Items.OBSIDIAN)
                        .input('E', Items.ENDER_PEARL)
                        .input('D', Items.DIAMOND)
                        .criterion(hasItem(Items.ENDER_PEARL), conditionsFromItem(Items.ENDER_PEARL))
                        .offerTo(exporter, Identifier.of(PocketPortals.MOD_ID, "pocket_portal"));
            }
        });
        pack.addProvider((output, registriesLookup) -> new FabricBlockLootTableProvider(output, registriesLookup) {
            @Override
            public void generate() {
                addDrop(ModBlocks.POCKET_PORTAL);
                addDrop(ModBlocks.POCKET_PORTAL_FRAME, drops(ModBlocks.POCKET_PORTAL_FRAME));
            }
        });
        pack.addProvider((output, registriesLookup) -> new FabricLanguageProvider(output, registriesLookup) {
            @Override
            public void generateTranslations(RegistryWrapper.WrapperLookup wrapperLookup, TranslationBuilder translationBuilder) {
                translationBuilder.add(ModBlocks.POCKET_PORTAL, "Pocket Portal");
                translationBuilder.add(ModBlocks.POCKET_PORTAL_FRAME, "Pocket Portal Frame");
                translationBuilder.add("itemGroup.pocket-portals.main", "Pocket Portals");
            }
        });
        pack.addProvider(PocketDimensionJsonProvider::new);
    }
}
</file>

<file path="main/resources/assets/pocket-portals/models/block/pocket_portal_frame.json">
{
  "parent": "block/cube",
  "textures": {
    "particle": "block/nether_portal",
    "portal": "block/nether_portal"
  },
  "elements": [
    {
      "from": [0, 0, 0],
      "to": [16, 16, 16],
      "faces": {
        "north": {"uv": [0, 0, 16, 16], "texture": "portal"},
        "east": {"uv": [0, 0, 16, 16], "texture": "portal"},
        "south": {"uv": [0, 0, 16, 16], "texture": "portal"},
        "west": {"uv": [0, 0, 16, 16], "texture": "portal"},
        "up": {"uv": [0, 0, 16, 16], "texture": "portal"},
        "down": {"uv": [0, 0, 16, 16], "texture": "portal"}
      }
    }
  ]
}
</file>

<file path="main/resources/fabric.mod.json">
{
	"schemaVersion": 1,
	"id": "pocket-portals",
	"version": "${version}",
	"name": "Pocket Portals",
	"description": "This is an example description! Tell everyone what your mod is about!",
	"authors": [
		"Me!"
	],
	"contact": {
		"homepage": "https://fabricmc.net/",
		"sources": "https://github.com/FabricMC/fabric-example-mod"
	},
	"license": "CC0-1.0",
	"icon": "assets/pocket-portals/icon.png",
	"environment": "*",
	"entrypoints": {
		"main": [
			"ninja.trek.pocketportals.PocketPortals"
		],
		"client": [
			"ninja.trek.pocketportals.PocketPortalsClient"
		],
		"fabric-datagen": [
			"ninja.trek.pocketportals.PocketPortalsDataGenerator"
		]
	},
	"mixins": [
		"pocket-portals.mixins.json",
		{
			"config": "pocket-portals.client.mixins.json",
			"environment": "client"
		}
	],
	"depends": {
		"fabricloader": ">=0.16.10",
		"minecraft": "~1.21",
		"java": ">=21",
		"fabric-api": "*"
	},
	"suggests": {
		"another-mod": "*"
	}
}
</file>

<file path="main/resources/pocket-portals.mixins.json">
{
	"required": true,
	"package": "ninja.trek.pocketportals.mixin",
	"compatibilityLevel": "JAVA_21",
	"mixins": [
		"ExampleMixin"
	],
	"injectors": {
		"defaultRequire": 1
	}
}
</file>

<file path="repomixx.bat">
repomix --style xml --remove-empty-lines --copy --ignore "**/generated/**"
</file>

</files>
